Index: include/ode/objects.h
===================================================================
--- include/ode/objects.h	(revision 1730)
+++ include/ode/objects.h	(working copy)
@@ -1722,6 +1722,12 @@
 ODE_API void dJointSetData (dJointID, void *data);
 
 /**
+ * @brief Set the user-data pointer
+ * @ingroup joints
+ */
+ODE_API void dJointSetDamping (dJointID, dReal damping);
+
+/**
  * @brief Get the user-data pointer
  * @ingroup joints
  */
Index: include/ode/misc.h
===================================================================
--- include/ode/misc.h	(revision 1730)
+++ include/ode/misc.h	(working copy)
@@ -57,8 +57,11 @@
 #ifdef __cplusplus
 ODE_API void dPrintMatrix (const dReal *A, int n, int m, char *fmt = "%10.4f ",
 		   FILE *f=stdout);
+ODE_API void dPrintIntMatrix (const int *A, int n, int m, char *fmt = "%5d ",
+		   FILE *f=stdout);
 #else
 ODE_API void dPrintMatrix (const dReal *A, int n, int m, char *fmt, FILE *f);
+ODE_API void dPrintIntMatrix (const int *A, int n, int m, char *fmt, FILE *f);
 #endif
 
 /* make a random vector with entries between +/- range. A has n elements. */
Index: configure.in
===================================================================
--- configure.in	(revision 1730)
+++ configure.in	(working copy)
@@ -1,7 +1,9 @@
 dnl AC_INIT does not take a macro as a version nr: set it separately! - Bram
-AC_INIT([ODE],[0.11.1],[ode@ode.org])
+# add another minor for wg
+AC_INIT([ODE],[0.11.1.1],[ode@ode.org])
 # AC_CONFIG_SRCDIR([ode/src/ode.cpp])
-ODE_RELEASE=0.11.1
+# add another minor for wg
+ODE_RELEASE=0.11.1.1
 AC_SUBST(ODE_RELEASE)
 
 # Those are instructions from the Libtool manual:
Index: ode/src/collision_space.cpp
===================================================================
--- ode/src/collision_space.cpp	(revision 1730)
+++ ode/src/collision_space.cpp	(working copy)
@@ -168,7 +168,10 @@
 
   // add
   geom->parent_space = this;
-  geom->spaceAdd (&first);
+  {
+    boost::mutex::scoped_lock lock(this->mutex);
+    geom->spaceAdd (&first);  // lock mutex before alterning linked list
+  }
   count++;
 
   // enumerator has been invalidated
@@ -189,7 +192,10 @@
   dUASSERT (geom->parent_space == this,"object is not in this space");
 
   // remove
-  geom->spaceRemove();
+  {
+    boost::mutex::scoped_lock lock(this->mutex);
+    geom->spaceRemove();  // lock mutex before alterning linked list
+  }
   count--;
 
   // safeguard
@@ -208,6 +214,7 @@
 
 void dxSpace::dirty (dxGeom *geom)
 {
+  boost::mutex::scoped_lock lock(this->mutex);  // lock mutex before alterning linked list
   geom->spaceRemove();
   geom->spaceAdd (&first);
 }
Index: ode/src/quickstep.cpp
===================================================================
--- ode/src/quickstep.cpp	(revision 1730)
+++ ode/src/quickstep.cpp	(working copy)
@@ -63,6 +63,8 @@
 
 #define RANDOMLY_REORDER_CONSTRAINTS 1
 
+#define USE_JOINT_DAMPING
+
 //****************************************************************************
 // special matrix multipliers
 
@@ -343,7 +345,12 @@
   const int m, const int nb, dRealMutablePtr J, int *jb, dxBody * const *body,
   dRealPtr invI, dRealMutablePtr lambda, dRealMutablePtr fc, dRealMutablePtr b,
   dRealPtr lo, dRealPtr hi, dRealPtr cfm, const int *findex,
-  const dxQuickStepParameters *qs)
+  const dxQuickStepParameters *qs,
+#ifdef USE_JOINT_DAMPING
+  const int m_damp,dRealMutablePtr J_damp, dRealPtr coeff_damp, int *jb_damp,dRealMutablePtr v_damp,
+  dRealMutablePtr f_damp,dRealMutablePtr v_joint_damp, dRealPtr JiM, // damping related
+#endif
+  const dReal stepsize) // for updating v_damp along the way
 {
 #ifdef WARM_STARTING
   {
@@ -384,6 +391,14 @@
     }
   }
 
+
+  /********************************/
+  /* allocate for J*invM*f_damp   */
+  /* which is a mX1 column vector */
+  /********************************/
+  dReal *Adcfm = context->AllocateArray<dReal> (m);
+
+
   {
     // NOTE: This may seem unnecessary but it's indeed an optimization 
     // to move multiplication by Ad[i] and cfm[i] out of iteration loop.
@@ -397,7 +412,7 @@
       }
       b[i] *= Ad_i;
       // scale Ad by CFM. N.B. this should be done last since it is used above
-      Ad[i] = Ad_i * cfm[i];
+      Adcfm[i] = Ad_i * cfm[i];
     }
   }
 
@@ -430,6 +445,10 @@
   dReal *last_lambda = context->AllocateArray<dReal> (m);
 #endif
 
+#ifdef USE_JOINT_DAMPING
+  dReal *b_damp = context->AllocateArray<dReal> (m);
+#endif
+
   const int num_iterations = qs->num_iterations;
   for (int iteration=0; iteration < num_iterations; iteration++) {
 
@@ -481,6 +500,7 @@
     }
 #endif
 
+    dReal rms_error = 0;
     for (int i=0; i<m; i++) {
       // @@@ potential optimization: we could pre-sort J and iMJ, thereby
       //     linearizing access to those arrays. hmmm, this does not seem
@@ -500,10 +520,52 @@
         fc_ptr2 = (b2 >= 0) ? fc + 6*b2 : NULL;
       }
 
+#ifdef USE_JOINT_DAMPING
+      /*************************************************************/
+      /* compute b_damp                                            */
+      /* b is to be modified by b_damp                             */
+      /* where b_damp = -J*inv(M)*f_damp / Ad  (since b is rhs/Ad) */
+      /*                                                           */
+      /* initially f_damp is 0, so motion is undamped on first     */
+      /* iteration.                                                */
+      /*                                                           */
+      /*************************************************************/
+      {
+        b_damp[index] = 0;
+        int b1 = jb[index*2];
+        int b2 = jb[index*2+1];
+        dRealMutablePtr f_damp_ptr1 = f_damp + 6*b1;
+        dRealMutablePtr f_damp_ptr2 = (b2 >= 0) ? f_damp + 6*b2 : NULL;
+   
+        dRealPtr JiM_ptr = JiM + index*12;
+
+        // compute b_damp = JiM * f_damp, b_damp is preset to zero already
+        for (int j=0;j<6;j++) {
+          b_damp[index] += JiM_ptr[j] * f_damp_ptr1[j];
+          if (b2>=0) b_damp[index] += JiM_ptr[j+6] * f_damp_ptr2[j];
+        }
+   
+        // and scale JiM by Ad
+        b_damp[index] *= Ad[index];
+        // FIXME: find some kind of limiters that works as artificial dampers
+        // b_damp must make b smaller
+        // so b_damp must have opposite sign as b
+        // and abs(b_damp) < abs(b)
+        //if (b_damp[index]*b[index]>0) b_damp[index]=0;
+        //if (dFabs(b_damp[index])>dFabs(b[index])) b_damp[index]=-b[index];
+      }
+#endif
+
       dReal old_lambda = lambda[index];
 
       {
-        delta = b[index] - old_lambda*Ad[index];
+        delta = b[index] - old_lambda*Adcfm[index];
+#ifdef USE_JOINT_DAMPING
+        /***************************************************************************/
+        /* b is to be modified by b_damp = -J*inv(M)*f_damp / Ad since b is rhs/Ad */
+        /***************************************************************************/
+        delta += b_damp[index];
+#endif
 
         dRealPtr J_ptr = J + index*12;
         // @@@ potential optimization: SIMD-ize this and the b2 >= 0 case
@@ -553,6 +615,8 @@
           lambda[index] = new_lambda;
         }
       }
+      // get a measure of error
+      rms_error += delta*delta/(dReal)m;
 
       //@@@ a trick that may or may not help
       //dReal ramp = (1-((dReal)(iteration+1)/(dReal)num_iterations));
@@ -579,8 +643,98 @@
           fc_ptr2[5] += delta * iMJ_ptr[11];
         }
       }
+
+    } // end of for loop on m
+    rms_error = sqrt(rms_error);
+
+#ifdef USE_JOINT_DAMPING
+    /****************************************************************/
+    /* compute v_damp per fc update                                 */
+    /*   based on all external forces fe, fc, f_damp                */
+    /*   v_damp should have started out same as v(n)                */
+    /*   v_damp should end up being v(n+1)                          */
+    /*                                                              */
+    /*  v_damp = v_current + stepsize * invM * f_all                */
+    /*                                                              */
+    /****************************************************************/
+    {
+      IFTIMING (dTimerNow ("velocity update due to f_damp"));
+      const dReal *invIrow = invI;
+      dRealMutablePtr f_damp_ptr = f_damp;
+      dRealMutablePtr v_damp_ptr = v_damp;
+      dxBody *const *const bodyend = body + nb;
+      const dReal *fc_ptr = fc;
+
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; fc_ptr+=6, invIrow += 12, f_damp_ptr+=6, v_damp_ptr+=6, bodycurr++) {
+        // f_damp should be updated in SOR LCP
+
+        // compute the velocity update:
+        // add stepsize * invM * f_damp to the body velocity
+        dxBody *b = *bodycurr;
+        dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+        dReal tmp3[3];
+        for (int j=0; j<3; j++) {
+          // note that cforce(fc) is really not a force but an acceleration, hence there is
+          // no premultiplying of invM here (compare to update due to external force 'facc' below)
+          // add stepsize * cforce(fc) to the body velocity
+          v_damp_ptr[j]   = b->lvel[j] + stepsize * fc_ptr[j]   + body_invMass_mul_stepsize * ( b->facc[j] + f_damp_ptr[j] );
+          v_damp_ptr[j+3] = b->avel[j] + stepsize * fc_ptr[j+3];
+
+          // accumulate step*torques
+          tmp3[j] = stepsize*(b->tacc[j] + f_damp_ptr[j+3]);
+        }
+        // v_damp = invI * f_damp
+        dMultiplyAdd0_331 (v_damp_ptr+3, invIrow, tmp3);
+
+      }
     }
-  }
+
+    /****************************************************************/
+    /* compute f_damp per v_damp update                             */
+    /* compute damping force f_damp = J_damp' * B * J_damp * v_damp */
+    /*                                                              */
+    /*  we probably want to apply some kind of limiter on f_damp    */
+    /*  based on changes in v_damp.                                 */
+    /*                                                              */
+    /*  for starters, ramp up damping to increase stability.        */
+    /*                                                              */
+    /****************************************************************/
+    {
+      dSetZero (f_damp,6*nb); // reset f_damp, following update skips around, so cannot set to 0 inline
+      dRealPtr J_damp_ptr = J_damp;
+      // compute f_damp and velocity updates
+      // first compute v_joint_damp = J_damp * v_damp
+      // v_joint_damp is m_damp X 1 single column vector
+      for (int j=0; j<m_damp;J_damp_ptr+=12, j++) {
+        int b1 = jb_damp[j*2];
+        int b2 = jb_damp[j*2+1];
+        v_joint_damp[j] = 0;
+        // ramp-up
+        dReal alpha = (dReal)iteration / (dReal)num_iterations;
+        for (int k=0;k<6;k++) v_joint_damp[j] += alpha*J_damp_ptr[k] * v_damp[b1*6+k];
+        if (b2 >= 0) for (int k=0;k<6;k++) v_joint_damp[j] += alpha*J_damp_ptr[k+6] * v_damp[b2*6+k];
+        // multiply by damping coefficients (B is diagnoal)
+        v_joint_damp[j] *= coeff_damp[j];
+
+        // so now v_joint_damp = B * J_damp * v_damp
+        // update f_damp = J_damp' * v_joint_damp
+        for (int k=0; k<6; k++) f_damp[b1*6+k] -= J_damp_ptr[k]*v_joint_damp[j];
+        if (b2 >= 0) for (int k=0; k<6; k++) f_damp[b2*6+k] -= J_damp_ptr[6+k]*v_joint_damp[j];
+      }
+
+    }
+#endif
+
+    dReal rms_error_tolerance = 1e-12;
+    if (rms_error < rms_error_tolerance)
+    {
+      printf("CONVERGED: %d steps, rms(%f)\n",iteration,rms_error);
+      break;
+    }
+    else if (iteration == num_iterations -1)
+      printf("ERROR: did not converge in %d steps, rms(%f)\n",num_iterations,rms_error);
+
+  } // end of for loop on iterations
 }
 
 struct dJointWithInfo1
@@ -589,7 +743,7 @@
   dxJoint::Info1 info;
 };
 
-void dxQuickStepper (dxWorldProcessContext *context, 
+void dxQuickStepper (dxWorldProcessContext *shared_context,dxWorldProcessContext *context, 
   dxWorld *world, dxBody * const *body, int nb,
   dxJoint * const *_joint, int _nj, dReal stepsize)
 {
@@ -630,7 +784,21 @@
     }
   }
 
+  // get the masses for every body
+  dReal *invM = context->AllocateArray<dReal> (nb);
   {
+    dReal *invMrow = invM;
+    dxBody *const *const bodyend = body + nb;
+    for (dxBody *const *bodycurr = body; bodycurr != bodyend; invMrow++, bodycurr++) {
+      dxBody *b = *bodycurr;
+      //*invMrow = b->mass.mass;
+      *invMrow = b->invMass;
+
+    }
+  }
+
+
+  {
     // add the gravity force to all bodies
     // since gravity does normally have only one component it's more efficient
     // to run three loops for each individual component
@@ -705,9 +873,40 @@
     mfb = mfbcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  /************************************************************************/
+  /* for joint damping, get the total number of rows for damping jacobian */
+  /************************************************************************/
+  int m_damp; // number of rows for damped joint jacobian
+  {
+    int mcurr = 0;
+    const dJointWithInfo1 *jicurr = jointiinfos; // info1 stored in jointiinfos
+    const dJointWithInfo1 *const jiend = jicurr + nj;
+    for (; jicurr != jiend; jicurr++)
+      if (jicurr->joint->use_damping)
+        mcurr ++;
+
+    m_damp = mcurr;
+  }
+#endif
+
   // if there are constraints, compute the constraint force
   dReal *J = NULL;
   int *jb = NULL;
+
+#ifdef USE_JOINT_DAMPING
+  /*********************************/
+  /* do the same for damped joints */
+  /*********************************/
+  dReal *v_damp;
+  dReal *J_damp = NULL;
+  dReal *v_joint_damp = NULL;
+  dReal* f_damp = NULL;
+  dReal *JiM = NULL;
+  int *jb_damp = NULL;
+  dReal *coeff_damp = NULL;
+#endif
+
   if (m > 0) {
     dReal *cfm, *lo, *hi, *rhs, *Jcopy;
     int *findex;
@@ -740,8 +939,49 @@
       rhs = context->AllocateArray<dReal> (mlocal);
 
       Jcopy = context->AllocateArray<dReal> (mfb*12);
+
+#ifdef USE_JOINT_DAMPING
+      JiM = context->AllocateArray<dReal> (mlocal*12); // for computing b_damp
+      dSetZero (JiM,jelements);
+#endif
     }
 
+#ifdef USE_JOINT_DAMPING
+    /*********************************/
+    /* for damped joints             */
+    /*********************************/
+    {
+      int mlocal = m_damp;
+
+      const unsigned jelements = mlocal*12;
+      J_damp = context->AllocateArray<dReal> (jelements);
+      dSetZero (J_damp,jelements);
+
+      // v_joint = J_damp * v
+      // v_joint is the velocity of the joint in joint space
+      // (relative angular rates of attached bodies)
+      const unsigned v_joint_damp_elements = mlocal;
+      v_joint_damp = context->AllocateArray<dReal> (v_joint_damp_elements);
+      dSetZero (v_joint_damp,v_joint_damp_elements);
+
+      // jb is the body index for each jacobian
+      const unsigned jbelements = mlocal*2;
+      jb_damp = context->AllocateArray<int> (jbelements);
+
+      const unsigned f_damp_elements = nb*6;
+      f_damp = context->AllocateArray<dReal> (f_damp_elements);
+      dSetZero (f_damp,f_damp_elements);
+
+      const unsigned v_damp_elements = nb*6;
+      v_damp = context->AllocateArray<dReal> (v_damp_elements);
+      dSetZero (v_damp,v_damp_elements);
+
+      const unsigned coeffelements = mlocal;
+      coeff_damp = context->AllocateArray<dReal> (coeffelements);
+      dSetZero (coeff_damp,coeffelements);
+    }
+#endif
+
     BEGIN_STATE_SAVE(context, cstate) {
       dReal *c = context->AllocateArray<dReal> (m);
       dSetZero (c, m);
@@ -753,9 +993,9 @@
         // format:
         //
         //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 \    .
-        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2  }-- jacobian for joint 0, body 1 and body 2 (3 rows)
+        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2  )-- jacobian for joint 0, body 1 and body 2 (3 rows)
         //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 /
-        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 }--- jacobian for joint 1, body 1 and body 2 (3 rows)
+        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 )--- jacobian for joint 1, body 1 and body 2 (3 rows)
         //   etc...
         //
         //   (lll) = linear jacobian data
@@ -768,6 +1008,9 @@
 
         dReal *Jcopyrow = Jcopy;
         unsigned ofsi = 0;
+#ifdef USE_JOINT_DAMPING
+        unsigned ofsi_damp = 0; // for joint damping
+#endif
         const dJointWithInfo1 *jicurr = jointiinfos;
         const dJointWithInfo1 *const jiend = jicurr + nj;
         for (; jicurr != jiend; jicurr++) {
@@ -781,7 +1024,32 @@
           Jinfo.lo = lo + ofsi;
           Jinfo.hi = hi + ofsi;
           Jinfo.findex = findex + ofsi;
+
+
+
+#ifdef USE_JOINT_DAMPING
+          /*******************************************************/
+          /*  allocate space for damped joint Jacobians          */
+          /*******************************************************/
+          if (jicurr->joint->use_damping)
+          {
+            // damping coefficient is in jicurr->info.damping_coefficient);
+            coeff_damp[ofsi_damp] = jicurr->joint->damping_coefficient;
+
+            // setup joint damping pointers so getinfo2 will fill in J_damp
+            dReal *const Jrow_damp = J_damp + ofsi_damp * 12;
+            Jinfo.J1ld = Jrow_damp;
+            Jinfo.J1ad = Jrow_damp + 3;
+            Jinfo.J2ld = Jrow_damp + 6;
+            Jinfo.J2ad = Jrow_damp + 9;
+            // one row of constraint per joint
+            ofsi_damp ++;
+          }
+#endif
+
+
           
+          // now write all information into J
           dxJoint *joint = jicurr->joint;
           joint->getInfo2 (&Jinfo);
 
@@ -829,6 +1097,35 @@
         dIASSERT (jb_ptr == jb+2*m);
       }
 
+#ifdef USE_JOINT_DAMPING
+      {
+        /*************************************************************/
+        /* create an array of body numbers for each damped joint row */
+        /*************************************************************/
+        int *jb_damp_ptr = jb_damp;
+        const dJointWithInfo1 *jicurr = jointiinfos;
+        const dJointWithInfo1 *const jiend = jicurr + nj;
+        for (; jicurr != jiend; jicurr++) {
+          if (jicurr->joint->use_damping)
+          {
+            dxJoint *joint = jicurr->joint;
+            const int infom = 1; // one damping jacobian row per hinge joint
+
+            int b1 = (joint->node[0].body) ? (joint->node[0].body->tag) : -1;
+            int b2 = (joint->node[1].body) ? (joint->node[1].body->tag) : -1;
+            for (int j=0; j<infom; j++) {
+              jb_damp_ptr[0] = b1;
+              jb_damp_ptr[1] = b2;
+              jb_damp_ptr += 2;
+            }
+          }
+        }
+        dIASSERT (jb_damp_ptr == jb_damp+2*m_damp);
+      }
+#endif
+
+
+
       BEGIN_STATE_SAVE(context, tmp1state) {
         IFTIMING (dTimerNow ("compute rhs"));
         // compute the right hand side `rhs'
@@ -847,6 +1144,40 @@
 
         // put J*tmp1 into rhs
         multiply_J (m,J,jb,tmp1,rhs);
+
+#ifdef USE_JOINT_DAMPING
+        /*************************************************************/
+        /* compute J*inv(M) here JiM, it does not change             */
+        /* where b_damp = -J*inv(M)*f_damp / Ad  (since b is rhs/Ad) */
+        /* and b is to be modified by b_damp                         */
+        /*************************************************************/
+        {
+          dRealPtr J_ptr = J;
+          dRealMutablePtr JiM_ptr = JiM; // intermediate solution storage
+          for (int i=0; i<m;J_ptr+=12,JiM_ptr+=12, i++) {
+
+            // compute JiM = J * invM
+            int b1 = jb[i*2];
+            int b2 = jb[i*2+1];
+            dReal k1 = body[b1]->invMass;
+
+            for (int j=0; j<3 ; j++) JiM_ptr[j] = J_ptr[j]*k1;
+
+
+            const dReal *invI_ptr1 = invI + 12*b1;
+            for (int j=0;j<3;j++) for (int k=0;k<3;k++){
+              JiM_ptr[3+j] += J_ptr[3+k]*invI_ptr1[k*4+j];
+            }
+
+            if (b2 >= 0){
+              dReal k2 = body[b2]->invMass;
+              for (int j=0; j<3 ; j++) JiM_ptr[j+6] += k2*J_ptr[j+6];
+              const dReal *invI_ptr2 = invI + 12*b2;
+              for (int j=0;j<3;j++) for (int k=0;k<3;k++) JiM_ptr[9+j] += J_ptr[9+k]*invI_ptr2[k*4+j];
+            }
+          }
+        }
+#endif
       
       } END_STATE_SAVE(context, tmp1state);
 
@@ -858,6 +1189,29 @@
 
     } END_STATE_SAVE(context, cstate);
 
+
+#ifdef USE_JOINT_DAMPING
+    /***************************************************************************/
+    /* create a nb*6 by 1 vector (v_damp) to store estimated implicit velocity */
+    /*  as it is updated in the iterative loop                                 */
+    /***************************************************************************/
+    {
+      // allocate v_damp
+      dRealMutablePtr v_damp_ptr = v_damp;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; v_damp_ptr+=6, bodycurr++) {
+        dxBody *b = *bodycurr;
+        v_damp_ptr[0] = b->lvel[0];
+        v_damp_ptr[1] = b->lvel[1];
+        v_damp_ptr[2] = b->lvel[2];
+        v_damp_ptr[3] = b->avel[0];
+        v_damp_ptr[4] = b->avel[1];
+        v_damp_ptr[5] = b->avel[2];
+      }
+    }
+#endif
+
+
     // load lambda from the value saved on the previous iteration
     dReal *lambda = context->AllocateArray<dReal> (m);
 
@@ -874,12 +1228,19 @@
     }
 #endif
 
+
+
     dReal *cforce = context->AllocateArray<dReal> (nb*6);
 
+
     BEGIN_STATE_SAVE(context, lcpstate) {
       IFTIMING (dTimerNow ("solving LCP problem"));
       // solve the LCP problem and get lambda and invM*constraint_force
-      SOR_LCP (context,m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs);
+      SOR_LCP (context,m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs,
+#ifdef USE_JOINT_DAMPING
+               m_damp,J_damp,coeff_damp,jb_damp,v_damp,f_damp,v_joint_damp,JiM,
+#endif
+               stepsize);
 
     } END_STATE_SAVE(context, lcpstate);
 
@@ -899,10 +1260,42 @@
     }
 #endif
 
+#ifdef USE_JOINT_DAMPING
+    /****************************************************************/
+    /* perform velocity update due to damping force                 */
+    /*  v_new = n_old + stepsize * invM * f_damp                    */
+    /****************************************************************/
+    {
+      const dReal *invIrow = invI;
+      IFTIMING (dTimerNow ("velocity update due to f_damp"));
+
+      dRealMutablePtr f_damp_ptr = f_damp;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; invIrow += 12, f_damp_ptr+=6, bodycurr++) {
+        // f_damp should be updated in SOR LCP
+
+        // compute the velocity update:
+        // add stepsize * invM * f_damp to the body velocity
+        dxBody *b = *bodycurr;
+        dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+        for (int j=0; j<3; j++) {
+          b->lvel[j] += body_invMass_mul_stepsize * f_damp_ptr[j];
+          f_damp_ptr[3+j] *= stepsize; // multiply torque part by step size
+        }
+        dMultiplyAdd0_331 (b->avel, invIrow, f_damp_ptr+3);
+      }
+
+    }
+#endif
+
+
     // note that the SOR method overwrites rhs and J at this point, so
     // they should not be used again.
-
     {
+      IFTIMING (dTimerNow ("velocity update due to constraint forces"));
+      // note that cforce is really not a force but an acceleration, hence there is
+      // no premultiplying of invM here (compare to update due to external force 'facc' below)
+      //
       // add stepsize * cforce to the body velocity
       const dReal *cforcecurr = cforce;
       dxBody *const *const bodyend = body + nb;
@@ -1033,14 +1426,22 @@
 }
 #endif
 
-static size_t EstimateSOR_LCPMemoryRequirements(int m)
+static size_t EstimateSOR_LCPMemoryRequirements(int m
+#ifdef USE_JOINT_DAMPING
+                                               ,int m_damp
+#endif
+                                               )
 {
   size_t res = dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for iMJ
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Ad
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Adcfm
   res += dEFFICIENT_SIZE(sizeof(IndexError) * m); // for order
 #ifdef REORDER_CONSTRAINTS
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for last_lambda
 #endif
+#ifdef USE_JOINT_DAMPING
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for b_damp
+#endif
   return res;
 }
 
@@ -1069,9 +1470,28 @@
     nj = njcurr; m = mcurr; mfb = mfbcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  int m_damp;
+  {
+    int m_dampcurr = 0;
+    dxJoint::SureMaxInfo info;
+    dxJoint *const *const _jend = _joint + _nj;
+    for (dxJoint *const *_jcurr = _joint; _jcurr != _jend; _jcurr++) {
+      dxJoint *j = *_jcurr;
+      /***************************/
+      /* size for damping joints */
+      /***************************/
+      if (j->use_damping)
+        m_dampcurr ++;
+    }
+    m_damp = m_dampcurr;
+  }
+#endif
+
   size_t res = 0;
 
   res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for invI
+  res += dEFFICIENT_SIZE(sizeof(dReal) * nb); // for invM
 
   {
     size_t sub1_res1 = dEFFICIENT_SIZE(sizeof(dJointWithInfo1) * _nj); // for initial jointiinfos
@@ -1079,10 +1499,20 @@
     size_t sub1_res2 = dEFFICIENT_SIZE(sizeof(dJointWithInfo1) * nj); // for shrunk jointiinfos
     if (m > 0) {
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for J
-      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 12 * m); // for jb
       sub1_res2 += 4 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm, lo, hi, rhs
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 12 * m); // for jb            FIXME: shoulbe be 2 not 12?
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * m); // for findex
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * mfb); // for Jcopy
+
+#ifdef USE_JOINT_DAMPING
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m_damp); // for J_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp ); // for v_joint_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 12 * m_damp); // for jb_damp            FIXME: shoulbe be 2 not 12?
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for f_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12*m); // for JiM
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for v_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp); // for coeff_damp
+#endif
       {
         size_t sub2_res1 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for c
         {
@@ -1096,7 +1526,11 @@
         size_t sub2_res2 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for lambda
         sub2_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for cforce
         {
-          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m); // for SOR_LCP
+          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m
+#ifdef USE_JOINT_DAMPING
+                                                              ,m_damp
+#endif
+                                                              ); // for SOR_LCP
 
           size_t sub3_res2 = 0;
 #ifdef CHECK_VELOCITY_OBEYS_CONSTRAINT
Index: ode/src/util.h
===================================================================
--- ode/src/util.h	(revision 1730)
+++ ode/src/util.h	(working copy)
@@ -23,6 +23,7 @@
 #ifndef _ODE_UTIL_H_
 #define _ODE_UTIL_H_
 
+#define SIZE_MAX ((size_t)(-1))
 #include "objects.h"
 
 
@@ -187,8 +188,8 @@
 
   void CleanupContext();
 
-  void SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints);
-  void RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints);
+  void SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints, size_t const *islandreqs);
+  void RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints, size_t const *&islandreqs);
   void OffsetPreallocations(size_t stOffset);
   void CopyPreallocations(const dxWorldProcessContext *othercontext);
   void ClearPreallocations();
@@ -204,6 +205,7 @@
 
   int m_IslandCount;
   int const *m_pIslandSizes;
+  size_t const *m_pIslandReqs;
   dxBody *const *m_pBodies;
   dxJoint *const *m_pJoints;
 
@@ -216,7 +218,7 @@
 #define BEGIN_STATE_SAVE(context, state) void *state = context->SaveState();
 #define END_STATE_SAVE(context, state) context->RestoreState(state)
 
-typedef void (*dstepper_fn_t) (dxWorldProcessContext *context, 
+typedef void (*dstepper_fn_t) (dxWorldProcessContext *context,dxWorldProcessContext *island_context, 
         dxWorld *world, dxBody * const *body, int nb,
         dxJoint * const *_joint, int _nj, dReal stepsize);
 
Index: ode/src/misc.cpp
===================================================================
--- ode/src/misc.cpp	(revision 1730)
+++ ode/src/misc.cpp	(working copy)
@@ -109,7 +109,17 @@
   }
 }
 
+void dPrintIntMatrix (const int *A, int n, int m, char *fmt, FILE *f)
+{
+  int skip = 1;
+  const int *Arow = A;
+  for (int i=0; i<n; Arow+=skip, ++i) {
+    for (int j=0; j<m; ++j) fprintf (f,fmt,Arow[j]);
+    fprintf (f,"\n");
+  }
+}
 
+
 void dMakeRandomVector (dReal *A, int n, dReal range)
 {
   int i;
Index: ode/src/util.cpp
===================================================================
--- ode/src/util.cpp	(revision 1730)
+++ ode/src/util.cpp	(working copy)
@@ -25,6 +25,8 @@
 #include "objects.h"
 #include "joints/joint.h"
 #include "util.h"
+#include <boost/thread/recursive_mutex.hpp>
+#include <boost/bind.hpp>
 
 static void InternalFreeWorldProcessContext (dxWorldProcessContext *context);
 
@@ -45,17 +47,19 @@
   FreePreallocationsContext();
 }
 
-void dxWorldProcessContext::SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints)
+void dxWorldProcessContext::SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints, size_t const *islandreqs)
 {
   m_IslandCount = islandcount;
+  m_pIslandReqs = islandreqs;
   m_pIslandSizes = islandsizes;
   m_pBodies = bodies;
   m_pJoints = joints;
 }
 
-void dxWorldProcessContext::RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints)
+void dxWorldProcessContext::RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints, size_t const *&islandreqs)
 {
   islandcount = m_IslandCount;
+  islandreqs = m_pIslandReqs;
   islandsizes = m_pIslandSizes;
   bodies = m_pBodies;
   joints = m_pJoints;
@@ -65,6 +69,7 @@
 {
   // m_IslandCount = -- no offset for count
   m_pIslandSizes = m_pIslandSizes ? (int const *)((size_t)m_pIslandSizes + stOffset) : NULL;
+  m_pIslandReqs = m_pIslandReqs ? (size_t const *)((size_t)m_pIslandReqs + stOffset) : NULL;
   m_pBodies = m_pBodies ? (dxBody *const *)((size_t)m_pBodies + stOffset) : NULL;
   m_pJoints = m_pJoints ? (dxJoint *const *)((size_t)m_pJoints + stOffset) : NULL;
 }
@@ -73,6 +78,7 @@
 {
   m_IslandCount = othercontext->m_IslandCount;
   m_pIslandSizes = othercontext->m_pIslandSizes;
+  m_pIslandReqs = othercontext->m_pIslandReqs;
   m_pBodies = othercontext->m_pBodies;
   m_pJoints = othercontext->m_pJoints;
 }
@@ -81,6 +87,7 @@
 {
   m_IslandCount = 0;
   m_pIslandSizes = NULL;
+  m_pIslandReqs = NULL;
   m_pBodies = NULL;
   m_pJoints = NULL;
 }
@@ -371,6 +378,8 @@
 
   size_t islandcounts = dEFFICIENT_SIZE(world->nb * 2 * sizeof(int));
   res += islandcounts;
+  size_t islandreqs = dEFFICIENT_SIZE(world->nb * sizeof(size_t));
+  res += islandreqs;
 
   size_t bodiessize = dEFFICIENT_SIZE(world->nb * sizeof(dxBody*));
   size_t jointssize = dEFFICIENT_SIZE(world->nj * sizeof(dxJoint*));
@@ -380,6 +389,11 @@
   return res;
 }
 
+// sorts out islands,
+// cllocates array for island information into arrays: body[nj], joint[nb], islandsizes[2*nb]
+//   context->SavePreallocations(islandcount, islandsizes, body, joint,islandreqs);
+// and put into context
+//
 static size_t BuildIslandsAndEstimateStepperMemoryRequirements(dxWorldProcessContext *context, 
   dxWorld *world, dReal stepsize, dmemestimate_fn_t stepperestimate)
 {
@@ -393,33 +407,42 @@
   // Make array for island body/joint counts
   int *islandsizes = context->AllocateArray<int>(2 * nb);
   int *sizescurr;
+  size_t *islandreqs = context->AllocateArray<size_t>(nb);
+  size_t *islandreqscurr;
 
   // make arrays for body and joint lists (for a single island) to go into
-  dxBody **body = context->AllocateArray<dxBody *>(nb);
-  dxJoint **joint = context->AllocateArray<dxJoint *>(nj);
+  dxBody **body = context->AllocateArray<dxBody *>(nb);  // allocates a block of pointers and get back a pointer to first element
+  dxJoint **joint = context->AllocateArray<dxJoint *>(nj);  // allocates a block of pointers and get back a pointer to first element
 
   BEGIN_STATE_SAVE(context, stackstate) {
-    // allocate a stack of unvisited bodies in the island. the maximum size of
+    // stack is used to hold untagged bodies when traversing through all the joint-linked bodies.
+    // at the end, all the bodies in the stack are popped back out into the island.
+    //
+    // allocate a stack of UNVISITED BODIES in the island. the maximum size of
     // the stack can be the lesser of the number of bodies or joints, because
     // new bodies are only ever added to the stack by going through untagged
     // joints. all the bodies in the stack must be tagged!
     int stackalloc = (nj < nb) ? nj : nb;
-    dxBody **stack = context->AllocateArray<dxBody *>(stackalloc);
+    dxBody **stack = context->AllocateArray<dxBody *>(stackalloc);  // a body stack
 
     {
-      // set all body/joint tags to 0
-      for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) b->tag = 0;
-      for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) j->tag = 0;
+      // set all body/joint island_tags to 0
+      for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) b->island_tag = 0;
+      for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) j->island_tag = 0;
     }
 
+    int island_count = 0;
     sizescurr = islandsizes;
+    islandreqscurr = islandreqs;
     dxBody **bodystart = body;
     dxJoint **jointstart = joint;
+    // loop through all body, tag each one as it is processed
+    // every step in this for loop is one island
     for (dxBody *bb=world->firstbody; bb; bb=(dxBody*)bb->next) {
       // get bb = the next enabled, untagged body, and tag it
-      if (!bb->tag) {
+      if (!bb->island_tag) {
         if (!(bb->flags & dxBodyDisabled)) {
-          bb->tag = 1;
+          bb->island_tag = 1;
 
           dxBody **bodycurr = bodystart;
           dxJoint **jointcurr = jointstart;
@@ -431,19 +454,19 @@
           dxBody *b = bb;
 
           while (true) {
-            // traverse and tag all body's joints, add untagged connected bodies
+            // traverse and island_tag all body's joints, add untagged connected bodies
             // to stack
             for (dxJointNode *n=b->firstjoint; n; n=n->next) {
               dxJoint *njoint = n->joint;
-              if (!njoint->tag) {
+              if (!njoint->island_tag) {
                 if (njoint->isEnabled()) {
-                  njoint->tag = 1;
+                  njoint->island_tag = 1;
                   *jointcurr++ = njoint;
 
                   dxBody *nbody = n->body;
                   // Body disabled flag is not checked here. This is how auto-enable works.
-                  if (nbody && nbody->tag <= 0) {
-                    nbody->tag = 1;
+                  if (nbody && nbody->island_tag <= 0) {
+                    nbody->island_tag = 1;
                     // Make sure all bodies are in the enabled state.
                     nbody->flags &= ~dxBodyDisabled;
                     stack[stacksize++] = nbody;
@@ -470,17 +493,19 @@
           sizescurr[1] = jcount;
           sizescurr += sizeelements;
 
-          size_t islandreq = stepperestimate(bodystart, bcount, jointstart, jcount);
-          maxreq = (maxreq > islandreq) ? maxreq : islandreq;
+          *islandreqscurr = stepperestimate(bodystart, bcount, jointstart, jcount);
+          maxreq = (maxreq > *islandreqscurr) ? maxreq : *islandreqscurr;
+          //printf("island %d complete, stepper  %d maxreq %d \n",island_count++,*islandreqscurr, maxreq);
+          islandreqscurr += 1;
 
           bodystart = bodycurr;
           jointstart = jointcurr;
         } else {
-          bb->tag = -1; // Not used so far (assigned to retain consistency with joints)
+          bb->island_tag = -1; // Not used so far (assigned to retain consistency with joints)
         }
       }
     }
-  } END_STATE_SAVE(context, stackstate);
+  } END_STATE_SAVE(context, stackstate);  // restores contex pointer m_pAllocCurrent back to what it was before this block
 
 # ifndef dNODEBUG
   // if debugging, check that all objects (except for disabled bodies,
@@ -489,10 +514,10 @@
   {
     for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) {
       if (b->flags & dxBodyDisabled) {
-        if (b->tag > 0) dDebug (0,"disabled body tagged");
+        if (b->island_tag > 0) dDebug (0,"disabled body tagged");
       }
       else {
-        if (b->tag <= 0) dDebug (0,"enabled body not tagged");
+        if (b->island_tag <= 0) dDebug (0,"enabled body not tagged");
       }
     }
     for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) {
@@ -500,18 +525,24 @@
         (j->node[1].body && (j->node[1].body->flags & dxBodyDisabled)==0) )
         && 
         j->isEnabled() ) {
-          if (j->tag <= 0) dDebug (0,"attached enabled joint not tagged");
+          if (j->island_tag <= 0) dDebug (0,"attached enabled joint not tagged");
       }
       else {
-        if (j->tag > 0) dDebug (0,"unattached or disabled joint tagged");
+        if (j->island_tag > 0) dDebug (0,"unattached or disabled joint tagged");
       }
     }
   }
 # endif
 
   int islandcount = (sizescurr - islandsizes) / sizeelements;
-  context->SavePreallocations(islandcount, islandsizes, body, joint);
+  context->SavePreallocations(islandcount, islandsizes, body, joint,islandreqs);
 
+  //printf("total island count: %d\n",islandcount);
+  for (int j=0; j<islandcount; j++)
+  {
+    //printf("island:%d bodycount:%d jointcount:%d islandreqs:%d \n",j,islandsizes[2*j],islandsizes[2*j+1],islandreqs[j]);
+  }
+
   return maxreq;
 }
 
@@ -526,6 +557,20 @@
 // bodies will not be included in the simulation. disabled bodies are
 // re-enabled if they are found to be part of an active island.
 
+void dxProcessOneIsland(dxWorldProcessContext *context,dxWorldProcessContext *island_context, dxWorld *world, dReal stepsize, dstepper_fn_t stepper,
+                        dxBody *const* bodystart,
+                        int bcount,
+                        dxJoint *const *jointstart,
+                        int jcount)
+{
+    dAllocateODEDataForThread(dAllocateMaskAll);
+
+    BEGIN_STATE_SAVE(island_context, island_stepperstate) {
+      stepper (context,island_context,world,bodystart,bcount,jointstart,jcount,stepsize);
+    } END_STATE_SAVE(island_context, island_stepperstate);
+    dCleanupODEAllDataForThread();
+}
+
 void dxProcessIslands (dxWorld *world, dReal stepsize, dstepper_fn_t stepper)
 {
   const int sizeelements = 2;
@@ -536,28 +581,43 @@
   dxWorldProcessContext *context = wmem->GetWorldProcessingContext(); 
 
   int islandcount;
+  size_t const *islandreqs;
   int const *islandsizes;
   dxBody *const *body;
   dxJoint *const *joint;
-  context->RetrievePreallocations(islandcount, islandsizes, body, joint);
+  context->RetrievePreallocations(islandcount, islandsizes, body, joint, islandreqs);
 
   dxBody *const *bodystart = body;
   dxJoint *const *jointstart = joint;
 
+  int island_index = 0;
   int const *const sizesend = islandsizes + islandcount * sizeelements;
   for (int const *sizescurr = islandsizes; sizescurr != sizesend; sizescurr += sizeelements) {
     int bcount = sizescurr[0];
     int jcount = sizescurr[1];
 
-    BEGIN_STATE_SAVE(context, stepperstate) {
-      // now do something with body and joint lists
-      stepper (context,world,bodystart,bcount,jointstart,jcount,stepsize);
-    } END_STATE_SAVE(context, stepperstate);
+    //printf("debug: islandcount %d bcount %d jcount %d \n", islandcount,bcount, jcount);
 
+    dxStepWorkingMemory *island_wmem = world->island_wmems[island_index];
+    island_index++;
+    dIASSERT(island_wmem != NULL);
+    dxWorldProcessContext *island_context = island_wmem->GetWorldProcessingContext();
+
+#define TPOOLISLAND
+#ifdef TPOOLISLAND
+    world->threadpool->schedule(boost::bind(dxProcessOneIsland,context,island_context, world, stepsize, stepper,bodystart, bcount, jointstart, jcount));
+#else
+    dxProcessOneIsland(context,island_context, world, stepsize, stepper,bodystart, bcount, jointstart, jcount);
+#endif
+
     bodystart += bcount;
     jointstart += jcount;
   }
+  world->threadpool->wait();
 
+  for (int jj=0; jj < islandcount; jj++)
+    world->island_wmems[jj]->GetWorldProcessingContext()->CleanupContext();
+
   context->CleanupContext();
   dIASSERT(context->IsStructureValid());
 }
@@ -713,7 +773,7 @@
 bool dxReallocateWorldProcessContext (dxWorld *world, 
   dReal stepsize, dmemestimate_fn_t stepperestimate)
 {
-  dxStepWorkingMemory *wmem = AllocateOnDemand(world->wmem);
+  dxStepWorkingMemory *wmem = AllocateOnDemand(world->wmem);  // this is starting a new instance of dxStepWorkingMemory
   if (!wmem) return false;
 
   dxWorldProcessContext *oldcontext = wmem->GetWorldProcessingContext();
@@ -724,6 +784,10 @@
 
   dxWorldProcessContext *context = oldcontext;
 
+  // EstimateIslandsProcessingMemoryRequirements allocates memeory for 3 arrays:
+  //    islandsizes: integer arrays, 2*n_islands in size, contains bodycount and jointcount for each island
+  //    body: one array with all the 'active' bodies, all indexed by islandsizes
+  //    joint: one array with all the 'active' joints, all indexed by islandsizes
   size_t sesize;
   size_t islandsreq = EstimateIslandsProcessingMemoryRequirements(world, sesize);
   dIASSERT(islandsreq == dEFFICIENT_SIZE(islandsreq));
@@ -732,16 +796,45 @@
   size_t stepperestimatereq = islandsreq + sesize;
   context = InternalReallocateWorldProcessContext(context, stepperestimatereq, memmgr, 1.0f, reserveinfo->m_uiReserveMinimum);
   
+  //
+  // above context allocation of the island arrays is successful, then we proceed to allocate more spaces for the actual stepping work
+  //
+  // we want to start multiple contexts, one for each island.
+  //
   if (context)
   {
     size_t stepperreq = BuildIslandsAndEstimateStepperMemoryRequirements(context, world, stepsize, stepperestimate);
     dIASSERT(stepperreq == dEFFICIENT_SIZE(stepperreq));
 
-    size_t memreq = stepperreq + islandsreq;
-    context = InternalReallocateWorldProcessContext(context, memreq, memmgr, reserveinfo->m_fReserveFactor, reserveinfo->m_uiReserveMinimum);
+    // retrieve results of BuildIslandsAndEstimateStepperMemoryRequirements
+    int islandcount;
+    size_t const *islandreqs;
+    int const *islandsizes;
+    dxBody *const *body;
+    dxJoint *const *joint;
+    context->RetrievePreallocations(islandcount, islandsizes, body, joint, islandreqs);
+
+    for (int jj = 0; jj < islandcount; jj++)
+    {
+      // for individual islands
+      dxStepWorkingMemory *island_wmem = AllocateOnDemand(world->island_wmems[jj]);  // this is starting a new instance of dxStepWorkingMemory
+      if (!island_wmem) return false;
+
+      dxWorldProcessContext *island_oldcontext = island_wmem->GetWorldProcessingContext();
+      dIASSERT (!island_oldcontext || island_oldcontext->IsStructureValid());
+
+      const dxWorldProcessMemoryReserveInfo *island_reserveinfo = island_wmem->SureGetMemoryReserveInfo();
+      const dxWorldProcessMemoryManager *island_memmgr = island_wmem->SureGetMemoryManager();
+
+      dxWorldProcessContext *island_context = island_oldcontext;
+
+      size_t island_memreq = islandreqs[jj]; //  + islandsreq;
+      island_context = InternalReallocateWorldProcessContext(island_context, island_memreq, island_memmgr, island_reserveinfo->m_fReserveFactor, island_reserveinfo->m_uiReserveMinimum);
+      island_wmem->SetWorldProcessingContext(island_context); // set dxStepWorkingMemory to context
+    }
   }
 
-  wmem->SetWorldProcessingContext(context);
+  wmem->SetWorldProcessingContext(context); // set dxStepWorkingMemory to context
   return context != NULL;
 }
 
Index: ode/src/quickstep.h
===================================================================
--- ode/src/quickstep.h	(revision 1730)
+++ ode/src/quickstep.h	(working copy)
@@ -28,7 +28,7 @@
 size_t dxEstimateQuickStepMemoryRequirements (
   dxBody * const *body, int nb, dxJoint * const *_joint, int _nj);
 
-void dxQuickStepper (dxWorldProcessContext *context,
+void dxQuickStepper (dxWorldProcessContext *shared_context,dxWorldProcessContext *context,
         dxWorld *world, dxBody * const *body, int nb,
 		    dxJoint * const *_joint, int _nj, dReal stepsize);
 
Index: ode/src/joints/slider.cpp
===================================================================
--- ode/src/joints/slider.cpp	(revision 1730)
+++ ode/src/joints/slider.cpp	(working copy)
@@ -142,6 +142,10 @@
             info->m = 6;
         }
     }
+
+    // joint damping
+    if ( use_damping )
+      info->m = 6;
 }
 
 
@@ -224,6 +228,22 @@
 
     // if the slider is powered, or has joint limits, add in the extra row
     limot.addLimot ( this, info, 5, ax1, 0 );
+
+    // joint damping
+    if (this->use_damping)
+    {
+      // added J1ld and J2ld for damping, only 1 row
+      info->J1ld[0] = ax1[0];
+      info->J1ld[1] = ax1[1];
+      info->J1ld[2] = ax1[2];
+      if ( this->node[1].body )
+      {
+        info->J2ld[0] = -ax1[0];
+        info->J2ld[1] = -ax1[1];
+        info->J2ld[2] = -ax1[2];
+      }
+      // there's no rhs for damping setup, all we want to use is the jacobian information above
+    }
 }
 
 
Index: ode/src/joints/joint.h
===================================================================
--- ode/src/joints/joint.h	(revision 1730)
+++ ode/src/joints/joint.h	(working copy)
@@ -94,6 +94,10 @@
         // J2xx pointers may be 0.
         dReal *J1l, *J1a, *J2l, *J2a;
 
+        // jacobians for joint damping
+        // angular ones are implemented first
+        dReal *J1ld, *J1ad, *J2ld, *J2ad;
+
         // elements to jump from one row to the next in J's
         int rowskip;
 
@@ -155,6 +159,12 @@
 	// Test if this joint should be used in the simulation step
 	// (has the enabled flag set, and is attached to at least one dynamic body)
 	bool isEnabled() const;
+
+    // to use joint damping set use_damping to true
+    // and set damping_coefficient to the desired value
+    bool use_damping;
+    dReal damping_coefficient;
+
 };
 
 
Index: ode/src/joints/hinge.h
===================================================================
--- ode/src/joints/hinge.h	(revision 1730)
+++ ode/src/joints/hinge.h	(working copy)
@@ -36,6 +36,7 @@
     dVector3 axis2;     // axis w.r.t second body
     dQuaternion qrel;   // initial relative rotation body1 -> body2
     dxJointLimitMotor limot; // limit and motor information
+    dReal cumulative_angle; // save a cumulative angle so we can use larger then +/-pi limits
 
     dxJointHinge( dxWorld *w );
     virtual void getSureMaxInfo( SureMaxInfo* info );
Index: ode/src/joints/joint.cpp
===================================================================
--- ode/src/joints/joint.cpp	(revision 1730)
+++ ode/src/joints/joint.cpp	(working copy)
@@ -57,6 +57,10 @@
 
     w->nj++;
     feedback = 0;
+
+    // joint damping
+    use_damping = false;
+    damping_coefficient = 0.0;
 }
 
 dxJoint::~dxJoint()
Index: ode/src/joints/hinge.cpp
===================================================================
--- ode/src/joints/hinge.cpp	(revision 1730)
+++ ode/src/joints/hinge.cpp	(working copy)
@@ -25,7 +25,63 @@
 #include "hinge.h"
 #include "joint_internal.h"
 
+//****************************************************************************
+// helper function: shortest_angular_distance implementation
+    
+  /*!
+   * \brief normalize_angle_positive
+   *
+   *        Normalizes the angle to be 0 to 2*M_PI
+   *        It takes and returns radians.
+   */
+  static inline double normalize_angle_positive(double angle)
+  {
+    return fmod(fmod(angle, 2.0*M_PI) + 2.0*M_PI, 2.0*M_PI);
+  }
 
+
+  /*!
+   * \brief normalize
+   *
+   * Normalizes the angle to be -M_PI circle to +M_PI circle
+   * It takes and returns radians.
+   *
+   */    
+  static inline double normalize_angle(double angle)
+  {
+    double a = normalize_angle_positive(angle);
+    if (a > M_PI)
+      a -= 2.0 *M_PI;
+    return a;
+  }
+
+    
+  /*!
+   * \function
+   * \brief shortest_angular_distance
+   *
+   * Given 2 angles, this returns the shortest angular
+   * difference.  The inputs and ouputs are of course radians.
+   *
+   * The result
+   * would always be -pi <= result <= pi.  Adding the result
+   * to "from" will always get you an equivelent angle to "to".
+   */
+    
+  static inline double shortest_angular_distance(double from, double to)
+  {
+    double result = normalize_angle_positive(normalize_angle_positive(to) - normalize_angle_positive(from));
+	
+    if (result > M_PI)
+      // If the result > 180,
+      // It's shorter the other way.
+      result = -(2.0*M_PI - result);
+	
+    return normalize_angle(result);
+  }
+
+
+
 //****************************************************************************
 // hinge
 
@@ -40,6 +96,7 @@
     axis2[0] = 1;
     dSetZero( qrel, 4 );
     limot.init( world );
+    cumulative_angle = 0;
 }
 
 
@@ -60,16 +117,22 @@
         info->m = 6; // powered hinge needs an extra constraint row
     else info->m = 5;
 
+    // if proper joint limits are specified
     // see if we're at a joint limit.
-    if (( limot.lostop >= -M_PI || limot.histop <= M_PI ) &&
-            limot.lostop <= limot.histop )
+    if ( limot.lostop <= limot.histop )
     {
         dReal angle = getHingeAngle( node[0].body,
                                      node[1].body,
                                      axis1, qrel );
-        if ( limot.testRotationalLimit( angle ) )
+        // from angle, update cumulative_angle, which does not wrap
+        cumulative_angle = cumulative_angle + shortest_angular_distance(cumulative_angle,angle);
+
+        if ( limot.testRotationalLimit( cumulative_angle ) )
             info->m = 6;
     }
+    // joint damping
+    if ( use_damping )
+      info->m = 6;
 }
 
 
@@ -146,6 +209,22 @@
 
     // if the hinge is powered, or has joint limits, add in the stuff
     limot.addLimot( this, info, 5, ax1, 1 );
+
+    // joint damping
+    if (this->use_damping)
+    {
+      // added J1ad and J2ad for damping, only 1 row
+      info->J1ad[0] = ax1[0];
+      info->J1ad[1] = ax1[1];
+      info->J1ad[2] = ax1[2];
+      if ( this->node[1].body )
+      {
+        info->J2ad[0] = -ax1[0];
+        info->J2ad[1] = -ax1[1];
+        info->J2ad[2] = -ax1[2];
+      }
+      // there's no rhs for damping setup, all we want to use is the jacobian information above
+    }
 }
 
 
@@ -296,10 +375,12 @@
                                    joint->node[1].body,
                                    joint->axis1,
                                    joint->qrel );
+        // from angle, update cumulative_angle, which does not wrap
+        joint->cumulative_angle = joint->cumulative_angle + shortest_angular_distance(joint->cumulative_angle,ang);
         if ( joint->flags & dJOINT_REVERSE )
-            return -ang;
+            return -joint->cumulative_angle;
         else
-            return ang;
+            return joint->cumulative_angle;
     }
     else return 0;
 }
Index: ode/src/step.h
===================================================================
--- ode/src/step.h	(revision 1730)
+++ ode/src/step.h	(working copy)
@@ -28,7 +28,7 @@
 size_t dxEstimateStepMemoryRequirements (
   dxBody * const *body, int nb, dxJoint * const *_joint, int _nj);
 
-void dInternalStepIsland (dxWorldProcessContext *context, dxWorld *world,
+void dInternalStepIsland (dxWorldProcessContext *shared_context,dxWorldProcessContext *context, dxWorld *world,
 			  dxBody * const *body, int nb,
 			  dxJoint * const *joint, int nj,
 			  dReal stepsize);
Index: ode/src/objects.h
===================================================================
--- ode/src/objects.h	(revision 1730)
+++ ode/src/objects.h	(working copy)
@@ -30,6 +30,7 @@
 #include <ode/memory.h>
 #include <ode/mass.h>
 #include "array.h"
+#include <boost/threadpool.hpp>
 
 class dxStepWorkingMemory;
 
@@ -66,6 +67,7 @@
   dObject *next;		// next object of this type in list
   dObject **tome;		// pointer to previous object's next ptr
   int tag;			// used by dynamics algorithms
+  int island_tag;		// used by island algorithms for grouping
   void *userdata;		// user settable data
   dObject(dxWorld *w);
   virtual ~dObject() { }
@@ -151,11 +153,13 @@
   dxAutoDisable adis;		// auto-disable parameters
   int body_flags;               // flags for new bodies
   dxStepWorkingMemory *wmem; // Working memory object for dWorldStep/dWorldQuickStep
+  dxStepWorkingMemory *island_wmems[1000]; // Working memory object for dWorldStep/dWorldQuickStep
 
   dxQuickStepParameters qs;
   dxContactParameters contactp;
   dxDampingParameters dampingp; // damping parameters
   dReal max_angular_speed;      // limit the angular velocity to this magnitude
+  boost::threadpool::pool *threadpool;
 };
 
 
Index: ode/src/collision_kernel.h
===================================================================
--- ode/src/collision_kernel.h	(revision 1730)
+++ ode/src/collision_kernel.h	(working copy)
@@ -34,6 +34,7 @@
 #include <ode/collision.h>
 #include "objects.h"
 #include "odetls.h"
+#include <boost/thread/mutex.hpp>
 
 //****************************************************************************
 // constants and macros
@@ -204,6 +205,8 @@
   int sublevel;         // space sublevel (used in dSpaceCollide2). NOT TRACKED AUTOMATICALLY!!!
   unsigned tls_kind;	// space TLS kind to be used for global caches retrieval
 
+  boost::mutex mutex;
+
   // cached state for getGeom()
   int current_index;		// only valid if current_geom != 0
   dxGeom *current_geom;		// if 0 then there is no information
Index: ode/src/ode.cpp
===================================================================
--- ode/src/ode.cpp	(revision 1730)
+++ ode/src/ode.cpp	(working copy)
@@ -1454,7 +1454,20 @@
   joint->feedback = f;
 }
 
+void dJointSetDamping (dxJoint *joint, dReal damping)
+{
+  dAASSERT (joint);
 
+  if (damping > 0.0)
+  {
+    // set use_damping to true
+    joint->use_damping = true;
+    // damping coefficient is in jicurr->info.damping_coefficient);
+    joint->damping_coefficient = damping;
+    // FIXME: only hinge joint and slider are implemented at this time
+  }
+}
+
 dJointFeedback *dJointGetFeedback (dxJoint *joint)
 {
   dAASSERT (joint);
@@ -1559,6 +1572,10 @@
   w->body_flags = 0; // everything disabled
 
   w->wmem = 0;
+  for (int jj=0; jj < 1000; jj++)
+  {
+    w->island_wmems[jj] = 0;
+  }
 
   w->adis.idle_steps = 10;
   w->adis.idle_time = 0;
@@ -1578,6 +1595,8 @@
   w->dampingp.angular_threshold = REAL(0.01) * REAL(0.01);  
   w->max_angular_speed = dInfinity;
 
+  w->threadpool = new boost::threadpool::pool(4);
+
   return w;
 }
 
@@ -1617,6 +1636,8 @@
     w->wmem->Release();
   }
 
+  delete w->threadpool;
+
   delete w;
 }
 
Index: ode/src/step.cpp
===================================================================
--- ode/src/step.cpp	(revision 1730)
+++ ode/src/step.cpp	(working copy)
@@ -31,10 +31,13 @@
 #include "joints/joint.h"
 #include "lcp.h"
 #include "util.h"
+#include "joints/hinge.h"
 
 //****************************************************************************
 // misc defines
 
+#define USE_JOINT_DAMPING
+
 //#define TIMING
 
 
@@ -425,6 +428,24 @@
     m = mcurr;
   }
 
+
+#ifdef USE_JOINT_DAMPING
+  /************************************************************************/
+  /* for joint damping, get the total number of rows for damping jacobian */
+  /************************************************************************/
+  int m_damp; // number of rows for damped joint jacobian
+  {
+    int mcurr = 0;
+    const dJointWithInfo1 *jicurr = jointiinfos; // info1 stored in jointiinfos
+    const dJointWithInfo1 *const jiend = jicurr + nj;
+    for (; jicurr != jiend; jicurr++)
+      if (jicurr->joint->use_damping)
+        mcurr ++;
+
+    m_damp = mcurr;
+  }
+#endif
+
   // this will be set to the force due to the constraints
   dReal *cforce = context->AllocateArray<dReal> (nb*8);
   dSetZero (cforce,nb*8);
@@ -460,6 +481,23 @@
       dSetZero (rhs,mlocal);
     }
 
+#ifdef USE_JOINT_DAMPING
+    dReal *J_damp = NULL;
+    dReal *coeff_damp = NULL;
+    {
+      int mlocal = m_damp;
+
+      const unsigned jelements = mlocal*12;
+      J_damp = context->AllocateArray<dReal> (jelements);
+      dSetZero (J_damp,jelements);
+
+      const unsigned coeffelements = mlocal;
+      coeff_damp = context->AllocateArray<dReal> (coeffelements);
+      dSetZero (coeff_damp,coeffelements);
+    }
+#endif
+
+
     // Put 'c' in the same memory as 'rhs' as they transit into each other
     dReal *c = rhs; rhs = NULL; // erase rhs pointer for now as it is not to be used yet
 
@@ -496,6 +534,9 @@
         Jinfo.erp = world->global_erp;
 
         unsigned ofsi = 0;
+#ifdef USE_JOINT_DAMPING
+        unsigned ofsi_damp = 0;
+#endif
         const dJointWithInfo1 *jicurr = jointiinfos;
         const dJointWithInfo1 *const jiend = jicurr + nj;
         for (; jicurr != jiend; ++jicurr) {
@@ -511,7 +552,27 @@
           Jinfo.lo = lo + ofsi;
           Jinfo.hi = hi + ofsi;
           Jinfo.findex = findex + ofsi;
-          
+
+#ifdef USE_JOINT_DAMPING
+          /*******************************************************/
+          /*  allocate space for damped joint Jacobians          */
+          /*******************************************************/
+          if (jicurr->joint->use_damping)
+          {
+            // damping coefficient is in jicurr->info.damping_coefficient);
+            coeff_damp[ofsi_damp] = jicurr->joint->damping_coefficient;
+
+            // setup joint damping pointers so getinfo2 will fill in J_damp
+            dReal *const Jrow_damp = J_damp + ofsi_damp * 12;
+            Jinfo.J1ld = Jrow_damp;
+            Jinfo.J1ad = Jrow_damp + 3;
+            Jinfo.J2ld = Jrow_damp + 6;
+            Jinfo.J2ad = Jrow_damp + 9;
+            // one row of constraint per joint
+            ofsi_damp ++;
+          }
+#endif
+ 
           dxJoint *joint = jicurr->joint;
           joint->getInfo2 (&Jinfo);
           
@@ -838,8 +899,7 @@
 }
 
 //****************************************************************************
-
-void dInternalStepIsland (dxWorldProcessContext *context, 
+void dInternalStepIsland (dxWorldProcessContext *shared_context, dxWorldProcessContext *context, 
                           dxWorld *world, dxBody * const *body, int nb,
                           dxJoint * const *joint, int nj, dReal stepsize)
 {
@@ -868,6 +928,24 @@
     nj = njcurr; m = mcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  int m_damp;
+  {
+    int m_dampcurr = 0;
+    dxJoint::SureMaxInfo info;
+    dxJoint *const *const _jend = _joint + _nj;
+    for (dxJoint *const *_jcurr = _joint; _jcurr != _jend; _jcurr++) {
+      dxJoint *j = *_jcurr;
+      /***************************/
+      /* size for damping joints */
+      /***************************/
+      if (j->use_damping)
+        m_dampcurr ++;
+    }
+    m_damp = m_dampcurr;
+  }
+#endif
+
   size_t res = 0;
 
   res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for invI
@@ -884,6 +962,10 @@
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * mskip * m); // for A
       sub1_res2 += 3 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for lo, hi, rhs
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * m); // for findex
+#ifdef USE_JOINT_DAMPING
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m_damp); // for J_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp); // for coeff_damp
+#endif
       {
         size_t sub2_res1 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm
         sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 2 * 8 * m); // for JinvM
