Index: include/ode/objects.h
===================================================================
--- include/ode/objects.h	(revision 1730)
+++ include/ode/objects.h	(working copy)
@@ -76,8 +76,21 @@
  */
 ODE_API void dWorldSetGravity (dWorldID, dReal x, dReal y, dReal z);
 
+/**
+ * @brief Set the number of thread pool threads for islands
+ *
+ * @ingroup world
+ */
+ODE_API void dWorldSetIslandThreads (dWorldID, int num_island_threads);
 
 /**
+ * @brief Set the number of thread pool threads for quickstep
+ *
+ * @ingroup world
+ */
+ODE_API void dWorldSetQuickstepThreads (dWorldID, int num_quickstep_threads);
+
+/**
  * @brief Get the gravity vector for a given world.
  * @ingroup world
  */
@@ -374,6 +387,24 @@
 
 
 /**
+ * @brief Set the tolerance of when sor lcp stops
+ * @param num The default is 1 chunk
+ */
+void dWorldSetQuickStepTolerance (dWorldID, dReal tol);
+
+/**
+ * @brief Set the number of chunks quickstep divide up constraint rows
+ * @param num The default is 1 chunk
+ */
+void dWorldSetQuickStepNumChunks (dWorldID, int num);
+
+/**
+ * @brief Set the number of overlap when quickstep divide up constraint rows
+ * @param num The default is 0 overlap
+ */
+void dWorldSetQuickStepNumOverlap (dWorldID, int num);
+
+/**
  * @brief Set the number of iterations that the QuickStep method performs per
  *        step.
  * @ingroup world
@@ -1722,6 +1753,12 @@
 ODE_API void dJointSetData (dJointID, void *data);
 
 /**
+ * @brief Set the user-data pointer
+ * @ingroup joints
+ */
+ODE_API void dJointSetDamping (dJointID, dReal damping);
+
+/**
  * @brief Get the user-data pointer
  * @ingroup joints
  */
Index: include/ode/misc.h
===================================================================
--- include/ode/misc.h	(revision 1730)
+++ include/ode/misc.h	(working copy)
@@ -57,8 +57,11 @@
 #ifdef __cplusplus
 ODE_API void dPrintMatrix (const dReal *A, int n, int m, char *fmt = "%10.4f ",
 		   FILE *f=stdout);
+ODE_API void dPrintIntMatrix (const int *A, int n, int m, char *fmt = "%5d ",
+		   FILE *f=stdout);
 #else
 ODE_API void dPrintMatrix (const dReal *A, int n, int m, char *fmt, FILE *f);
+ODE_API void dPrintIntMatrix (const int *A, int n, int m, char *fmt, FILE *f);
 #endif
 
 /* make a random vector with entries between +/- range. A has n elements. */
Index: configure.in
===================================================================
--- configure.in	(revision 1730)
+++ configure.in	(working copy)
@@ -1,7 +1,9 @@
 dnl AC_INIT does not take a macro as a version nr: set it separately! - Bram
-AC_INIT([ODE],[0.11.1],[ode@ode.org])
+# add another minor for wg
+AC_INIT([ODE],[0.11.1.1],[ode@ode.org])
 # AC_CONFIG_SRCDIR([ode/src/ode.cpp])
-ODE_RELEASE=0.11.1
+# add another minor for wg
+ODE_RELEASE=0.11.1.1
 AC_SUBST(ODE_RELEASE)
 
 # Those are instructions from the Libtool manual:
Index: ode/src/collision_space.cpp
===================================================================
--- ode/src/collision_space.cpp	(revision 1730)
+++ ode/src/collision_space.cpp	(working copy)
@@ -168,7 +168,10 @@
 
   // add
   geom->parent_space = this;
-  geom->spaceAdd (&first);
+  {
+    boost::mutex::scoped_lock lock(this->mutex);
+    geom->spaceAdd (&first);  // lock mutex before alterning linked list
+  }
   count++;
 
   // enumerator has been invalidated
@@ -189,7 +192,10 @@
   dUASSERT (geom->parent_space == this,"object is not in this space");
 
   // remove
-  geom->spaceRemove();
+  {
+    boost::mutex::scoped_lock lock(this->mutex);
+    geom->spaceRemove();  // lock mutex before alterning linked list
+  }
   count--;
 
   // safeguard
@@ -208,6 +214,7 @@
 
 void dxSpace::dirty (dxGeom *geom)
 {
+  boost::mutex::scoped_lock lock(this->mutex);  // lock mutex before alterning linked list
   geom->spaceRemove();
   geom->spaceAdd (&first);
 }
Index: ode/src/quickstep.cpp
===================================================================
--- ode/src/quickstep.cpp	(revision 1730)
+++ ode/src/quickstep.cpp	(working copy)
@@ -33,6 +33,28 @@
 #include "lcp.h"
 #include "util.h"
 
+#include <sys/time.h>
+
+
+
+#undef REPORT_THREAD_TIMING
+#define USE_TPROW
+#undef TIMING
+#undef REPORT_MONITOR
+#undef SHOW_CONVERGENCE
+#define LOCAL_STEPPING
+#undef RECOMPUTE_RMS
+#undef USE_1NORM
+
+
+
+#ifdef USE_TPROW
+// added for threading per constraint rows
+#include <boost/thread/recursive_mutex.hpp>
+#include <boost/bind.hpp>
+#include "ode/odeinit.h"
+#endif
+
 typedef const dReal *dRealPtr;
 typedef dReal *dRealMutablePtr;
 
@@ -62,7 +84,10 @@
 // or hardly at all, but it doesn't seem to hurt.
 
 #define RANDOMLY_REORDER_CONSTRAINTS 1
+#undef LOCK_WHILE_RANDOMLY_REORDER_CONSTRAINTS
 
+#define USE_JOINT_DAMPING
+
 //****************************************************************************
 // special matrix multipliers
 
@@ -323,7 +348,13 @@
   int index;		// row index
 };
 
+struct dJointWithInfo1
+{
+  dxJoint *joint;
+  dxJoint::Info1 info;
+};
 
+
 #ifdef REORDER_CONSTRAINTS
 
 static int compare_index_error (const void *a, const void *b)
@@ -339,98 +370,72 @@
 
 #endif
 
-static void SOR_LCP (dxWorldProcessContext *context,
-  const int m, const int nb, dRealMutablePtr J, int *jb, dxBody * const *body,
-  dRealPtr invI, dRealMutablePtr lambda, dRealMutablePtr fc, dRealMutablePtr b,
-  dRealPtr lo, dRealPtr hi, dRealPtr cfm, const int *findex,
-  const dxQuickStepParameters *qs)
+
+static void ComputeRows(
+                IndexError* order,
+                dxBody* const *body,
+                int* tmpInt,
+                dReal* tmpReal,
+                int** tmpIntPtr,
+                dJointWithInfo1 *const jointiinfos,
+                dRealPtr* tmpRealPtr,
+                dRealMutablePtr* tmpMutablePtr,
+                boost::recursive_mutex* mutex)
 {
-#ifdef WARM_STARTING
-  {
-    // for warm starting, this seems to be necessary to prevent
-    // jerkiness in motor-driven joints. i have no idea why this works.
-    for (int i=0; i<m; i++) lambda[i] *= 0.9;
-  }
-#else
-  dSetZero (lambda,m);
-#endif
+  struct timeval tv;
+  double cur_time;
+  gettimeofday(&tv,NULL);
+  cur_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  //printf("thread %d started at time %f\n",thread_id,cur_time);
 
-  // precompute iMJ = inv(M)*J'
-  dReal *iMJ = context->AllocateArray<dReal> (m*12);
-  compute_invM_JT (m,J,iMJ,jb,body,invI);
-
-  // compute fc=(inv(M)*J')*lambda. we will incrementally maintain fc
-  // as we change lambda.
-#ifdef WARM_STARTING
-  multiply_invM_JT (m,nb,iMJ,jb,lambda,fc);
-#else
-  dSetZero (fc,nb*6);
+  //boost::recursive_mutex::scoped_lock lock(*mutex); // put in fc read/writes?
+  int startRow                 = tmpInt[0];
+  int nRows                    = tmpInt[1];
+  int m                        = tmpInt[2];
+  int nb                       = tmpInt[3];
+  int m_damp                   = tmpInt[4];
+  int num_iterations           = tmpInt[5];
+  int thread_id                = tmpInt[6];
+  int nj                       = tmpInt[7];
+  dReal stepsize               = tmpReal[0];
+  dReal sor_lcp_tol            = tmpReal[1];
+  dReal sor_w                  = tmpReal[2];
+  dReal global_erp             = tmpReal[3];
+  int* jb                      = tmpIntPtr[0];
+  int* jb_damp                 = tmpIntPtr[1];
+  int* findex                  = tmpIntPtr[2];
+  dRealPtr        JiM          = tmpRealPtr[0];
+  dRealPtr        invI         = tmpRealPtr[1];
+  dRealMutablePtr b            = tmpMutablePtr[0];
+  dRealMutablePtr J            = tmpMutablePtr[1];
+  dRealMutablePtr fc           = tmpMutablePtr[2];
+  dRealMutablePtr lambda       = tmpMutablePtr[3];
+  dRealMutablePtr iMJ          = tmpMutablePtr[4];
+#ifdef USE_JOINT_DAMPING
+  dRealMutablePtr b_damp       = tmpMutablePtr[5];
+  dRealMutablePtr f_damp       = tmpMutablePtr[6];
+  dRealMutablePtr v_damp       = tmpMutablePtr[7];
+  dRealMutablePtr J_damp       = tmpMutablePtr[8];
+  dRealMutablePtr v_joint_damp = tmpMutablePtr[9];
+#ifdef REORDER_CONSTRAINTS
+  dRealMutablePtr last_lambda  = tmpMutablePtr[10];
 #endif
-
-  dReal *Ad = context->AllocateArray<dReal> (m);
-
-  {
-    const dReal sor_w = qs->w;		// SOR over-relaxation parameter
-    // precompute 1 / diagonals of A
-    dRealPtr iMJ_ptr = iMJ;
-    dRealPtr J_ptr = J;
-    for (int i=0; i<m; J_ptr += 12, iMJ_ptr += 12, i++) {
-      dReal sum = 0;
-      for (int j=0; j<6; j++) sum += iMJ_ptr[j] * J_ptr[j];
-      if (jb[i*2+1] >= 0) {
-        for (int k=6; k<12; k++) sum += iMJ_ptr[k] * J_ptr[k];
-      }
-      Ad[i] = sor_w / (sum + cfm[i]);
-    }
-  }
-
-  {
-    // NOTE: This may seem unnecessary but it's indeed an optimization 
-    // to move multiplication by Ad[i] and cfm[i] out of iteration loop.
-
-    // scale J and b by Ad
-    dRealMutablePtr J_ptr = J;
-    for (int i=0; i<m; J_ptr += 12, i++) {
-      dReal Ad_i = Ad[i];
-      for (int j=0; j<12; j++) {
-        J_ptr[j] *= Ad_i;
-      }
-      b[i] *= Ad_i;
-      // scale Ad by CFM. N.B. this should be done last since it is used above
-      Ad[i] = Ad_i * cfm[i];
-    }
-  }
-
-
-  // order to solve constraint rows in
-  IndexError *order = context->AllocateArray<IndexError> (m);
-
-#ifndef REORDER_CONSTRAINTS
-  {
-    // make sure constraints with findex < 0 come first.
-    IndexError *orderhead = order, *ordertail = order + (m - 1);
-
-    // Fill the array from both ends
-    for (int i=0; i<m; i++) {
-      if (findex[i] < 0) {
-        orderhead->index = i; // Place them at the front
-        ++orderhead;
-      } else {
-        ordertail->index = i; // Place them at the end
-        --ordertail;
-      }
-    }
-    dIASSERT (orderhead-ordertail==1);
-  }
 #endif
+  dRealMutablePtr delta_error  = tmpMutablePtr[11];
+  dRealMutablePtr Ad           = tmpMutablePtr[12];
+  dRealMutablePtr Adcfm        = tmpMutablePtr[13];
+  dRealMutablePtr Jcopy        = tmpMutablePtr[14];
+  dRealMutablePtr hi           = tmpMutablePtr[15];
+  dRealMutablePtr lo           = tmpMutablePtr[16];
+  dRealMutablePtr coeff_damp   = tmpMutablePtr[17];
+  dRealMutablePtr cfm          = tmpMutablePtr[18];
+  dRealMutablePtr c            = tmpMutablePtr[19];
+  dRealMutablePtr v_save       = tmpMutablePtr[20];
 
-#ifdef REORDER_CONSTRAINTS
-  // the lambda computed at the previous iteration.
-  // this is used to measure error for when we are reordering the indexes.
-  dReal *last_lambda = context->AllocateArray<dReal> (m);
-#endif
+  //printf("iiiiiiiii %d %d %d\n",thread_id,jb[0],jb[1]);
+  //for (int i=startRow; i<startRow+nRows; i++) // swap within boundary of our own segment
+  //  printf("wwwwwwwwwwwww>id %d start %d n %d  order[%d].index=%d\n",thread_id,startRow,nRows,i,order[i].index);
 
-  const int num_iterations = qs->num_iterations;
   for (int iteration=0; iteration < num_iterations; iteration++) {
 
 #ifdef REORDER_CONSTRAINTS
@@ -438,8 +443,9 @@
     if (iteration < 2) {
       // for the first two iterations, solve the constraints in
       // the given order
-      IndexError *ordercurr = order;
-      for (int i = 0; i != m; ordercurr++, i++) {
+      IndexError *ordercurr = order+startRow;
+      //for (int i = 0; i != m; ordercurr++, i++) { }
+      for (int i = startRow; i != startRow+nRows; ordercurr++, i++) {
         ordercurr->error = i;
         ordercurr->findex = findex[i];
         ordercurr->index = i;
@@ -448,7 +454,8 @@
     else {
       // sort the constraints so that the ones converging slowest
       // get solved last. use the absolute (not relative) error.
-      for (int i=0; i<m; i++) {
+      //for (int i=0; i<m; i++) { }
+      for (int i=startRow; i<startRow+nRows; i++) {
         dReal v1 = dFabs (lambda[i]);
         dReal v2 = dFabs (last_lambda[i]);
         dReal max = (v1 > v2) ? v1 : v2;
@@ -463,25 +470,57 @@
         order[i].index = i;
       }
     }
-    qsort (order,m,sizeof(IndexError),&compare_index_error);
 
+    //if (thread_id == 0) for (int i=startRow;i<startRow+nRows;i++) printf("=====> %d %d %d %f %d\n",thread_id,iteration,i,order[i].error,order[i].index);
+
+    //qsort (order,m,sizeof(IndexError),&compare_index_error);
+    qsort (order+startRow,nRows,sizeof(IndexError),&compare_index_error);
+
     //@@@ potential optimization: swap lambda and last_lambda pointers rather
     //    than copying the data. we must make sure lambda is properly
     //    returned to the caller
-    memcpy (last_lambda,lambda,m*sizeof(dReal));
+    //memcpy (last_lambda,lambda,m*sizeof(dReal));
+    memcpy (last_lambda+startRow,lambda+startRow,nRows*sizeof(dReal));
+
+    //if (thread_id == 0) for (int i=startRow;i<startRow+nRows;i++) printf("-----> %d %d %d %f %d\n",thread_id,iteration,i,order[i].error,order[i].index);
+
 #endif
 #ifdef RANDOMLY_REORDER_CONSTRAINTS
     if ((iteration & 7) == 0) {
-      for (int i=1; i<m; i++) {
-        int swapi = dRandInt(i+1);
+      #ifdef LOCK_WHILE_RANDOMLY_REORDER_CONSTRAINTS
+        boost::recursive_mutex::scoped_lock lock(*mutex); // lock for every swap
+      #endif
+      //for (int i=1; i<m; i++) {}   // swap across engire matrix
+      //  int swapi = dRandInt(i+1); // swap across engire matrix
+      for (int i=startRow+1; i<startRow+nRows; i++) { // swap within boundary of our own segment
+        int swapi = dRandInt(i+1-startRow)+startRow; // swap within boundary of our own segment
+        //printf("xxxxxxxx>id %d swaping order[%d].index=%d order[%d].index=%d\n",thread_id,i,order[i].index,swapi,order[swapi].index);
         IndexError tmp = order[i];
         order[i] = order[swapi];
         order[swapi] = tmp;
       }
+
+      // {
+      //   // verify
+      //   boost::recursive_mutex::scoped_lock lock(*mutex); // lock for every row
+      //   printf("  random id %d iter %d\n",thread_id,iteration);
+      //   for (int i=startRow+1; i<startRow+nRows; i++)
+      //     printf(" %5d,",i);
+      //   printf("\n");
+      //   for (int i=startRow+1; i<startRow+nRows; i++)
+      //     printf(" %5d;",(int)order[i].index);
+      //   printf("\n");
+      // }
     }
 #endif
 
-    for (int i=0; i<m; i++) {
+    //dSetZero (delta_error,m);
+    dReal rms_error = 0;
+
+    for (int i=startRow; i<startRow+nRows; i++) {
+
+      //boost::recursive_mutex::scoped_lock lock(*mutex); // lock for every row
+
       // @@@ potential optimization: we could pre-sort J and iMJ, thereby
       //     linearizing access to those arrays. hmmm, this does not seem
       //     like a win, but we should think carefully about our memory
@@ -500,10 +539,52 @@
         fc_ptr2 = (b2 >= 0) ? fc + 6*b2 : NULL;
       }
 
+#ifdef USE_JOINT_DAMPING
+      /*************************************************************/
+      /* compute b_damp                                            */
+      /* b is to be modified by b_damp                             */
+      /* where b_damp = -J*inv(M)*f_damp / Ad  (since b is rhs/Ad) */
+      /*                                                           */
+      /* initially f_damp is 0, so motion is undamped on first     */
+      /* iteration.                                                */
+      /*                                                           */
+      /*************************************************************/
+      {
+        b_damp[index] = 0;
+        int b1 = jb[index*2];
+        int b2 = jb[index*2+1];
+        dRealMutablePtr f_damp_ptr1 = f_damp + 6*b1;
+        dRealMutablePtr f_damp_ptr2 = (b2 >= 0) ? f_damp + 6*b2 : NULL;
+   
+        dRealPtr JiM_ptr = JiM + index*12;
+
+        // compute b_damp = JiM * f_damp, b_damp is preset to zero already
+        for (int j=0;j<6;j++) {
+          b_damp[index] += JiM_ptr[j] * f_damp_ptr1[j];
+          if (b2>=0) b_damp[index] += JiM_ptr[j+6] * f_damp_ptr2[j];
+        }
+   
+        // and scale JiM by Ad
+        b_damp[index] *= Ad[index];
+        // FIXME: find some kind of limiters that works as artificial dampers
+        // b_damp must make b smaller
+        // so b_damp must have opposite sign as b
+        // and abs(b_damp) < abs(b)
+        //if (b_damp[index]*b[index]>0) b_damp[index]=0;
+        //if (dFabs(b_damp[index])>dFabs(b[index])) b_damp[index]=-b[index];
+      }
+#endif
+
       dReal old_lambda = lambda[index];
 
       {
-        delta = b[index] - old_lambda*Ad[index];
+        delta = b[index] - old_lambda*Adcfm[index];
+#ifdef USE_JOINT_DAMPING
+        /***************************************************************************/
+        /* b is to be modified by b_damp = -J*inv(M)*f_damp / Ad since b is rhs/Ad */
+        /***************************************************************************/
+        delta += b_damp[index];
+#endif
 
         dRealPtr J_ptr = J + index*12;
         // @@@ potential optimization: SIMD-ize this and the b2 >= 0 case
@@ -554,6 +635,9 @@
         }
       }
 
+      rms_error += delta*delta;
+      delta_error[index] = dFabs(delta);
+
       //@@@ a trick that may or may not help
       //dReal ramp = (1-((dReal)(iteration+1)/(dReal)num_iterations));
       //delta *= ramp;
@@ -579,17 +663,684 @@
           fc_ptr2[5] += delta * iMJ_ptr[11];
         }
       }
+    } // end of for loop on m
+
+
+// do we need to compute norm across entire solution space (0,m)?
+// since local convergence might produce errors in other nodes?
+#ifdef RECOMPUTE_RMS
+    // recompute rms_error to be sure swap is not corrupting arrays
+    rms_error = 0;
+#ifdef USE_1NORM
+    //for (int i=startRow; i<startRow+nRows; i++)
+    for (int i=0; i<m; i++)
+    {
+      rms_error = dFabs(delta_error[order[i].index]) > rms_error ? dFabs(delta_error[order[i].index]) : rms_error; // 1norm test
     }
-  }
+#else // use 2 norm
+    //for (int i=startRow; i<startRow+nRows; i++)
+    for (int i=0; i<m; i++)  // use entire solution vector errors
+      rms_error += delta_error[order[i].index]*delta_error[order[i].index]; ///(dReal)nRows;
+    rms_error = sqrt(rms_error); ///(dReal)nRows;
+#endif
+#else
+    rms_error = sqrt(rms_error); ///(dReal)nRows;
+#endif
+
+    //printf("------ %d %d %20.18f\n",thread_id,iteration,rms_error);
+
+    //for (int i=startRow; i<startRow+nRows; i++) printf("debug: %d %f\n",i,delta_error[i]);
+
+
+    //{
+    //  // verify
+    //  boost::recursive_mutex::scoped_lock lock(*mutex); // lock for every row
+    //  printf("  random id %d iter %d\n",thread_id,iteration);
+    //  for (int i=startRow+1; i<startRow+nRows; i++)
+    //    printf(" %10d,",i);
+    //  printf("\n");
+    //  for (int i=startRow+1; i<startRow+nRows; i++)
+    //    printf(" %10d;",order[i].index);
+    //  printf("\n");
+    //  for (int i=startRow+1; i<startRow+nRows; i++)
+    //    printf(" %10.8f,",delta_error[i]);
+    //  printf("\n%f\n",rms_error);
+    //}
+
+
+#ifdef USE_JOINT_DAMPING
+    /****************************************************************/
+    /* compute v_damp per fc update                                 */
+    /*   based on all external forces fe, fc, f_damp                */
+    /*   v_damp should have started out same as v(n)                */
+    /*   v_damp should end up being v(n+1)                          */
+    /*                                                              */
+    /*  v_damp = v_current + stepsize * invM * f_all                */
+    /*                                                              */
+    /*  for DTSS, v_damp is                                         */
+    /*    = v_current - dtau/dt*(v_current - v_n)                   */
+    /*      + dtau * invM * f_all                                   */
+    /*                                                              */
+    /*  where dtau can be throttled                                 */
+    /*                                                              */
+    /*                                                              */
+    /****************************************************************/
+    {
+      const dReal *invIrow = invI;
+      dRealMutablePtr f_damp_ptr = f_damp;
+      dRealMutablePtr v_damp_ptr = v_damp;
+      dxBody *const *const bodyend = body + nb;
+      const dReal *fc_ptr = fc;
+
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; fc_ptr+=6, invIrow += 12, f_damp_ptr+=6, v_damp_ptr+=6, bodycurr++) {
+        // f_damp should be updated in SOR LCP
+
+        // compute the velocity update:
+        // add stepsize * invM * f_damp to the body velocity
+        dxBody *b = *bodycurr;
+        dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+
+        dReal tmp3[3];
+
+        // compute pseudo time step size
+        // dtau ~ dt * invM * f_all
+        dReal a0 = 0.1;
+        dReal dtau[6];
+        for (int j=0;j<3;j++)
+        {
+          dtau[j] = a0 * (stepsize * fc_ptr[j] + body_invMass_mul_stepsize * ( b->facc[j] + f_damp_ptr[j]));
+          dtau[j+3] = a0 * (stepsize * fc_ptr[j+3]);
+          tmp3[j] = a0 * stepsize*(b->tacc[j]+f_damp_ptr[j+3]);
+        }
+        dMultiplyAdd0_331 (dtau+3, invIrow, tmp3);
+        // alternatively
+        // dtau[0]=dtau[1]=dtau[2]=dtau[3]=dtau[4]=dtau[5]=stepsize/(dReal)num_iterations;
+
+
+        for (int j=0; j<3; j++) {
+          // note that cforce(fc) is really not a force but an acceleration, hence there is
+          // no premultiplying of invM here (compare to update due to external force 'facc' below)
+          // add dt*forces to the body velocity
+          v_damp_ptr[j]   = v_damp_ptr[j] - dtau[j]/stepsize*( v_damp_ptr[j] - b->lvel[j])
+                            + dtau[j] * fc_ptr[j]
+                            + dtau[j]*b->invMass * ( b->facc[j] + f_damp_ptr[j] );
+          // accumulate dt*torques
+          v_damp_ptr[j+3] = v_damp_ptr[j+3] - dtau[j+3]/stepsize*( v_damp_ptr[j+3] - b->avel[j])
+                            + b->avel[j] + dtau[j+3] * fc_ptr[j+3];
+          tmp3[j] = dtau[j+3]*(b->tacc[j] + f_damp_ptr[j+3]);
+        }
+        // v_damp = invI * f_damp
+        dMultiplyAdd0_331 (v_damp_ptr+3, invIrow, tmp3);
+
+      }
+    }
+
+    /****************************************************************/
+    /* compute f_damp per v_damp update                             */
+    /* compute damping force f_damp = J_damp' * B * J_damp * v_damp */
+    /*                                                              */
+    /*  we probably want to apply some kind of limiter on f_damp    */
+    /*  based on changes in v_damp.                                 */
+    /*                                                              */
+    /*  for starters, ramp up damping to increase stability.        */
+    /*                                                              */
+    /****************************************************************/
+    {
+      dSetZero (f_damp,6*nb); // reset f_damp, following update skips around, so cannot set to 0 inline
+      dRealPtr J_damp_ptr = J_damp;
+      // compute f_damp and velocity updates
+      // first compute v_joint_damp = J_damp * v_damp
+      // v_joint_damp is m_damp X 1 single column vector
+      for (int j=0; j<m_damp;J_damp_ptr+=12, j++) {
+        int b1 = jb_damp[j*2];
+        int b2 = jb_damp[j*2+1];
+        v_joint_damp[j] = 0;
+
+        // ramp-up : option to skip first few iterations to let the joint settle first
+        int skip = 0; //num_iterations-1;
+        dReal alpha = (iteration>=skip)?(dReal)(iteration-skip+1) / (dReal)(num_iterations-skip):0;
+        //dReal alpha = 1;
+
+        for (int k=0;k<6;k++) v_joint_damp[j] += alpha*J_damp_ptr[k] * v_damp[b1*6+k];
+        if (b2 >= 0) for (int k=0;k<6;k++) v_joint_damp[j] += alpha*J_damp_ptr[k+6] * v_damp[b2*6+k];
+        // multiply by damping coefficients (B is diagnoal)
+        v_joint_damp[j] *= coeff_damp[j];
+
+        // so now v_joint_damp = B * J_damp * v_damp
+        // update f_damp = J_damp' * v_joint_damp
+        for (int k=0; k<6; k++) f_damp[b1*6+k] -= J_damp_ptr[k]*v_joint_damp[j];
+        if (b2 >= 0) for (int k=0; k<6; k++) f_damp[b2*6+k] -= J_damp_ptr[6+k]*v_joint_damp[j];
+
+        //if (v_joint_damp[j] < 1000)
+        //  printf("ITER: %d j: %d m1: %f m2: %f v: %f\n",iteration,j,1.0/body[b1]->invMass,1.0/body[b2]->invMass,v_joint_damp[j]);
+      }
+
+    }
+#endif
+
+
+
+
+
+
+#if 0 
+    /****************************************************************/
+    /*                                                              */
+    /*                                                              */
+    /*  above computes lambda updates, if we want to update         */
+    /*  velocity during the iteration, make it happen below         */
+    /*                                                              */
+    /*                                                              */
+    /*                                                              */
+    /*  UPDATE ALL HERE                                             */
+    /*    JACOBIANS, POSE, ALL                                      */
+    /*                                                              */
+    /*                                                              */
+    /*  we might want to update rhs, jacobian and dependents (Ad*)  */
+    /*  but not update the actual pose and etc.                     */
+    /*  unless we update pose and etc based on dtss with            */
+    /*  additional forcing terms.                                   */
+    /*                                                              */
+    /*                                                              */
+    /*                                                              */
+    /*                                                              */
+    /*                                                              */
+    /****************************************************************/
+#ifdef USE_JOINT_DAMPING
+    /****************************************************************/
+    /*                                                              */
+    /* copy the updated velocity in v_damp into body velocity       */
+    /*                                                              */
+    /****************************************************************/
+    {
+      dRealMutablePtr v_damp_ptr = v_damp;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
+        dxBody *b = *bodycurr;
+        for (int j=0; j<6; j++) b->lvel[j] = v_damp_ptr[j];
+      }
+
+    }
+#endif
+
+    //  is there a way to save body poses first,
+    //   update body pose, compute new jacobians, then revert body poses?
+    {
+      // update the position and orientation from the new linear/angular velocity
+      // (over the given timestep)
+      IFTIMING (dTimerNow ("update position"));
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
+        dxBody *b = *bodycurr;
+        dxStepBody (b,stepsize);
+      }
+    }
+
+
+    /******************************************************************/
+    /*                                                                */
+    /*  recompute jacobians and things that depend on it              */
+    /*  update J, J_damp                                              */
+    /*                                                                */
+    /*  then, update Ad, Adcfm,                                       */
+    /*                                                                */
+    /*                                                                */
+    /******************************************************************/
+    {
+      IFTIMING (dTimerNow ("create J"));
+      // get jacobian data from constraints. an m*12 matrix will be created
+      // to store the two jacobian blocks from each constraint. it has this
+      // format:
+      //
+      //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 \    .
+      //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2  )-- jacobian for joint 0, body 1 and body 2 (3 rows)
+      //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 /
+      //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 )--- jacobian for joint 1, body 1 and body 2 (3 rows)
+      //   etc...
+      //
+      //   (lll) = linear jacobian data
+      //   (aaa) = angular jacobian data
+      //
+      dxJoint::Info2 Jinfo;
+      Jinfo.rowskip = 12;
+      Jinfo.fps = dRecip(stepsize);
+      Jinfo.erp = global_erp;
+
+      dReal *Jcopyrow = Jcopy;
+      unsigned ofsi = 0;
+#ifdef USE_JOINT_DAMPING
+      unsigned ofsi_damp = 0; // for joint damping
+#endif
+
+
+
+      // go through each joint and call jicurr->joint->getInfo2(Jinfo)
+      const dJointWithInfo1 *jicurr = jointiinfos;
+      const dJointWithInfo1 *const jiend = jicurr + nj;
+      for (; jicurr != jiend; jicurr++) {
+        dReal *const Jrow = J + ofsi * 12;
+        Jinfo.J1l = Jrow;
+        Jinfo.J1a = Jrow + 3;
+        Jinfo.J2l = Jrow + 6;
+        Jinfo.J2a = Jrow + 9;
+        Jinfo.c = c + ofsi;
+        Jinfo.cfm = cfm + ofsi;
+        Jinfo.lo = lo + ofsi;
+        Jinfo.hi = hi + ofsi;
+        Jinfo.findex = findex + ofsi;
+
+
+
+#ifdef USE_JOINT_DAMPING
+        /*******************************************************/
+        /*  allocate space for damped joint Jacobians          */
+        /*******************************************************/
+        if (jicurr->joint->use_damping)
+        {
+          // damping coefficient is in jicurr->info.damping_coefficient);
+          coeff_damp[ofsi_damp] = jicurr->joint->damping_coefficient;
+
+          // setup joint damping pointers so getinfo2 will fill in J_damp
+          dReal *const Jrow_damp = J_damp + ofsi_damp * 12;
+          Jinfo.J1ld = Jrow_damp;
+          Jinfo.J1ad = Jrow_damp + 3;
+          Jinfo.J2ld = Jrow_damp + 6;
+          Jinfo.J2ad = Jrow_damp + 9;
+          // one row of constraint per joint
+          ofsi_damp ++;
+        }
+#endif
+
+
+        
+        // now write all information into J
+        dxJoint *joint = jicurr->joint;
+        joint->getInfo2 (&Jinfo);
+
+        const int infom = jicurr->info.m;
+
+        // we need a copy of Jacobian for joint feedbacks
+        // because it gets destroyed by SOR solver
+        // instead of saving all Jacobian, we can save just rows
+        // for joints, that requested feedback (which is normally much less)
+        if (joint->feedback) {
+          const int rowels = infom * 12;
+          memcpy(Jcopyrow, Jrow, rowels * sizeof(dReal));
+          Jcopyrow += rowels;
+        }
+
+        // adjust returned findex values for global index numbering
+        int *findex_ofsi = findex + ofsi;
+        for (int j=0; j<infom; j++) {
+          int fival = findex_ofsi[j];
+          if (fival >= 0) 
+            findex_ofsi[j] = fival + ofsi;
+        }
+
+        ofsi += infom;
+      }
+    }
+
+
+
+    // re-precompute iMJ = inv(M)*J'
+    compute_invM_JT (m,J,iMJ,jb,body,invI);
+
+
+    // re-compute Ad
+    {
+      // precompute 1 / diagonals of A
+      dRealPtr iMJ_ptr = iMJ;
+      dRealPtr J_ptr = J;
+      for (int i=0; i<m; J_ptr += 12, iMJ_ptr += 12, i++) {
+        dReal sum = 0;
+        for (int j=0; j<6; j++) sum += iMJ_ptr[j] * J_ptr[j];
+        if (jb[i*2+1] >= 0) {
+          for (int k=6; k<12; k++) sum += iMJ_ptr[k] * J_ptr[k];
+        }
+        Ad[i] = sor_w / (sum + cfm[i]);
+      }
+    }
+
+
+    // re-compute Adcfm
+    {
+      // NOTE: This may seem unnecessary but it's indeed an optimization 
+      // to move multiplication by Ad[i] and cfm[i] out of iteration loop.
+
+      // scale J and b by Ad
+      dRealMutablePtr J_ptr = J;
+      for (int i=0; i<m; J_ptr += 12, i++) {
+        dReal Ad_i = Ad[i];
+        for (int j=0; j<12; j++) {
+          J_ptr[j] *= Ad_i;
+        }
+        b[i] *= Ad_i;
+        // scale Ad by CFM. N.B. this should be done last since it is used above
+        Adcfm[i] = Ad_i * cfm[i];
+      }
+    }
+
+
+  #ifndef REORDER_CONSTRAINTS
+    {
+      // make sure constraints with findex < 0 come first.
+      IndexError *orderhead = order, *ordertail = order + (m - 1);
+
+      // Fill the array from both ends
+      for (int i=0; i<m; i++) {
+        if (findex[i] < 0) {
+          orderhead->index = i; // Place them at the front
+          ++orderhead;
+        } else {
+          ordertail->index = i; // Place them at the end
+          --ordertail;
+        }
+      }
+      dIASSERT (orderhead-ordertail==1);
+    }
+  #endif
+#endif
+
+
+
+
+
+
+
+
+
+
+
+    /****************************************************************/
+    /*                                                              */
+    /*                                                              */
+    /*   check convergence                                          */
+    /*                                                              */
+    /*                                                              */
+    /****************************************************************/
+#ifdef SHOW_CONVERGENCE
+    printf("MONITOR: id: %d iteration: %d error: %20.16f\n",thread_id,iteration,rms_error);
+#endif
+
+    if (rms_error < sor_lcp_tol)
+    {
+      #ifdef REPORT_MONITOR
+        printf("CONVERGED: id: %d steps: %d rms(%20.18f)\n",thread_id,iteration,rms_error);
+      #endif
+      break;
+    }
+    else if (iteration == num_iterations -1)
+    {
+      #ifdef REPORT_MONITOR
+        printf("**********ERROR: id: %d did not converge in %d steps, rms(%20.18f)\n",thread_id,num_iterations,rms_error);
+      #endif
+    }
+
+  } // end of for loop on iterations
+
+  gettimeofday(&tv,NULL);
+  double end_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  #ifdef REPORT_THREAD_TIMING
+    printf("      quickstep row thread %d start time %f ended time %f duration %f\n",thread_id,cur_time,end_time,end_time - cur_time);
+  #endif
 }
 
-struct dJointWithInfo1
+static void SOR_LCP (dxWorldProcessContext *context,
+  const int m, const int nb, const int nj, dRealMutablePtr J, dRealMutablePtr Jcopy, int *jb, dxBody * const *body,
+  dJointWithInfo1 *const jointiinfos,
+  dRealPtr invI, dRealMutablePtr lambda, dRealMutablePtr fc, dRealMutablePtr b,
+  dRealMutablePtr lo, dRealMutablePtr hi, dRealMutablePtr cfm, int *findex,
+  const dxQuickStepParameters *qs,dReal global_erp, dRealMutablePtr c, dRealMutablePtr v_save,
+#ifdef USE_JOINT_DAMPING
+  const int m_damp,dRealMutablePtr J_damp, dRealMutablePtr coeff_damp, int *jb_damp,dRealMutablePtr v_damp,
+  dRealMutablePtr f_damp,dRealMutablePtr v_joint_damp, dRealPtr JiM, // damping related
+#endif
+#ifdef USE_TPROW
+  boost::threadpool::pool* row_threadpool,
+#endif
+  const dReal stepsize) // for updating v_damp along the way
 {
-  dxJoint *joint;
-  dxJoint::Info1 info;
-};
+#ifdef WARM_STARTING
+  {
+    // for warm starting, this seems to be necessary to prevent
+    // jerkiness in motor-driven joints. i have no idea why this works.
+    for (int i=0; i<m; i++) lambda[i] *= 0.9;
+  }
+#else
+  dSetZero (lambda,m);
+#endif
 
-void dxQuickStepper (dxWorldProcessContext *context, 
+  // precompute iMJ = inv(M)*J'
+  dReal *iMJ = context->AllocateArray<dReal> (m*12);
+  compute_invM_JT (m,J,iMJ,jb,body,invI);
+
+  // compute fc=(inv(M)*J')*lambda. we will incrementally maintain fc
+  // as we change lambda.
+#ifdef WARM_STARTING
+  multiply_invM_JT (m,nb,iMJ,jb,lambda,fc);
+#else
+  dSetZero (fc,nb*6);
+#endif
+
+  dReal *Ad = context->AllocateArray<dReal> (m);
+
+  {
+    const dReal sor_w = qs->w;		// SOR over-relaxation parameter
+    // precompute 1 / diagonals of A
+    dRealPtr iMJ_ptr = iMJ;
+    dRealPtr J_ptr = J;
+    for (int i=0; i<m; J_ptr += 12, iMJ_ptr += 12, i++) {
+      dReal sum = 0;
+      for (int j=0; j<6; j++) sum += iMJ_ptr[j] * J_ptr[j];
+      if (jb[i*2+1] >= 0) {
+        for (int k=6; k<12; k++) sum += iMJ_ptr[k] * J_ptr[k];
+      }
+      Ad[i] = sor_w / (sum + cfm[i]);
+    }
+  }
+
+
+  /********************************/
+  /* allocate for J*invM*f_damp   */
+  /* which is a mX1 column vector */
+  /********************************/
+  dReal *Adcfm = context->AllocateArray<dReal> (m);
+
+
+  {
+    // NOTE: This may seem unnecessary but it's indeed an optimization 
+    // to move multiplication by Ad[i] and cfm[i] out of iteration loop.
+
+    // scale J and b by Ad
+    dRealMutablePtr J_ptr = J;
+    for (int i=0; i<m; J_ptr += 12, i++) {
+      dReal Ad_i = Ad[i];
+      for (int j=0; j<12; j++) {
+        J_ptr[j] *= Ad_i;
+      }
+      b[i] *= Ad_i;
+      // scale Ad by CFM. N.B. this should be done last since it is used above
+      Adcfm[i] = Ad_i * cfm[i];
+    }
+  }
+
+
+  // order to solve constraint rows in
+  IndexError *order = context->AllocateArray<IndexError> (m);
+
+  dReal *delta_error = context->AllocateArray<dReal> (m);
+
+#ifndef REORDER_CONSTRAINTS
+  {
+    // make sure constraints with findex < 0 come first.
+    IndexError *orderhead = order, *ordertail = order + (m - 1);
+
+    // Fill the array from both ends
+    for (int i=0; i<m; i++) {
+      if (findex[i] < 0) {
+        orderhead->index = i; // Place them at the front
+        ++orderhead;
+      } else {
+        ordertail->index = i; // Place them at the end
+        --ordertail;
+      }
+    }
+    dIASSERT (orderhead-ordertail==1);
+  }
+#endif
+
+#ifdef REORDER_CONSTRAINTS
+  // the lambda computed at the previous iteration.
+  // this is used to measure error for when we are reordering the indexes.
+  dReal *last_lambda = context->AllocateArray<dReal> (m);
+#endif
+
+#ifdef USE_JOINT_DAMPING
+  dReal *b_damp = context->AllocateArray<dReal> (m);
+#endif
+
+
+  boost::recursive_mutex* mutex = new boost::recursive_mutex();
+
+  const int num_iterations = qs->num_iterations;
+
+
+
+
+  int num_chunks = qs->num_chunks;
+
+  // prepare pointers for threads
+  int tmpInt_size = 8;
+  int tmpInt[tmpInt_size*num_chunks];
+  int tmpReal_size = 4;
+  dReal tmpReal[tmpReal_size*num_chunks];
+  int tmpIntPtr_size = 3;
+  int* tmpIntPtr[tmpIntPtr_size*num_chunks];
+  int tmpRealPtr_size = 2;
+  dRealPtr tmpRealPtr[tmpRealPtr_size*num_chunks];
+  int tmpMutablePtr_size = 21;
+  dRealMutablePtr tmpMutablePtr[tmpMutablePtr_size*num_chunks];
+
+  int num_overlap = qs->num_overlap;
+  int chunk = m / num_chunks+1;
+  chunk = chunk > 0 ? chunk : 1;
+  int thread_id = 0;
+
+
+
+
+  struct timeval tv;
+  double cur_time;
+  gettimeofday(&tv,NULL);
+  cur_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  //printf("    quickstep start threads at time %f\n",cur_time);
+
+
+
+
+  IFTIMING (dTimerNow ("start pgs rows"));
+  for (int i=0; i<m; i+= chunk,thread_id++)
+  {
+    //for (int ijk=0;ijk<m;ijk++) printf("aaaaaaaaaaaaaaaaaaaaa> id:%d jb[%d]=%d\n",thread_id,ijk,jb[ijk]);
+
+    int nStart = i - num_overlap < 0 ? 0 : i - num_overlap;
+    int nEnd   = i + chunk + num_overlap;
+    if (nEnd > m) nEnd = m;
+    // if every one reorders constraints, this might just work
+    // comment out below if using defaults (0 and m) so every thread runs through all joints
+    tmpInt[0+thread_id*tmpInt_size] = nStart;   // 0
+    tmpInt[1+thread_id*tmpInt_size] = nEnd - nStart; // m
+    tmpInt[2+thread_id*tmpInt_size] = m; // m
+    tmpInt[3+thread_id*tmpInt_size] = nb;
+    tmpInt[4+thread_id*tmpInt_size] = m_damp;
+    tmpInt[5+thread_id*tmpInt_size] = num_iterations;
+    tmpInt[6+thread_id*tmpInt_size] = thread_id;
+    tmpInt[7+thread_id*tmpInt_size] = nj;
+    tmpReal[0+thread_id*tmpReal_size] = stepsize;
+    tmpReal[1+thread_id*tmpReal_size] = qs->sor_lcp_tolerance;
+    tmpReal[2+thread_id*tmpReal_size] = qs->w;
+    tmpReal[3+thread_id*tmpReal_size] = global_erp;
+    tmpIntPtr[0+thread_id*tmpIntPtr_size] = jb;
+    tmpIntPtr[1+thread_id*tmpIntPtr_size] = jb_damp;
+    tmpIntPtr[2+thread_id*tmpIntPtr_size] = findex;
+    tmpRealPtr[0+thread_id*tmpRealPtr_size] = JiM;
+    tmpRealPtr[1+thread_id*tmpRealPtr_size] = invI;
+    tmpMutablePtr[0+thread_id*tmpMutablePtr_size] = b;
+    tmpMutablePtr[1+thread_id*tmpMutablePtr_size] = J;
+    tmpMutablePtr[2+thread_id*tmpMutablePtr_size] = fc;
+    tmpMutablePtr[3+thread_id*tmpMutablePtr_size] = lambda;
+    tmpMutablePtr[4+thread_id*tmpMutablePtr_size] = iMJ;
+    #ifdef USE_JOINT_DAMPING
+      tmpMutablePtr[5+thread_id*tmpMutablePtr_size] = b_damp;
+      tmpMutablePtr[6+thread_id*tmpMutablePtr_size] = f_damp;
+      tmpMutablePtr[7+thread_id*tmpMutablePtr_size] = v_damp;
+      tmpMutablePtr[8+thread_id*tmpMutablePtr_size] = J_damp;
+      tmpMutablePtr[9+thread_id*tmpMutablePtr_size] = v_joint_damp;
+      #ifdef REORDER_CONSTRAINTS
+        tmpMutablePtr[10+thread_id*tmpMutablePtr_size] = last_lambda;
+      #endif
+    #endif
+    tmpMutablePtr[11+thread_id*tmpMutablePtr_size] = delta_error ;
+    tmpMutablePtr[12+thread_id*tmpMutablePtr_size] = Ad ;
+    tmpMutablePtr[13+thread_id*tmpMutablePtr_size] = Adcfm ;
+    tmpMutablePtr[14+thread_id*tmpMutablePtr_size] = Jcopy ;
+    tmpMutablePtr[15+thread_id*tmpMutablePtr_size] = hi;
+    tmpMutablePtr[16+thread_id*tmpMutablePtr_size] = lo;
+    tmpMutablePtr[17+thread_id*tmpMutablePtr_size] = coeff_damp;
+    tmpMutablePtr[18+thread_id*tmpMutablePtr_size] = cfm;
+    tmpMutablePtr[19+thread_id*tmpMutablePtr_size] = c;
+    tmpMutablePtr[20+thread_id*tmpMutablePtr_size] = v_save;
+
+    #ifdef REPORT_MONITOR
+      printf("thread summary: id %d i %d m %d chunk %d start %d end %d \n",thread_id,i,m,chunk,nStart,nEnd);
+    #endif
+#ifdef USE_TPROW
+    if (row_threadpool->size() > 1)
+      row_threadpool->schedule(boost::bind(ComputeRows,order, body, tmpInt+thread_id*tmpInt_size,
+                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
+                           jointiinfos,
+                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex));
+    else //automatically skip threadpool if only 1 thread allocated
+      ComputeRows(order, body, tmpInt+thread_id*tmpInt_size,
+                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
+                           jointiinfos,
+                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex);
+#else
+    ComputeRows(order, body, tmpInt+thread_id*tmpInt_size,
+                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
+                           jointiinfos,
+                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex);
+#endif
+  }
+
+
+  // check time for scheduling, this is usually very quick
+  //gettimeofday(&tv,NULL);
+  //double wait_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  //printf("      quickstep done scheduling start time %f stopped time %f duration %f\n",cur_time,wait_time,wait_time - cur_time);
+
+#ifdef USE_TPROW
+  IFTIMING (dTimerNow ("wait for threads"));
+  if (row_threadpool->size() > 1)
+    row_threadpool->wait();
+  IFTIMING (dTimerNow ("threads done"));
+#endif
+
+
+
+  gettimeofday(&tv,NULL);
+  double end_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  #ifdef REPORT_THREAD_TIMING
+    printf("    quickstep threads start time %f stopped time %f duration %f\n",cur_time,end_time,end_time - cur_time);
+  #endif
+
+
+
+  delete mutex;
+}
+
+void dxQuickStepper (dxWorldProcessContext *shared_context,dxWorldProcessContext *context, 
   dxWorld *world, dxBody * const *body, int nb,
   dxJoint * const *_joint, int _nj, dReal stepsize)
 {
@@ -630,7 +1381,21 @@
     }
   }
 
+  // get the masses for every body
+  dReal *invM = context->AllocateArray<dReal> (nb);
   {
+    dReal *invMrow = invM;
+    dxBody *const *const bodyend = body + nb;
+    for (dxBody *const *bodycurr = body; bodycurr != bodyend; invMrow++, bodycurr++) {
+      dxBody *b = *bodycurr;
+      //*invMrow = b->mass.mass;
+      *invMrow = b->invMass;
+
+    }
+  }
+
+
+  {
     // add the gravity force to all bodies
     // since gravity does normally have only one component it's more efficient
     // to run three loops for each individual component
@@ -667,6 +1432,11 @@
   // get joint information (m = total constraint dimension, nub = number of unbounded variables).
   // joints with m=0 are inactive and are removed from the joints array
   // entirely, so that the code that follows does not consider them.
+  // 
+  // 
+  // allocate jointiinfos array and update it with getInfo1 for each joint
+  // 
+  // 
   dJointWithInfo1 *const jointiinfos = context->AllocateArray<dJointWithInfo1> (_nj);
   int nj;
   
@@ -705,13 +1475,53 @@
     mfb = mfbcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  /************************************************************************/
+  /* for joint damping, get the total number of rows for damping jacobian */
+  /************************************************************************/
+  int m_damp; // number of rows for damped joint jacobian
+  {
+    int mcurr = 0;
+    const dJointWithInfo1 *jicurr = jointiinfos; // info1 stored in jointiinfos
+    const dJointWithInfo1 *const jiend = jicurr + nj;
+    for (; jicurr != jiend; jicurr++)
+      if (jicurr->joint->use_damping)
+        mcurr ++;
+
+    m_damp = mcurr;
+  }
+#endif
+
   // if there are constraints, compute the constraint force
   dReal *J = NULL;
   int *jb = NULL;
+  dReal *v_save = NULL;
+
+#ifdef USE_JOINT_DAMPING
+  /*********************************/
+  /* do the same for damped joints */
+  /*********************************/
+  dReal *v_damp;
+  dReal *J_damp = NULL;
+  dReal *v_joint_damp = NULL;
+  dReal* f_damp = NULL;
+  dReal *JiM = NULL;
+  int *jb_damp = NULL;
+  dReal *coeff_damp = NULL;
+  dReal *c = NULL;
+#endif
+
   if (m > 0) {
     dReal *cfm, *lo, *hi, *rhs, *Jcopy;
     int *findex;
 
+    /************************************************/
+    /*                                              */
+    /* allocate cfm, lo, hi, findex, jb, rhs, Jcopy */
+    /*                                              */
+    /*          JiM                                 */
+    /*                                              */
+    /************************************************/
     {
       int mlocal = m;
 
@@ -740,10 +1550,72 @@
       rhs = context->AllocateArray<dReal> (mlocal);
 
       Jcopy = context->AllocateArray<dReal> (mfb*12);
+
+      c = context->AllocateArray<dReal> (mlocal);
+
+      const unsigned v_save_elements = nb*6;
+      v_save = context->AllocateArray<dReal> (v_save_elements);
+
+#ifdef USE_JOINT_DAMPING
+      JiM = context->AllocateArray<dReal> (mlocal*12); // for computing b_damp
+      dSetZero (JiM,jelements);
+#endif
     }
 
+#ifdef USE_JOINT_DAMPING
+    /******************************************************************/
+    /*                                                                */
+    /* allocate more for damping                                      */
+    /*                                                                */
+    /*   J_damp, v_joint_damp, jb_damp, f_damp, v_damp, coeff_damp    */
+    /*                                                                */
+    /******************************************************************/
+    {
+      int mlocal = m_damp;
+
+      const unsigned jelements = mlocal*12;
+      J_damp = context->AllocateArray<dReal> (jelements);
+      dSetZero (J_damp,jelements);
+
+      // v_joint = J_damp * v
+      // v_joint is the velocity of the joint in joint space
+      // (relative angular rates of attached bodies)
+      const unsigned v_joint_damp_elements = mlocal;
+      v_joint_damp = context->AllocateArray<dReal> (v_joint_damp_elements);
+      dSetZero (v_joint_damp,v_joint_damp_elements);
+
+      // jb is the body index for each jacobian
+      const unsigned jbelements = mlocal*2;
+      jb_damp = context->AllocateArray<int> (jbelements);
+
+      const unsigned f_damp_elements = nb*6;
+      f_damp = context->AllocateArray<dReal> (f_damp_elements);
+      dSetZero (f_damp,f_damp_elements);
+
+      const unsigned v_damp_elements = nb*6;
+      v_damp = context->AllocateArray<dReal> (v_damp_elements);
+      dSetZero (v_damp,v_damp_elements);
+
+      const unsigned coeffelements = mlocal;
+      coeff_damp = context->AllocateArray<dReal> (coeffelements);
+      dSetZero (coeff_damp,coeffelements);
+    }
+#endif
+
     BEGIN_STATE_SAVE(context, cstate) {
-      dReal *c = context->AllocateArray<dReal> (m);
+
+
+
+
+      /******************************************************************/
+      /*                                                                */
+      /*                                                                */
+      /*  allocate get info, update                                     */
+      /*      c, jointiinfos (getInfo2), J, Jcopy, findex               */
+      /*                                                                */
+      /*      damping_coefficient, J_damp                               */
+      /*                                                                */
+      /******************************************************************/
       dSetZero (c, m);
 
       {
@@ -753,9 +1625,9 @@
         // format:
         //
         //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 \    .
-        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2  }-- jacobian for joint 0, body 1 and body 2 (3 rows)
+        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2  )-- jacobian for joint 0, body 1 and body 2 (3 rows)
         //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 /
-        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 }--- jacobian for joint 1, body 1 and body 2 (3 rows)
+        //   l1 l1 l1 a1 a1 a1 l2 l2 l2 a2 a2 a2 )--- jacobian for joint 1, body 1 and body 2 (3 rows)
         //   etc...
         //
         //   (lll) = linear jacobian data
@@ -768,6 +1640,9 @@
 
         dReal *Jcopyrow = Jcopy;
         unsigned ofsi = 0;
+#ifdef USE_JOINT_DAMPING
+        unsigned ofsi_damp = 0; // for joint damping
+#endif
         const dJointWithInfo1 *jicurr = jointiinfos;
         const dJointWithInfo1 *const jiend = jicurr + nj;
         for (; jicurr != jiend; jicurr++) {
@@ -781,7 +1656,32 @@
           Jinfo.lo = lo + ofsi;
           Jinfo.hi = hi + ofsi;
           Jinfo.findex = findex + ofsi;
+
+
+
+#ifdef USE_JOINT_DAMPING
+          /*******************************************************/
+          /*  allocate space for damped joint Jacobians          */
+          /*******************************************************/
+          if (jicurr->joint->use_damping)
+          {
+            // damping coefficient is in jicurr->info.damping_coefficient);
+            coeff_damp[ofsi_damp] = jicurr->joint->damping_coefficient;
+
+            // setup joint damping pointers so getinfo2 will fill in J_damp
+            dReal *const Jrow_damp = J_damp + ofsi_damp * 12;
+            Jinfo.J1ld = Jrow_damp;
+            Jinfo.J1ad = Jrow_damp + 3;
+            Jinfo.J2ld = Jrow_damp + 6;
+            Jinfo.J2ad = Jrow_damp + 9;
+            // one row of constraint per joint
+            ofsi_damp ++;
+          }
+#endif
+
+
           
+          // now write all information into J
           dxJoint *joint = jicurr->joint;
           joint->getInfo2 (&Jinfo);
 
@@ -809,6 +1709,11 @@
         }
       }
 
+      /********************************************************************/
+      /*                                                                  */
+      /*  update jb (array of corresponding body numbers for each joint)  */
+      /*                                                                  */
+      /********************************************************************/
       {
         // create an array of body numbers for each joint row
         int *jb_ptr = jb;
@@ -827,11 +1732,52 @@
           }
         }
         dIASSERT (jb_ptr == jb+2*m);
+        //printf("jjjjjjjjj %d %d\n",jb[0],jb[1]);
       }
 
+#ifdef USE_JOINT_DAMPING
+      /*************************************************************************/
+      /*                                                                       */
+      /*  update jb_damp (array of corresponding body numbers for each joint)  */
+      /*                                                                       */
+      /*     create an array of body numbers for each damped joint row         */
+      /*                                                                       */
+      /*************************************************************************/
+      {
+        int *jb_damp_ptr = jb_damp;
+        const dJointWithInfo1 *jicurr = jointiinfos;
+        const dJointWithInfo1 *const jiend = jicurr + nj;
+        for (; jicurr != jiend; jicurr++) {
+          if (jicurr->joint->use_damping)
+          {
+            dxJoint *joint = jicurr->joint;
+            const int infom = 1; // one damping jacobian row per hinge joint
+
+            int b1 = (joint->node[0].body) ? (joint->node[0].body->tag) : -1;
+            int b2 = (joint->node[1].body) ? (joint->node[1].body->tag) : -1;
+            for (int j=0; j<infom; j++) {
+              jb_damp_ptr[0] = b1;
+              jb_damp_ptr[1] = b2;
+              jb_damp_ptr += 2;
+            }
+          }
+        }
+        dIASSERT (jb_damp_ptr == jb_damp+2*m_damp);
+      }
+#endif
+
+
+
       BEGIN_STATE_SAVE(context, tmp1state) {
+
         IFTIMING (dTimerNow ("compute rhs"));
-        // compute the right hand side `rhs'
+
+        /*************************************************************/
+        /*                                                           */
+        /*  begin to compute rhs                                     */
+        /*    update also invI                                       */
+        /*                                                           */
+        /*************************************************************/
         dReal *tmp1 = context->AllocateArray<dReal> (nb*6);
         // put v/h + invM*fe into tmp1
         dReal *tmp1curr = tmp1;
@@ -847,6 +1793,40 @@
 
         // put J*tmp1 into rhs
         multiply_J (m,J,jb,tmp1,rhs);
+
+#ifdef USE_JOINT_DAMPING
+        /*************************************************************/
+        /* compute J*inv(M) here JiM, it does not change             */
+        /* where b_damp = -J*inv(M)*f_damp / Ad  (since b is rhs/Ad) */
+        /* and b is to be modified by b_damp                         */
+        /*************************************************************/
+        {
+          dRealPtr J_ptr = J;
+          dRealMutablePtr JiM_ptr = JiM; // intermediate solution storage
+          for (int i=0; i<m;J_ptr+=12,JiM_ptr+=12, i++) {
+
+            // compute JiM = J * invM
+            int b1 = jb[i*2];
+            int b2 = jb[i*2+1];
+            dReal k1 = body[b1]->invMass;
+
+            for (int j=0; j<3 ; j++) JiM_ptr[j] = J_ptr[j]*k1;
+
+
+            const dReal *invI_ptr1 = invI + 12*b1;
+            for (int j=0;j<3;j++) for (int k=0;k<3;k++){
+              JiM_ptr[3+j] += J_ptr[3+k]*invI_ptr1[k*4+j];
+            }
+
+            if (b2 >= 0){
+              dReal k2 = body[b2]->invMass;
+              for (int j=0; j<3 ; j++) JiM_ptr[j+6] += k2*J_ptr[j+6];
+              const dReal *invI_ptr2 = invI + 12*b2;
+              for (int j=0;j<3;j++) for (int k=0;k<3;k++) JiM_ptr[9+j] += J_ptr[9+k]*invI_ptr2[k*4+j];
+            }
+          }
+        }
+#endif
       
       } END_STATE_SAVE(context, tmp1state);
 
@@ -858,6 +1838,49 @@
 
     } END_STATE_SAVE(context, cstate);
 
+    /*****************************************************************************/
+    /* save v_save                                                               */
+    /*   save the current velocity vector so later when it's updated in dtss     */
+    /*   iteration cycle, we still have v_n for rhs                              */
+    /*****************************************************************************/
+    {
+      // allocate v_save
+      dRealMutablePtr v_save_ptr = v_save;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; v_save_ptr+=6, bodycurr++) {
+        dxBody *b = *bodycurr;
+        v_save_ptr[0] = b->lvel[0];
+        v_save_ptr[1] = b->lvel[1];
+        v_save_ptr[2] = b->lvel[2];
+        v_save_ptr[3] = b->avel[0];
+        v_save_ptr[4] = b->avel[1];
+        v_save_ptr[5] = b->avel[2];
+      }
+    }
+
+#ifdef USE_JOINT_DAMPING
+    /*****************************************************************************/
+    /* update v_damp                                                             */
+    /*   create a nb*6 by 1 vector (v_damp) to store estimated implicit velocity */
+    /*  as it is updated in the iterative loop                                   */
+    /*****************************************************************************/
+    {
+      // allocate v_damp
+      dRealMutablePtr v_damp_ptr = v_damp;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; v_damp_ptr+=6, bodycurr++) {
+        dxBody *b = *bodycurr;
+        v_damp_ptr[0] = b->lvel[0];
+        v_damp_ptr[1] = b->lvel[1];
+        v_damp_ptr[2] = b->lvel[2];
+        v_damp_ptr[3] = b->avel[0];
+        v_damp_ptr[4] = b->avel[1];
+        v_damp_ptr[5] = b->avel[2];
+      }
+    }
+#endif
+
+
     // load lambda from the value saved on the previous iteration
     dReal *lambda = context->AllocateArray<dReal> (m);
 
@@ -874,12 +1897,27 @@
     }
 #endif
 
+
+
+    /*****************************************************************************/
+    /*                                                                           */
+    /*  allocate cforce and call SOR_LCP                                         */
+    /*                                                                           */
+    /*****************************************************************************/
     dReal *cforce = context->AllocateArray<dReal> (nb*6);
 
+
     BEGIN_STATE_SAVE(context, lcpstate) {
       IFTIMING (dTimerNow ("solving LCP problem"));
       // solve the LCP problem and get lambda and invM*constraint_force
-      SOR_LCP (context,m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs);
+      SOR_LCP (context,m,nb,nj,J,Jcopy,jb,body,jointiinfos,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs,world->global_erp,c,v_save,
+#ifdef USE_JOINT_DAMPING
+               m_damp,J_damp,coeff_damp,jb_damp,v_damp,f_damp,v_joint_damp,JiM,
+#endif
+#ifdef USE_TPROW
+               world->row_threadpool,
+#endif
+               stepsize);
 
     } END_STATE_SAVE(context, lcpstate);
 
@@ -899,10 +1937,44 @@
     }
 #endif
 
+#ifdef USE_JOINT_DAMPING
+    /****************************************************************/
+    /* perform velocity update due to damping force                 */
+    /*  v_new = n_old + stepsize * invM * f_damp                    */
+    /****************************************************************/
+    {
+      const dReal *invIrow = invI;
+
+      dRealMutablePtr f_damp_ptr = f_damp;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; invIrow += 12, f_damp_ptr+=6, bodycurr++) {
+        // f_damp should be updated in SOR LCP
+
+        // compute the velocity update:
+        // add stepsize * invM * f_damp to the body velocity
+        dxBody *b = *bodycurr;
+        dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+        for (int j=0; j<3; j++) {
+          b->lvel[j] += body_invMass_mul_stepsize * f_damp_ptr[j];
+          f_damp_ptr[3+j] *= stepsize; // multiply torque part by step size
+        }
+        dMultiplyAdd0_331 (b->avel, invIrow, f_damp_ptr+3);
+      }
+
+    }
+#endif
+
+
+    //
+    // update body velocities due to constraint forces
+    //
     // note that the SOR method overwrites rhs and J at this point, so
     // they should not be used again.
-
     {
+      IFTIMING (dTimerNow ("velocity update due to constraint forces"));
+      // note that cforce is really not a force but an acceleration, hence there is
+      // no premultiplying of invM here (compare to update due to external force 'facc' below)
+      //
       // add stepsize * cforce to the body velocity
       const dReal *cforcecurr = cforce;
       dxBody *const *const bodyend = body + nb;
@@ -915,6 +1987,7 @@
       }
     }
 
+    // update feedback requests
     if (mfb > 0) {
       // straightforward computation of joint constraint forces:
       // multiply related lambdas with respective J' block for joints
@@ -955,8 +2028,11 @@
         lambdacurr += infom;
       }
     }
-  }
+  }  // end of -- if m>0, computing constraint forces using SOR_LCP and updating velocities
 
+  //
+  // update velocity due to non-constraint external forces (b->facc and b->tacc)
+  //
   {
     IFTIMING (dTimerNow ("compute velocity update"));
     // compute the velocity update:
@@ -1022,6 +2098,7 @@
 
   IFTIMING (dTimerEnd());
   IFTIMING (if (m > 0) dTimerReport (stdout,1));
+
 }
 
 #ifdef USE_CG_LCP
@@ -1033,14 +2110,23 @@
 }
 #endif
 
-static size_t EstimateSOR_LCPMemoryRequirements(int m)
+static size_t EstimateSOR_LCPMemoryRequirements(int m
+#ifdef USE_JOINT_DAMPING
+                                               ,int m_damp
+#endif
+                                               )
 {
   size_t res = dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for iMJ
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Ad
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Adcfm
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for delta_error
   res += dEFFICIENT_SIZE(sizeof(IndexError) * m); // for order
 #ifdef REORDER_CONSTRAINTS
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for last_lambda
 #endif
+#ifdef USE_JOINT_DAMPING
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for b_damp
+#endif
   return res;
 }
 
@@ -1069,9 +2155,28 @@
     nj = njcurr; m = mcurr; mfb = mfbcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  int m_damp;
+  {
+    int m_dampcurr = 0;
+    dxJoint::SureMaxInfo info;
+    dxJoint *const *const _jend = _joint + _nj;
+    for (dxJoint *const *_jcurr = _joint; _jcurr != _jend; _jcurr++) {
+      dxJoint *j = *_jcurr;
+      /***************************/
+      /* size for damping joints */
+      /***************************/
+      if (j->use_damping)
+        m_dampcurr ++;
+    }
+    m_damp = m_dampcurr;
+  }
+#endif
+
   size_t res = 0;
 
   res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for invI
+  res += dEFFICIENT_SIZE(sizeof(dReal) * nb); // for invM
 
   {
     size_t sub1_res1 = dEFFICIENT_SIZE(sizeof(dJointWithInfo1) * _nj); // for initial jointiinfos
@@ -1079,10 +2184,21 @@
     size_t sub1_res2 = dEFFICIENT_SIZE(sizeof(dJointWithInfo1) * nj); // for shrunk jointiinfos
     if (m > 0) {
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for J
-      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 12 * m); // for jb
-      sub1_res2 += 4 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm, lo, hi, rhs
+      sub1_res2 += 5 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm, lo, hi, rhs, c
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 2 * m); // for jb            FIXME: shoulbe be 2 not 12?
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * m); // for findex
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * mfb); // for Jcopy
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for v_save
+
+#ifdef USE_JOINT_DAMPING
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m_damp); // for J_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp ); // for v_joint_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 2 * m_damp); // for jb_damp            FIXME: shoulbe be 2 not 12?
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for f_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12*m); // for JiM
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for v_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp); // for coeff_damp
+#endif
       {
         size_t sub2_res1 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for c
         {
@@ -1096,7 +2212,11 @@
         size_t sub2_res2 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for lambda
         sub2_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for cforce
         {
-          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m); // for SOR_LCP
+          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m
+#ifdef USE_JOINT_DAMPING
+                                                              ,m_damp
+#endif
+                                                              ); // for SOR_LCP
 
           size_t sub3_res2 = 0;
 #ifdef CHECK_VELOCITY_OBEYS_CONSTRAINT
Index: ode/src/util.h
===================================================================
--- ode/src/util.h	(revision 1730)
+++ ode/src/util.h	(working copy)
@@ -23,6 +23,7 @@
 #ifndef _ODE_UTIL_H_
 #define _ODE_UTIL_H_
 
+#define SIZE_MAX ((size_t)(-1))
 #include "objects.h"
 
 
@@ -187,8 +188,8 @@
 
   void CleanupContext();
 
-  void SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints);
-  void RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints);
+  void SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints, size_t const *islandreqs);
+  void RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints, size_t const *&islandreqs);
   void OffsetPreallocations(size_t stOffset);
   void CopyPreallocations(const dxWorldProcessContext *othercontext);
   void ClearPreallocations();
@@ -204,6 +205,7 @@
 
   int m_IslandCount;
   int const *m_pIslandSizes;
+  size_t const *m_pIslandReqs;
   dxBody *const *m_pBodies;
   dxJoint *const *m_pJoints;
 
@@ -216,7 +218,7 @@
 #define BEGIN_STATE_SAVE(context, state) void *state = context->SaveState();
 #define END_STATE_SAVE(context, state) context->RestoreState(state)
 
-typedef void (*dstepper_fn_t) (dxWorldProcessContext *context, 
+typedef void (*dstepper_fn_t) (dxWorldProcessContext *context,dxWorldProcessContext *island_context, 
         dxWorld *world, dxBody * const *body, int nb,
         dxJoint * const *_joint, int _nj, dReal stepsize);
 
Index: ode/src/misc.cpp
===================================================================
--- ode/src/misc.cpp	(revision 1730)
+++ ode/src/misc.cpp	(working copy)
@@ -109,7 +109,17 @@
   }
 }
 
+void dPrintIntMatrix (const int *A, int n, int m, char *fmt, FILE *f)
+{
+  int skip = 1;
+  const int *Arow = A;
+  for (int i=0; i<n; Arow+=skip, ++i) {
+    for (int j=0; j<m; ++j) fprintf (f,fmt,Arow[j]);
+    fprintf (f,"\n");
+  }
+}
 
+
 void dMakeRandomVector (dReal *A, int n, dReal range)
 {
   int i;
Index: ode/src/quickstep.h
===================================================================
--- ode/src/quickstep.h	(revision 1730)
+++ ode/src/quickstep.h	(working copy)
@@ -28,7 +28,7 @@
 size_t dxEstimateQuickStepMemoryRequirements (
   dxBody * const *body, int nb, dxJoint * const *_joint, int _nj);
 
-void dxQuickStepper (dxWorldProcessContext *context,
+void dxQuickStepper (dxWorldProcessContext *shared_context,dxWorldProcessContext *context,
         dxWorld *world, dxBody * const *body, int nb,
 		    dxJoint * const *_joint, int _nj, dReal stepsize);
 
Index: ode/src/util.cpp
===================================================================
--- ode/src/util.cpp	(revision 1730)
+++ ode/src/util.cpp	(working copy)
@@ -25,7 +25,18 @@
 #include "objects.h"
 #include "joints/joint.h"
 #include "util.h"
+#include <boost/thread/recursive_mutex.hpp>
+#include <boost/bind.hpp>
+#include <ode/timer.h>
 
+#undef REPORT_THREAD_TIMING
+//#define TIMING
+#ifdef TIMING
+#define IFTIMING(x) x
+#else
+#define IFTIMING(x) ((void)0)
+#endif
+
 static void InternalFreeWorldProcessContext (dxWorldProcessContext *context);
 
 //****************************************************************************
@@ -45,17 +56,19 @@
   FreePreallocationsContext();
 }
 
-void dxWorldProcessContext::SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints)
+void dxWorldProcessContext::SavePreallocations(int islandcount, int const *islandsizes, dxBody *const *bodies, dxJoint *const *joints, size_t const *islandreqs)
 {
   m_IslandCount = islandcount;
+  m_pIslandReqs = islandreqs;
   m_pIslandSizes = islandsizes;
   m_pBodies = bodies;
   m_pJoints = joints;
 }
 
-void dxWorldProcessContext::RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints)
+void dxWorldProcessContext::RetrievePreallocations(int &islandcount, int const *&islandsizes, dxBody *const *&bodies, dxJoint *const *&joints, size_t const *&islandreqs)
 {
   islandcount = m_IslandCount;
+  islandreqs = m_pIslandReqs;
   islandsizes = m_pIslandSizes;
   bodies = m_pBodies;
   joints = m_pJoints;
@@ -65,6 +78,7 @@
 {
   // m_IslandCount = -- no offset for count
   m_pIslandSizes = m_pIslandSizes ? (int const *)((size_t)m_pIslandSizes + stOffset) : NULL;
+  m_pIslandReqs = m_pIslandReqs ? (size_t const *)((size_t)m_pIslandReqs + stOffset) : NULL;
   m_pBodies = m_pBodies ? (dxBody *const *)((size_t)m_pBodies + stOffset) : NULL;
   m_pJoints = m_pJoints ? (dxJoint *const *)((size_t)m_pJoints + stOffset) : NULL;
 }
@@ -73,6 +87,7 @@
 {
   m_IslandCount = othercontext->m_IslandCount;
   m_pIslandSizes = othercontext->m_pIslandSizes;
+  m_pIslandReqs = othercontext->m_pIslandReqs;
   m_pBodies = othercontext->m_pBodies;
   m_pJoints = othercontext->m_pJoints;
 }
@@ -81,6 +96,7 @@
 {
   m_IslandCount = 0;
   m_pIslandSizes = NULL;
+  m_pIslandReqs = NULL;
   m_pBodies = NULL;
   m_pJoints = NULL;
 }
@@ -371,6 +387,8 @@
 
   size_t islandcounts = dEFFICIENT_SIZE(world->nb * 2 * sizeof(int));
   res += islandcounts;
+  size_t islandreqs = dEFFICIENT_SIZE(world->nb * sizeof(size_t));
+  res += islandreqs;
 
   size_t bodiessize = dEFFICIENT_SIZE(world->nb * sizeof(dxBody*));
   size_t jointssize = dEFFICIENT_SIZE(world->nj * sizeof(dxJoint*));
@@ -380,6 +398,11 @@
   return res;
 }
 
+// sorts out islands,
+// cllocates array for island information into arrays: body[nj], joint[nb], islandsizes[2*nb]
+//   context->SavePreallocations(islandcount, islandsizes, body, joint,islandreqs);
+// and put into context
+//
 static size_t BuildIslandsAndEstimateStepperMemoryRequirements(dxWorldProcessContext *context, 
   dxWorld *world, dReal stepsize, dmemestimate_fn_t stepperestimate)
 {
@@ -393,33 +416,42 @@
   // Make array for island body/joint counts
   int *islandsizes = context->AllocateArray<int>(2 * nb);
   int *sizescurr;
+  size_t *islandreqs = context->AllocateArray<size_t>(nb);
+  size_t *islandreqscurr;
 
   // make arrays for body and joint lists (for a single island) to go into
-  dxBody **body = context->AllocateArray<dxBody *>(nb);
-  dxJoint **joint = context->AllocateArray<dxJoint *>(nj);
+  dxBody **body = context->AllocateArray<dxBody *>(nb);  // allocates a block of pointers and get back a pointer to first element
+  dxJoint **joint = context->AllocateArray<dxJoint *>(nj);  // allocates a block of pointers and get back a pointer to first element
 
   BEGIN_STATE_SAVE(context, stackstate) {
-    // allocate a stack of unvisited bodies in the island. the maximum size of
+    // stack is used to hold untagged bodies when traversing through all the joint-linked bodies.
+    // at the end, all the bodies in the stack are popped back out into the island.
+    //
+    // allocate a stack of UNVISITED BODIES in the island. the maximum size of
     // the stack can be the lesser of the number of bodies or joints, because
     // new bodies are only ever added to the stack by going through untagged
     // joints. all the bodies in the stack must be tagged!
     int stackalloc = (nj < nb) ? nj : nb;
-    dxBody **stack = context->AllocateArray<dxBody *>(stackalloc);
+    dxBody **stack = context->AllocateArray<dxBody *>(stackalloc);  // a body stack
 
     {
-      // set all body/joint tags to 0
-      for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) b->tag = 0;
-      for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) j->tag = 0;
+      // set all body/joint island_tags to 0
+      for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) b->island_tag = 0;
+      for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) j->island_tag = 0;
     }
 
+    int island_count = 0;
     sizescurr = islandsizes;
+    islandreqscurr = islandreqs;
     dxBody **bodystart = body;
     dxJoint **jointstart = joint;
+    // loop through all body, tag each one as it is processed
+    // every step in this for loop is one island
     for (dxBody *bb=world->firstbody; bb; bb=(dxBody*)bb->next) {
       // get bb = the next enabled, untagged body, and tag it
-      if (!bb->tag) {
+      if (!bb->island_tag) {
         if (!(bb->flags & dxBodyDisabled)) {
-          bb->tag = 1;
+          bb->island_tag = 1;
 
           dxBody **bodycurr = bodystart;
           dxJoint **jointcurr = jointstart;
@@ -431,19 +463,19 @@
           dxBody *b = bb;
 
           while (true) {
-            // traverse and tag all body's joints, add untagged connected bodies
+            // traverse and island_tag all body's joints, add untagged connected bodies
             // to stack
             for (dxJointNode *n=b->firstjoint; n; n=n->next) {
               dxJoint *njoint = n->joint;
-              if (!njoint->tag) {
+              if (!njoint->island_tag) {
                 if (njoint->isEnabled()) {
-                  njoint->tag = 1;
+                  njoint->island_tag = 1;
                   *jointcurr++ = njoint;
 
                   dxBody *nbody = n->body;
                   // Body disabled flag is not checked here. This is how auto-enable works.
-                  if (nbody && nbody->tag <= 0) {
-                    nbody->tag = 1;
+                  if (nbody && nbody->island_tag <= 0) {
+                    nbody->island_tag = 1;
                     // Make sure all bodies are in the enabled state.
                     nbody->flags &= ~dxBodyDisabled;
                     stack[stacksize++] = nbody;
@@ -470,17 +502,19 @@
           sizescurr[1] = jcount;
           sizescurr += sizeelements;
 
-          size_t islandreq = stepperestimate(bodystart, bcount, jointstart, jcount);
-          maxreq = (maxreq > islandreq) ? maxreq : islandreq;
+          *islandreqscurr = stepperestimate(bodystart, bcount, jointstart, jcount);
+          maxreq = (maxreq > *islandreqscurr) ? maxreq : *islandreqscurr;
+          //printf("island %d complete, stepper  %d maxreq %d \n",island_count++,*islandreqscurr, maxreq);
+          islandreqscurr += 1;
 
           bodystart = bodycurr;
           jointstart = jointcurr;
         } else {
-          bb->tag = -1; // Not used so far (assigned to retain consistency with joints)
+          bb->island_tag = -1; // Not used so far (assigned to retain consistency with joints)
         }
       }
     }
-  } END_STATE_SAVE(context, stackstate);
+  } END_STATE_SAVE(context, stackstate);  // restores contex pointer m_pAllocCurrent back to what it was before this block
 
 # ifndef dNODEBUG
   // if debugging, check that all objects (except for disabled bodies,
@@ -489,10 +523,10 @@
   {
     for (dxBody *b=world->firstbody; b; b=(dxBody*)b->next) {
       if (b->flags & dxBodyDisabled) {
-        if (b->tag > 0) dDebug (0,"disabled body tagged");
+        if (b->island_tag > 0) dDebug (0,"disabled body tagged");
       }
       else {
-        if (b->tag <= 0) dDebug (0,"enabled body not tagged");
+        if (b->island_tag <= 0) dDebug (0,"enabled body not tagged");
       }
     }
     for (dxJoint *j=world->firstjoint; j; j=(dxJoint*)j->next) {
@@ -500,18 +534,24 @@
         (j->node[1].body && (j->node[1].body->flags & dxBodyDisabled)==0) )
         && 
         j->isEnabled() ) {
-          if (j->tag <= 0) dDebug (0,"attached enabled joint not tagged");
+          if (j->island_tag <= 0) dDebug (0,"attached enabled joint not tagged");
       }
       else {
-        if (j->tag > 0) dDebug (0,"unattached or disabled joint tagged");
+        if (j->island_tag > 0) dDebug (0,"unattached or disabled joint tagged");
       }
     }
   }
 # endif
 
   int islandcount = (sizescurr - islandsizes) / sizeelements;
-  context->SavePreallocations(islandcount, islandsizes, body, joint);
+  context->SavePreallocations(islandcount, islandsizes, body, joint,islandreqs);
 
+  //printf("total island count: %d\n",islandcount);
+  for (int j=0; j<islandcount; j++)
+  {
+    //printf("island:%d bodycount:%d jointcount:%d islandreqs:%d \n",j,islandsizes[2*j],islandsizes[2*j+1],islandreqs[j]);
+  }
+
   return maxreq;
 }
 
@@ -526,6 +566,39 @@
 // bodies will not be included in the simulation. disabled bodies are
 // re-enabled if they are found to be part of an active island.
 
+void dxProcessOneIsland(dxWorldProcessContext *context,dxWorldProcessContext *island_context, dxWorld *world, dReal stepsize, dstepper_fn_t stepper,
+                        dxBody *const* bodystart,
+                        int bcount,
+                        dxJoint *const *jointstart,
+                        int jcount)
+{
+
+
+    struct timeval tv;
+    double cur_time;
+    gettimeofday(&tv,NULL);
+    cur_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+    //printf("island thread started time %f\n",cur_time);
+
+
+
+
+    //dAllocateODEDataForThread(dAllocateMaskAll);
+
+    BEGIN_STATE_SAVE(island_context, island_stepperstate) {
+      stepper (context,island_context,world,bodystart,bcount,jointstart,jcount,stepsize);
+    } END_STATE_SAVE(island_context, island_stepperstate);
+    //dCleanupODEAllDataForThread();
+
+    gettimeofday(&tv,NULL);
+    double end_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+    #ifdef REPORT_THREAD_TIMING
+      printf("----- island thread start time %f ended at time %f with duration %f\n",cur_time,end_time,end_time - cur_time);
+    #endif
+
+
+}
+
 void dxProcessIslands (dxWorld *world, dReal stepsize, dstepper_fn_t stepper)
 {
   const int sizeelements = 2;
@@ -536,28 +609,81 @@
   dxWorldProcessContext *context = wmem->GetWorldProcessingContext(); 
 
   int islandcount;
+  size_t const *islandreqs;
   int const *islandsizes;
   dxBody *const *body;
   dxJoint *const *joint;
-  context->RetrievePreallocations(islandcount, islandsizes, body, joint);
+  context->RetrievePreallocations(islandcount, islandsizes, body, joint, islandreqs);
 
   dxBody *const *bodystart = body;
   dxJoint *const *jointstart = joint;
 
+  IFTIMING(dTimerStart("preprocessing islands"));
+
+  int island_index = 0;
   int const *const sizesend = islandsizes + islandcount * sizeelements;
+
+
+
+  struct timeval tv;
+  double cur_time;
+  gettimeofday(&tv,NULL);
+  cur_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  #ifdef REPORT_THREAD_TIMING
+    printf(">>>>>>>>>>>> start island spawn threads at time %f\n",cur_time);
+  #endif
+
+
+
   for (int const *sizescurr = islandsizes; sizescurr != sizesend; sizescurr += sizeelements) {
     int bcount = sizescurr[0];
     int jcount = sizescurr[1];
 
-    BEGIN_STATE_SAVE(context, stepperstate) {
-      // now do something with body and joint lists
-      stepper (context,world,bodystart,bcount,jointstart,jcount,stepsize);
-    } END_STATE_SAVE(context, stepperstate);
+    //printf("debug: islandcount %d bcount %d jcount %d \n", islandcount,bcount, jcount);
 
+    dxStepWorkingMemory *island_wmem = world->island_wmems[island_index];
+    island_index++;
+    dIASSERT(island_wmem != NULL);
+    dxWorldProcessContext *island_context = island_wmem->GetWorldProcessingContext();
+
+#define USE_TPISLAND
+
+#ifdef USE_TPISLAND
+    IFTIMING(dTimerNow("scheduling island"));
+    if (world->threadpool->size() > 1)
+      world->threadpool->schedule(boost::bind(dxProcessOneIsland,context,island_context, world, stepsize, stepper,bodystart, bcount, jointstart, jcount));
+    else //automatically skip threadpool if only 1 thread allocated
+      dxProcessOneIsland(context,island_context, world, stepsize, stepper,bodystart, bcount, jointstart, jcount);
+#else
+    dxProcessOneIsland(context,island_context, world, stepsize, stepper,bodystart, bcount, jointstart, jcount);
+#endif
+
     bodystart += bcount;
     jointstart += jcount;
   }
+#ifdef USE_TPISLAND
+  IFTIMING(dTimerNow("islands wait"));
+  if (world->threadpool->size() > 1)
+    world->threadpool->wait();
+#endif
+  IFTIMING(dTimerEnd());
+  IFTIMING(dTimerReport (stdout,1));
 
+
+
+
+  gettimeofday(&tv,NULL);
+  double end_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
+  #ifdef REPORT_THREAD_TIMING
+    printf("<<<<<<<<<<<< all island threads stopped at time %f with duration %f\n",end_time,end_time - cur_time);
+  #endif
+
+
+
+
+  for (int jj=0; jj < islandcount; jj++)
+    world->island_wmems[jj]->GetWorldProcessingContext()->CleanupContext();
+
   context->CleanupContext();
   dIASSERT(context->IsStructureValid());
 }
@@ -713,7 +839,7 @@
 bool dxReallocateWorldProcessContext (dxWorld *world, 
   dReal stepsize, dmemestimate_fn_t stepperestimate)
 {
-  dxStepWorkingMemory *wmem = AllocateOnDemand(world->wmem);
+  dxStepWorkingMemory *wmem = AllocateOnDemand(world->wmem);  // this is starting a new instance of dxStepWorkingMemory
   if (!wmem) return false;
 
   dxWorldProcessContext *oldcontext = wmem->GetWorldProcessingContext();
@@ -724,6 +850,10 @@
 
   dxWorldProcessContext *context = oldcontext;
 
+  // EstimateIslandsProcessingMemoryRequirements allocates memeory for 3 arrays:
+  //    islandsizes: integer arrays, 2*n_islands in size, contains bodycount and jointcount for each island
+  //    body: one array with all the 'active' bodies, all indexed by islandsizes
+  //    joint: one array with all the 'active' joints, all indexed by islandsizes
   size_t sesize;
   size_t islandsreq = EstimateIslandsProcessingMemoryRequirements(world, sesize);
   dIASSERT(islandsreq == dEFFICIENT_SIZE(islandsreq));
@@ -732,16 +862,45 @@
   size_t stepperestimatereq = islandsreq + sesize;
   context = InternalReallocateWorldProcessContext(context, stepperestimatereq, memmgr, 1.0f, reserveinfo->m_uiReserveMinimum);
   
+  //
+  // above context allocation of the island arrays is successful, then we proceed to allocate more spaces for the actual stepping work
+  //
+  // we want to start multiple contexts, one for each island.
+  //
   if (context)
   {
     size_t stepperreq = BuildIslandsAndEstimateStepperMemoryRequirements(context, world, stepsize, stepperestimate);
     dIASSERT(stepperreq == dEFFICIENT_SIZE(stepperreq));
 
-    size_t memreq = stepperreq + islandsreq;
-    context = InternalReallocateWorldProcessContext(context, memreq, memmgr, reserveinfo->m_fReserveFactor, reserveinfo->m_uiReserveMinimum);
+    // retrieve results of BuildIslandsAndEstimateStepperMemoryRequirements
+    int islandcount;
+    size_t const *islandreqs;
+    int const *islandsizes;
+    dxBody *const *body;
+    dxJoint *const *joint;
+    context->RetrievePreallocations(islandcount, islandsizes, body, joint, islandreqs);
+
+    for (int jj = 0; jj < islandcount; jj++)
+    {
+      // for individual islands
+      dxStepWorkingMemory *island_wmem = AllocateOnDemand(world->island_wmems[jj]);  // this is starting a new instance of dxStepWorkingMemory
+      if (!island_wmem) return false;
+
+      dxWorldProcessContext *island_oldcontext = island_wmem->GetWorldProcessingContext();
+      dIASSERT (!island_oldcontext || island_oldcontext->IsStructureValid());
+
+      const dxWorldProcessMemoryReserveInfo *island_reserveinfo = island_wmem->SureGetMemoryReserveInfo();
+      const dxWorldProcessMemoryManager *island_memmgr = island_wmem->SureGetMemoryManager();
+
+      dxWorldProcessContext *island_context = island_oldcontext;
+
+      size_t island_memreq = islandreqs[jj]; //  + islandsreq;
+      island_context = InternalReallocateWorldProcessContext(island_context, island_memreq, island_memmgr, island_reserveinfo->m_fReserveFactor, island_reserveinfo->m_uiReserveMinimum);
+      island_wmem->SetWorldProcessingContext(island_context); // set dxStepWorkingMemory to context
+    }
   }
 
-  wmem->SetWorldProcessingContext(context);
+  wmem->SetWorldProcessingContext(context); // set dxStepWorkingMemory to context
   return context != NULL;
 }
 
Index: ode/src/joints/slider.cpp
===================================================================
--- ode/src/joints/slider.cpp	(revision 1730)
+++ ode/src/joints/slider.cpp	(working copy)
@@ -142,6 +142,10 @@
             info->m = 6;
         }
     }
+
+    // joint damping
+    if ( use_damping )
+      info->m = 6;
 }
 
 
@@ -224,6 +228,22 @@
 
     // if the slider is powered, or has joint limits, add in the extra row
     limot.addLimot ( this, info, 5, ax1, 0 );
+
+    // joint damping
+    if (this->use_damping)
+    {
+      // added J1ld and J2ld for damping, only 1 row
+      info->J1ld[0] = ax1[0];
+      info->J1ld[1] = ax1[1];
+      info->J1ld[2] = ax1[2];
+      if ( this->node[1].body )
+      {
+        info->J2ld[0] = -ax1[0];
+        info->J2ld[1] = -ax1[1];
+        info->J2ld[2] = -ax1[2];
+      }
+      // there's no rhs for damping setup, all we want to use is the jacobian information above
+    }
 }
 
 
Index: ode/src/joints/joint.h
===================================================================
--- ode/src/joints/joint.h	(revision 1730)
+++ ode/src/joints/joint.h	(working copy)
@@ -94,6 +94,10 @@
         // J2xx pointers may be 0.
         dReal *J1l, *J1a, *J2l, *J2a;
 
+        // jacobians for joint damping
+        // angular ones are implemented first
+        dReal *J1ld, *J1ad, *J2ld, *J2ad;
+
         // elements to jump from one row to the next in J's
         int rowskip;
 
@@ -155,6 +159,12 @@
 	// Test if this joint should be used in the simulation step
 	// (has the enabled flag set, and is attached to at least one dynamic body)
 	bool isEnabled() const;
+
+    // to use joint damping set use_damping to true
+    // and set damping_coefficient to the desired value
+    bool use_damping;
+    dReal damping_coefficient;
+
 };
 
 
Index: ode/src/joints/hinge.h
===================================================================
--- ode/src/joints/hinge.h	(revision 1730)
+++ ode/src/joints/hinge.h	(working copy)
@@ -36,6 +36,7 @@
     dVector3 axis2;     // axis w.r.t second body
     dQuaternion qrel;   // initial relative rotation body1 -> body2
     dxJointLimitMotor limot; // limit and motor information
+    dReal cumulative_angle; // save a cumulative angle so we can use larger then +/-pi limits
 
     dxJointHinge( dxWorld *w );
     virtual void getSureMaxInfo( SureMaxInfo* info );
Index: ode/src/joints/joint.cpp
===================================================================
--- ode/src/joints/joint.cpp	(revision 1730)
+++ ode/src/joints/joint.cpp	(working copy)
@@ -57,6 +57,10 @@
 
     w->nj++;
     feedback = 0;
+
+    // joint damping
+    use_damping = false;
+    damping_coefficient = 0.0;
 }
 
 dxJoint::~dxJoint()
Index: ode/src/joints/hinge.cpp
===================================================================
--- ode/src/joints/hinge.cpp	(revision 1730)
+++ ode/src/joints/hinge.cpp	(working copy)
@@ -25,7 +25,63 @@
 #include "hinge.h"
 #include "joint_internal.h"
 
+//****************************************************************************
+// helper function: shortest_angular_distance implementation
+    
+  /*!
+   * \brief normalize_angle_positive
+   *
+   *        Normalizes the angle to be 0 to 2*M_PI
+   *        It takes and returns radians.
+   */
+  static inline double normalize_angle_positive(double angle)
+  {
+    return fmod(fmod(angle, 2.0*M_PI) + 2.0*M_PI, 2.0*M_PI);
+  }
 
+
+  /*!
+   * \brief normalize
+   *
+   * Normalizes the angle to be -M_PI circle to +M_PI circle
+   * It takes and returns radians.
+   *
+   */    
+  static inline double normalize_angle(double angle)
+  {
+    double a = normalize_angle_positive(angle);
+    if (a > M_PI)
+      a -= 2.0 *M_PI;
+    return a;
+  }
+
+    
+  /*!
+   * \function
+   * \brief shortest_angular_distance
+   *
+   * Given 2 angles, this returns the shortest angular
+   * difference.  The inputs and ouputs are of course radians.
+   *
+   * The result
+   * would always be -pi <= result <= pi.  Adding the result
+   * to "from" will always get you an equivelent angle to "to".
+   */
+    
+  static inline double shortest_angular_distance(double from, double to)
+  {
+    double result = normalize_angle_positive(normalize_angle_positive(to) - normalize_angle_positive(from));
+	
+    if (result > M_PI)
+      // If the result > 180,
+      // It's shorter the other way.
+      result = -(2.0*M_PI - result);
+	
+    return normalize_angle(result);
+  }
+
+
+
 //****************************************************************************
 // hinge
 
@@ -40,6 +96,7 @@
     axis2[0] = 1;
     dSetZero( qrel, 4 );
     limot.init( world );
+    cumulative_angle = 0;
 }
 
 
@@ -60,16 +117,22 @@
         info->m = 6; // powered hinge needs an extra constraint row
     else info->m = 5;
 
+    // if proper joint limits are specified
     // see if we're at a joint limit.
-    if (( limot.lostop >= -M_PI || limot.histop <= M_PI ) &&
-            limot.lostop <= limot.histop )
+    if ( limot.lostop <= limot.histop )
     {
         dReal angle = getHingeAngle( node[0].body,
                                      node[1].body,
                                      axis1, qrel );
-        if ( limot.testRotationalLimit( angle ) )
+        // from angle, update cumulative_angle, which does not wrap
+        cumulative_angle = cumulative_angle + shortest_angular_distance(cumulative_angle,angle);
+
+        if ( limot.testRotationalLimit( cumulative_angle ) )
             info->m = 6;
     }
+    // joint damping
+    if ( use_damping )
+      info->m = 6;
 }
 
 
@@ -146,6 +209,22 @@
 
     // if the hinge is powered, or has joint limits, add in the stuff
     limot.addLimot( this, info, 5, ax1, 1 );
+
+    // joint damping
+    if (this->use_damping)
+    {
+      // added J1ad and J2ad for damping, only 1 row
+      info->J1ad[0] = ax1[0];
+      info->J1ad[1] = ax1[1];
+      info->J1ad[2] = ax1[2];
+      if ( this->node[1].body )
+      {
+        info->J2ad[0] = -ax1[0];
+        info->J2ad[1] = -ax1[1];
+        info->J2ad[2] = -ax1[2];
+      }
+      // there's no rhs for damping setup, all we want to use is the jacobian information above
+    }
 }
 
 
@@ -296,10 +375,12 @@
                                    joint->node[1].body,
                                    joint->axis1,
                                    joint->qrel );
+        // from angle, update cumulative_angle, which does not wrap
+        joint->cumulative_angle = joint->cumulative_angle + shortest_angular_distance(joint->cumulative_angle,ang);
         if ( joint->flags & dJOINT_REVERSE )
-            return -ang;
+            return -joint->cumulative_angle;
         else
-            return ang;
+            return joint->cumulative_angle;
     }
     else return 0;
 }
Index: ode/src/step.h
===================================================================
--- ode/src/step.h	(revision 1730)
+++ ode/src/step.h	(working copy)
@@ -28,7 +28,7 @@
 size_t dxEstimateStepMemoryRequirements (
   dxBody * const *body, int nb, dxJoint * const *_joint, int _nj);
 
-void dInternalStepIsland (dxWorldProcessContext *context, dxWorld *world,
+void dInternalStepIsland (dxWorldProcessContext *shared_context,dxWorldProcessContext *context, dxWorld *world,
 			  dxBody * const *body, int nb,
 			  dxJoint * const *joint, int nj,
 			  dReal stepsize);
Index: ode/src/objects.h
===================================================================
--- ode/src/objects.h	(revision 1730)
+++ ode/src/objects.h	(working copy)
@@ -30,6 +30,7 @@
 #include <ode/memory.h>
 #include <ode/mass.h>
 #include "array.h"
+#include <boost/threadpool.hpp>
 
 class dxStepWorkingMemory;
 
@@ -66,6 +67,7 @@
   dObject *next;		// next object of this type in list
   dObject **tome;		// pointer to previous object's next ptr
   int tag;			// used by dynamics algorithms
+  int island_tag;		// used by island algorithms for grouping
   void *userdata;		// user settable data
   dObject(dxWorld *w);
   virtual ~dObject() { }
@@ -95,6 +97,9 @@
 struct dxQuickStepParameters {
   int num_iterations;		// number of SOR iterations to perform
   dReal w;			// the SOR over-relaxation parameter
+  int num_chunks;		// divide rows to these many chunks
+  int num_overlap;		// divide rows but over lap this many rows
+  dReal sor_lcp_tolerance;	// the stop if rms_error falls below this
 };
 
 
@@ -151,11 +156,14 @@
   dxAutoDisable adis;		// auto-disable parameters
   int body_flags;               // flags for new bodies
   dxStepWorkingMemory *wmem; // Working memory object for dWorldStep/dWorldQuickStep
+  dxStepWorkingMemory *island_wmems[1000]; // Working memory object for dWorldStep/dWorldQuickStep
 
   dxQuickStepParameters qs;
   dxContactParameters contactp;
   dxDampingParameters dampingp; // damping parameters
   dReal max_angular_speed;      // limit the angular velocity to this magnitude
+  boost::threadpool::pool *threadpool;
+  boost::threadpool::pool *row_threadpool;
 };
 
 
Index: ode/src/collision_kernel.h
===================================================================
--- ode/src/collision_kernel.h	(revision 1730)
+++ ode/src/collision_kernel.h	(working copy)
@@ -34,6 +34,7 @@
 #include <ode/collision.h>
 #include "objects.h"
 #include "odetls.h"
+#include <boost/thread/mutex.hpp>
 
 //****************************************************************************
 // constants and macros
@@ -204,6 +205,8 @@
   int sublevel;         // space sublevel (used in dSpaceCollide2). NOT TRACKED AUTOMATICALLY!!!
   unsigned tls_kind;	// space TLS kind to be used for global caches retrieval
 
+  boost::mutex mutex;
+
   // cached state for getGeom()
   int current_index;		// only valid if current_geom != 0
   dxGeom *current_geom;		// if 0 then there is no information
Index: ode/src/ode.cpp
===================================================================
--- ode/src/ode.cpp	(revision 1730)
+++ ode/src/ode.cpp	(working copy)
@@ -1454,7 +1454,20 @@
   joint->feedback = f;
 }
 
+void dJointSetDamping (dxJoint *joint, dReal damping)
+{
+  dAASSERT (joint);
 
+  if (damping > 0.0)
+  {
+    // set use_damping to true
+    joint->use_damping = true;
+    // damping coefficient is in jicurr->info.damping_coefficient);
+    joint->damping_coefficient = damping;
+    // FIXME: only hinge joint and slider are implemented at this time
+  }
+}
+
 dJointFeedback *dJointGetFeedback (dxJoint *joint)
 {
   dAASSERT (joint);
@@ -1559,6 +1572,10 @@
   w->body_flags = 0; // everything disabled
 
   w->wmem = 0;
+  for (int jj=0; jj < 1000; jj++)
+  {
+    w->island_wmems[jj] = 0;
+  }
 
   w->adis.idle_steps = 10;
   w->adis.idle_time = 0;
@@ -1568,6 +1585,9 @@
 
   w->qs.num_iterations = 20;
   w->qs.w = REAL(1.3);
+  w->qs.num_chunks = 1;
+  w->qs.num_overlap = 0;
+  w->qs.sor_lcp_tolerance = 0;
 
   w->contactp.max_vel = dInfinity;
   w->contactp.min_depth = 0;
@@ -1578,6 +1598,9 @@
   w->dampingp.angular_threshold = REAL(0.01) * REAL(0.01);  
   w->max_angular_speed = dInfinity;
 
+  w->threadpool = new boost::threadpool::pool(4);
+  w->row_threadpool = new boost::threadpool::pool(1);
+
   return w;
 }
 
@@ -1617,6 +1640,8 @@
     w->wmem->Release();
   }
 
+  delete w->threadpool;
+
   delete w;
 }
 
@@ -1629,7 +1654,30 @@
   w->gravity[2] = z;
 }
 
+void dWorldSetIslandThreads (dWorldID w, int num_island_threads)
+{
+  dAASSERT (w);
+  if (w->threadpool)
+  {
+    w->threadpool->wait();
+    delete w->threadpool;
+  }
+  w->threadpool = new boost::threadpool::pool(num_island_threads);
+  printf("setting island pool threads to %d\n",num_island_threads);
+}
 
+void dWorldSetQuickstepThreads (dWorldID w, int num_quickstep_threads)
+{
+  dAASSERT (w);
+  if (w->row_threadpool)
+  {
+    w->row_threadpool->wait();
+    delete w->row_threadpool;
+  }
+  w->row_threadpool = new boost::threadpool::pool(num_quickstep_threads);
+  printf("setting quickstep pool threads to %d\n",num_quickstep_threads);
+}
+
 void dWorldGetGravity (dWorldID w, dVector3 g)
 {
   dAASSERT (w);
@@ -2002,7 +2050,24 @@
         w->max_angular_speed = max_speed;
 }
 
+void dWorldSetQuickStepTolerance (dWorldID w, dReal tol)
+{
+	dAASSERT(w);
+	w->qs.sor_lcp_tolerance = tol;
+}
 
+void dWorldSetQuickStepNumChunks (dWorldID w, int num)
+{
+	dAASSERT(w);
+	w->qs.num_chunks = num;
+}
+
+void dWorldSetQuickStepNumOverlap (dWorldID w, int num)
+{
+	dAASSERT(w);
+	w->qs.num_overlap = num;
+}
+
 void dWorldSetQuickStepNumIterations (dWorldID w, int num)
 {
 	dAASSERT(w);
Index: ode/src/step.cpp
===================================================================
--- ode/src/step.cpp	(revision 1730)
+++ ode/src/step.cpp	(working copy)
@@ -31,10 +31,13 @@
 #include "joints/joint.h"
 #include "lcp.h"
 #include "util.h"
+#include "joints/hinge.h"
 
 //****************************************************************************
 // misc defines
 
+#define USE_JOINT_DAMPING
+
 //#define TIMING
 
 
@@ -425,6 +428,24 @@
     m = mcurr;
   }
 
+
+#ifdef USE_JOINT_DAMPING
+  /************************************************************************/
+  /* for joint damping, get the total number of rows for damping jacobian */
+  /************************************************************************/
+  int m_damp; // number of rows for damped joint jacobian
+  {
+    int mcurr = 0;
+    const dJointWithInfo1 *jicurr = jointiinfos; // info1 stored in jointiinfos
+    const dJointWithInfo1 *const jiend = jicurr + nj;
+    for (; jicurr != jiend; jicurr++)
+      if (jicurr->joint->use_damping)
+        mcurr ++;
+
+    m_damp = mcurr;
+  }
+#endif
+
   // this will be set to the force due to the constraints
   dReal *cforce = context->AllocateArray<dReal> (nb*8);
   dSetZero (cforce,nb*8);
@@ -460,6 +481,23 @@
       dSetZero (rhs,mlocal);
     }
 
+#ifdef USE_JOINT_DAMPING
+    dReal *J_damp = NULL;
+    dReal *coeff_damp = NULL;
+    {
+      int mlocal = m_damp;
+
+      const unsigned jelements = mlocal*12;
+      J_damp = context->AllocateArray<dReal> (jelements);
+      dSetZero (J_damp,jelements);
+
+      const unsigned coeffelements = mlocal;
+      coeff_damp = context->AllocateArray<dReal> (coeffelements);
+      dSetZero (coeff_damp,coeffelements);
+    }
+#endif
+
+
     // Put 'c' in the same memory as 'rhs' as they transit into each other
     dReal *c = rhs; rhs = NULL; // erase rhs pointer for now as it is not to be used yet
 
@@ -496,6 +534,9 @@
         Jinfo.erp = world->global_erp;
 
         unsigned ofsi = 0;
+#ifdef USE_JOINT_DAMPING
+        unsigned ofsi_damp = 0;
+#endif
         const dJointWithInfo1 *jicurr = jointiinfos;
         const dJointWithInfo1 *const jiend = jicurr + nj;
         for (; jicurr != jiend; ++jicurr) {
@@ -511,7 +552,27 @@
           Jinfo.lo = lo + ofsi;
           Jinfo.hi = hi + ofsi;
           Jinfo.findex = findex + ofsi;
-          
+
+#ifdef USE_JOINT_DAMPING
+          /*******************************************************/
+          /*  allocate space for damped joint Jacobians          */
+          /*******************************************************/
+          if (jicurr->joint->use_damping)
+          {
+            // damping coefficient is in jicurr->info.damping_coefficient);
+            coeff_damp[ofsi_damp] = jicurr->joint->damping_coefficient;
+
+            // setup joint damping pointers so getinfo2 will fill in J_damp
+            dReal *const Jrow_damp = J_damp + ofsi_damp * 12;
+            Jinfo.J1ld = Jrow_damp;
+            Jinfo.J1ad = Jrow_damp + 3;
+            Jinfo.J2ld = Jrow_damp + 6;
+            Jinfo.J2ad = Jrow_damp + 9;
+            // one row of constraint per joint
+            ofsi_damp ++;
+          }
+#endif
+ 
           dxJoint *joint = jicurr->joint;
           joint->getInfo2 (&Jinfo);
           
@@ -838,8 +899,7 @@
 }
 
 //****************************************************************************
-
-void dInternalStepIsland (dxWorldProcessContext *context, 
+void dInternalStepIsland (dxWorldProcessContext *shared_context, dxWorldProcessContext *context, 
                           dxWorld *world, dxBody * const *body, int nb,
                           dxJoint * const *joint, int nj, dReal stepsize)
 {
@@ -868,6 +928,24 @@
     nj = njcurr; m = mcurr;
   }
 
+#ifdef USE_JOINT_DAMPING
+  int m_damp;
+  {
+    int m_dampcurr = 0;
+    dxJoint::SureMaxInfo info;
+    dxJoint *const *const _jend = _joint + _nj;
+    for (dxJoint *const *_jcurr = _joint; _jcurr != _jend; _jcurr++) {
+      dxJoint *j = *_jcurr;
+      /***************************/
+      /* size for damping joints */
+      /***************************/
+      if (j->use_damping)
+        m_dampcurr ++;
+    }
+    m_damp = m_dampcurr;
+  }
+#endif
+
   size_t res = 0;
 
   res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for invI
@@ -884,6 +962,10 @@
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * mskip * m); // for A
       sub1_res2 += 3 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for lo, hi, rhs
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * m); // for findex
+#ifdef USE_JOINT_DAMPING
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m_damp); // for J_damp
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m_damp); // for coeff_damp
+#endif
       {
         size_t sub2_res1 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm
         sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 2 * 8 * m); // for JinvM
