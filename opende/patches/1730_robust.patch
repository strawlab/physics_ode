Index: include/ode/objects.h
===================================================================
--- include/ode/objects.h	(revision 1730)
+++ include/ode/objects.h	(working copy)
@@ -309,6 +309,16 @@
 ODE_API int dWorldStep (dWorldID w, dReal stepsize);
 
 /**
+ * @brief Step the world using the algorithm of Drumwright and Shell.
+ * This uses a "big matrix" method that takes time on the order of m^3.
+ * This is currently the most robust and accurate method.
+ * @ingroup world
+ * @param stepsize the number of seconds that the simulation has to advance.
+ * @returns 1 for success and 0 for failure
+ */
+ODE_API int dWorldRobustStep (dWorldID, dReal stepsize);
+
+/**
  * @brief Quick-step the world.
  *
  * This uses an iterative method that takes time on the order of m*N
@@ -372,8 +382,28 @@
  dReal ix, dReal iy, dReal iz, dVector3 force
  );
 
+/**
+ * @brief Set the maximum number of iterations that the RobustStep method 
+ *        performs per step.
+ * @ingroup world
+ * @remarks
+ * More iterations may give a more accurate solution, but may take
+ * longer to compute.
+ * @param num The default is 100 iterations.
+ */
+ODE_API void dWorldSetRobustStepMaxIterations (dWorldID, int num);
 
+
 /**
+ * @brief Get the maximum number of iterations that the RobustStep method 
+ *        performs per step.
+ * @ingroup world
+ * @return nr of iterations
+ */
+ODE_API int dWorldGetRobustStepMaxIterations (dWorldID);
+
+
+/**
  * @brief Set the number of iterations that the QuickStep method performs per
  *        step.
  * @ingroup world
Index: configure.in
===================================================================
--- configure.in	(revision 1730)
+++ configure.in	(working copy)
@@ -103,7 +103,11 @@
 dnl check for required headers
 AC_CHECK_HEADERS( [alloca.h stdio.h inttypes.h stdint.h stdlib.h math.h \
                   string.h stdarg.h malloc.h float.h time.h sys/time.h ])
+AC_LANG_PUSH([C++])
+AC_CHECK_HEADERS([limits], [], [AC_MSG_ERROR([C++ limits is required])])
+AC_LANG_POP()
 
+BOOST_FIND_HEADER([boost/shared_array.hpp])
 
 opcode=no
 gimpact=no
Index: boost.m4
===================================================================
--- boost.m4	(revision 0)
+++ boost.m4	(revision 0)
@@ -0,0 +1,734 @@
+# boost.m4: Locate Boost headers and libraries for autoconf-based projects.
+# Copyright (C) 2007  Benoit Sigoure <tsuna@lrde.epita.fr>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# serial 1
+# Original sources can be found at http://repo.or.cz/w/boost.m4.git
+# You can fetch the latest version of the script by doing:
+#   wget 'http://repo.or.cz/w/boost.m4.git?a=blob_plain;f=build-aux/boost.m4;hb=HEAD' -O boost.m4
+
+# ------ #
+# README #
+# ------ #
+
+# This file provides several macros to use the various Boost libraries.
+# The first macro is BOOST_REQUIRE.  It will simply check if it's possible to
+# find the Boost headers of a given (optional) minimum version and it will
+# define BOOST_CPPFLAGS accordingly.  It will add an option --with-boost to
+# your configure so that users can specify non standard locations.
+# For more README and documentation, go to http://repo.or.cz/w/boost.m4.git
+
+m4_pattern_forbid([^_?BOOST_])
+
+# BOOST_REQUIRE([VERSION])
+# ------------------------
+# Look for Boost.  If version is given, it must either be a literal of the form
+# "X.Y" where X and Y are integers or a variable "$var".
+# Defines the value BOOST_CPPFLAGS.  This macro only checks for headers with
+# the required version, it does not check for any of the Boost libraries.
+# FIXME: Add a 2nd optional argument so that it's not fatal if Boost isn't found
+# and add an AC_DEFINE to tell whether HAVE_BOOST.
+AC_DEFUN([BOOST_REQUIRE],
+[dnl First find out what kind of argument we have.
+dnl If we have an empty argument, there is no constraint on the version of
+dnl Boost to use.  If it's a literal version number, we can split it in M4 (so
+dnl the resulting configure script will be smaller/faster).  Otherwise we do
+dnl the splitting at runtime.
+m4_bmatch([$1],
+  [^ *$], [m4_pushdef([BOOST_VERSION_REQ], [])dnl
+           boost_version_major=0
+           boost_version_minor=0
+           boost_version_subminor=0
+],
+  [^[0-9]+\([-._][0-9]+\)*$],
+    [m4_pushdef([BOOST_VERSION_REQ], [ version >= $1])dnl
+     boost_version_major=m4_bregexp([$1], [^\([0-9]+\)], [\1])
+     boost_version_minor=m4_bregexp([$1], [^[0-9]+[-._]\([0-9]+\)], [\1])
+     boost_version_subminor=m4_bregexp([$1], [^[0-9]+[-._][0-9]+[-._]\([0-9]+\)], [\1])
+],
+  [^\$[a-zA-Z_]+$],
+    [m4_pushdef([BOOST_VERSION_REQ], [])dnl
+     boost_version_major=`expr "X$1" : 'X\([[^-._]]*\)'`
+     boost_version_minor=`expr "X$1" : 'X[[0-9]]*[[-._]]\([[^-._]]*\)'`
+     boost_version_subminor=`expr "X$1" : 'X[[0-9]]*[[-._]][[0-9]]*[[-._]]\([[0-9]]*\)'`
+     case $boost_version_major:$boost_version_minor in #(
+       *: | :* | *[[^0-9]]*:* | *:*[[^0-9]]*)
+         AC_MSG_ERROR([[Invalid argument for REQUIRE_BOOST: `$1']])
+         ;;
+     esac
+],
+  [m4_fatal(Invalid argument: `$1')]
+)dnl
+AC_ARG_WITH([boost],
+   [AS_HELP_STRING([--with-boost=DIR],
+                   [prefix of Boost]BOOST_VERSION_REQ[ @<:@guess@:>@])])dnl
+AC_SUBST([DISTCHECK_CONFIGURE_FLAGS],
+         ["$DISTCHECK_CONFIGURE_FLAGS '--with-boost=$with_boost'"])
+  AC_CACHE_CHECK([for Boost headers[]BOOST_VERSION_REQ],
+    [boost_cv_inc_path],
+    [boost_cv_inc_path=no
+AC_LANG_PUSH([C++])dnl
+    boost_subminor_chk=
+    test x"$boost_version_subminor" != x \
+      && boost_subminor_chk="|| (B_V_MAJ == $boost_version_major \
+&& B_V_MIN == $boost_version_minor \
+&& B_V_SUB < $boost_version_subminor)"
+    for boost_inc in "$with_boost/include" '' \
+             /opt/local/include /usr/local/include /opt/include /usr/include \
+             "$with_boost" C:/Boost/include
+    do
+      test -e "$boost_inc" || continue
+      # Ensure that version.hpp exists: we're going to read it.  Moreover,
+      # Boost could be reachable thanks to the default include path so we can
+      # mistakenly accept a wrong include path without this check.
+      test -e "$boost_inc/boost/version.hpp" || continue
+      boost_save_CPPFLAGS=$CPPFLAGS
+      test x"$boost_inc" != x && CPPFLAGS="$CPPFLAGS -I$boost_inc"
+m4_pattern_allow([^BOOST_VERSION$])dnl
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <boost/version.hpp>
+#ifndef BOOST_VERSION
+# error BOOST_VERSION is not defined
+#endif
+#define B_V_MAJ (BOOST_VERSION / 100000)
+#define B_V_MIN (BOOST_VERSION / 100 % 1000)
+#define B_V_SUB (BOOST_VERSION % 100)
+#if (B_V_MAJ < $boost_version_major) \
+   || (B_V_MAJ == $boost_version_major \
+       && B_V_MIN < $boost_version_minor) $boost_subminor_chk
+# error Boost headers version < $1
+#endif
+]])], [boost_cv_inc_path=yes], [boost_cv_version=no])
+      CPPFLAGS=$boost_save_CPPFLAGS
+      if test x"$boost_cv_inc_path" = xyes; then
+        if test x"$boost_inc" != x; then
+          boost_cv_inc_path=$boost_inc
+        fi
+        break
+      fi
+    done
+AC_LANG_POP([C++])dnl
+    ])
+    case $boost_cv_inc_path in #(
+      no)
+        AC_MSG_ERROR([Could not find Boost headers[]BOOST_VERSION_REQ])
+        ;;#(
+      yes)
+        BOOST_CPPFLAGS=
+        ;;#(
+      *)
+        BOOST_CPPFLAGS="-I$boost_cv_inc_path"
+        ;;
+    esac
+AC_SUBST([BOOST_CPPFLAGS])dnl
+  AC_CACHE_CHECK([for Boost's header version],
+    [boost_cv_lib_version],
+    [m4_pattern_allow([^BOOST_LIB_VERSION$])dnl
+    boost_cv_lib_version=unknown
+    boost_sed_version='/^.*BOOST_LIB_VERSION.*"\([[^"]]*\)".*$/!d;s//\1/'
+    boost_version_hpp="$boost_inc/boost/version.hpp"
+    test -e "$boost_version_hpp" \
+      && boost_cv_lib_version=`sed "$boost_sed_version" "$boost_version_hpp"`
+    ])
+m4_popdef([BOOST_VERSION_REQ])dnl
+])# BOOST_REQUIRE
+
+
+# BOOST_FIND_HEADER([HEADER-NAME], [ACTION-IF-NOT-FOUND], [ACTION-IF-FOUND])
+# --------------------------------------------------------------------------
+# Wrapper around AC_CHECK_HEADER for Boost headers.  Useful to check for
+# some parts of the Boost library which are only made of headers and don't
+# require linking (such as Boost.Foreach).
+#
+# Default ACTION-IF-NOT-FOUND: Fail with a fatal error.
+#
+# Default ACTION-IF-FOUND: define the preprocessor symbol HAVE_<HEADER-NAME> in
+# case of success # (where HEADER-NAME is written LIKE_THIS, e.g.,
+# HAVE_BOOST_FOREACH_HPP).
+AC_DEFUN([BOOST_FIND_HEADER],
+[AC_REQUIRE([BOOST_REQUIRE])dnl
+AC_LANG_PUSH([C++])dnl
+boost_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+AC_CHECK_HEADER([$1],
+  [m4_default([$3], [AC_DEFINE(AS_TR_CPP([HAVE_$1]), [1],
+                               [Define to 1 if you have <$1>])])],
+  [m4_default([$2], [AC_MSG_ERROR([cannot find $1])])])
+CPPFLAGS=$boost_save_CPPFLAGS
+AC_LANG_POP([C++])dnl
+])# BOOST_FIND_HEADER
+
+
+# BOOST_FIND_LIB([LIB-NAME], [PREFERRED-RT-OPT], [HEADER-NAME], [CXX-TEST])
+# -------------------------------------------------------------------------
+# Look for the Boost library LIB-NAME (e.g., LIB-NAME = `thread', for
+# libboost_thread).  Check that HEADER-NAME works and check that
+# libboost_LIB-NAME can link with the code CXX-TEST.
+#
+# Invokes BOOST_FIND_HEADER([HEADER-NAME]) (see above).
+#
+# Boost libraries typically come compiled with several flavors (with different
+# runtime options) so PREFERRED-RT-OPT is the preferred suffix.  A suffix is one
+# or more of the following letters: sgdpn (in that order).  s = static
+# runtime, d = debug build, g = debug/diagnostic runtime, p = STLPort build,
+# n = (unsure) STLPort build without iostreams from STLPort (it looks like `n'
+# must always be used along with `p').  Additionally, PREFERRED-RT-OPT can
+# start with `mt-' to indicate that there is a preference for multi-thread
+# builds.  Some sample values for PREFERRED-RT-OPT: (nothing), mt, d, mt-d, gdp
+# ...  If you want to make sure you have a specific version of Boost
+# (eg, >= 1.33) you *must* invoke BOOST_REQUIRE before this macro.
+AC_DEFUN([BOOST_FIND_LIB],
+[AC_REQUIRE([_BOOST_FIND_COMPILER_TAG])dnl
+AC_REQUIRE([BOOST_REQUIRE])dnl
+AC_REQUIRE([_BOOST_GUESS_WHETHER_TO_USE_MT])dnl
+AC_LANG_PUSH([C++])dnl
+AS_VAR_PUSHDEF([Boost_lib], [boost_cv_lib_$1])dnl
+AS_VAR_PUSHDEF([Boost_lib_LDFLAGS], [boost_cv_lib_$1_LDFLAGS])dnl
+AS_VAR_PUSHDEF([Boost_lib_LIBS], [boost_cv_lib_$1_LIBS])dnl
+BOOST_FIND_HEADER([$3])
+boost_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $BOOST_CPPFLAGS"
+# Now let's try to find the library.  The algorithm is as follows: first look
+# for a given library name according to the user's PREFERRED-RT-OPT.  For each
+# library name, we prefer to use the ones that carry the tag (toolset name).
+# Each library is searched through the various standard paths were Boost is
+# usually installed.  If we can't find the standard variants, we try to
+# enforce -mt (for instance on MacOSX, libboost_threads.dylib doesn't exist
+# but there's -obviously- libboost_threads-mt.dylib).
+AC_CACHE_CHECK([for the Boost $1 library], [Boost_lib],
+  [Boost_lib=no
+  case "$2" in #(
+    mt | mt-) boost_mt=-mt; boost_rtopt=;; #(
+    mt* | mt-*) boost_mt=-mt; boost_rtopt=`expr "X$2" : 'Xmt-*\(.*\)'`;; #(
+    *) boost_mt=; boost_rtopt=$2;;
+  esac
+  # If the PREFERRED-RT-OPT are not empty, prepend a `-'.
+  case $boost_rtopt in #(
+    *[[a-z0-9A-Z]]*) boost_rtopt="-$boost_rtopt";;
+  esac
+  $boost_guess_use_mt && boost_mt=-mt
+  boost_save_ac_objext=$ac_objext
+  # Generate the test file.
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <$3>], [$4])])
+dnl Optimization hacks: compiling C++ is slow, especially with Boost.  What
+dnl we're trying to do here is guess the right combination of link flags
+dnl (LIBS / LDFLAGS) to use a given library.  This can take several
+dnl iteration before it succeeds and is thus *very* slow.  So what we do
+dnl instead is that we compile the code first (and thus get an object file,
+dnl typically conftest.o).  Then we try various combinations of link flags
+dnl until we succeed to link conftest.o in an executable.  The problem is
+dnl that the various TRY_LINK / COMPILE_IFELSE macros of Autoconf always
+dnl remove all the temporary files including conftest.o.  So the trick here
+dnl is to temporarily change the value of ac_objext so that conftest.o is
+dnl preserved accross tests.  This is obviously fragile and I will burn in
+dnl hell for not respecting Autoconf's documented interfaces, but in the
+dnl mean time, it optimizes the macro by several order of magnitude.
+dnl Another small optimization: the first argument of AC_COMPILE_IFELSE left
+dnl empty because the test file is dnl generated only once above (before we
+dnl start the for loops).
+  AC_COMPILE_IFELSE([],
+    [ac_objext=do_not_rm_me_plz],
+    [AC_MSG_ERROR([Cannot compile a test that uses Boost $1])])
+  ac_objext=$boost_save_ac_objext
+  boost_failed_libs=
+# Don't bother to ident the 6 nested for loops, only the 2 inside-most ones
+# matter.
+for boost_tag_ in -$boost_cv_lib_tag ''; do
+for boost_ver_ in -$boost_cv_lib_version ''; do
+for boost_mt_ in $boost_mt -mt ''; do
+for boost_rtopt_ in $boost_rtopt '' -d; do
+  for boost_lib in \
+    boost_$1$boost_tag_$boost_mt_$boost_rtopt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_mt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_rtopt_$boost_ver_ \
+    boost_$1$boost_tag_$boost_mt_ \
+    boost_$1$boost_tag_$boost_ver_
+  do
+    # Avoid testing twice the same lib
+    case $boost_failed_libs in #(
+      *@$boost_lib@*) continue;;
+    esac
+    boost_save_LIBS=$LIBS
+    LIBS="-l$boost_lib $LIBS"
+    # If with_boost is empty, we'll search in /lib first, which is not quite
+    # right so instead we'll try to a location based on where the headers are.
+    boost_tmp_lib=$with_boost
+    test x"$with_boost" = x && boost_tmp_lib=${boost_cv_inc_path%/include}
+    for boost_ldpath in "$boost_tmp_lib/lib" '' \
+             /opt/local/lib /usr/local/lib /opt/lib /usr/lib \
+             "$with_boost" C:/Boost/lib /lib /usr/lib64 /lib64
+    do
+      test -e "$boost_ldpath" || continue
+      boost_save_LDFLAGS=$LDFLAGS
+      test x"$boost_ldpath" != x && LDFLAGS="$LDFLAGS -L$boost_ldpath"
+dnl First argument of AC_LINK_IFELSE left empty because the test file is
+dnl generated only once above (before we start the for loops).
+      _BOOST_AC_LINK_IFELSE([],
+                            [Boost_lib=yes], [Boost_lib=no])
+      ac_objext=$boost_save_ac_objext
+      LDFLAGS=$boost_save_LDFLAGS
+      if test x"$Boost_lib" = xyes; then
+        Boost_lib_LDFLAGS="-L$boost_ldpath -R$boost_ldpath"
+        Boost_lib_LIBS="-l$boost_lib"
+        LIBS=$boost_save_LIBS
+        break 6
+      else
+        boost_failed_libs="$boost_failed_libs@$boost_lib@"
+      fi
+    done
+    LIBS=$boost_save_LIBS
+  done
+done
+done
+done
+done
+rm -f conftest.$ac_objext
+])
+AC_SUBST(AS_TR_CPP([BOOST_$1_LDFLAGS]), [$Boost_lib_LDFLAGS])
+AC_SUBST(AS_TR_CPP([BOOST_$1_LIBS]), [$Boost_lib_LIBS])
+CPPFLAGS=$boost_save_CPPFLAGS
+AS_VAR_POPDEF([Boost_lib])dnl
+AS_VAR_POPDEF([Boost_lib_LDFLAGS])dnl
+AS_VAR_POPDEF([Boost_lib_LIBS])dnl
+AC_LANG_POP([C++])dnl
+])# BOOST_FIND_LIB
+
+
+# --------------------------------------- #
+# Checks for the various Boost libraries. #
+# --------------------------------------- #
+
+# List of boost libraries: http://www.boost.org/libs/libraries.htm
+# The page http://beta.boost.org/doc/libs is useful: it gives the first release
+# version of each library (among other things).
+
+
+# BOOST_ARRAY()
+# -------------
+# Look for Boost.Array
+AC_DEFUN([BOOST_ARRAY],
+[BOOST_FIND_HEADER([boost/array.hpp])])
+
+
+# BOOST_BIND()
+# ------------
+# Look for Boost.Bind
+AC_DEFUN([BOOST_BIND],
+[BOOST_FIND_HEADER([boost/bind.hpp])])
+
+
+# BOOST_CONVERSION()
+# ------------------
+# Look for Boost.Conversion (cast / lexical_cast)
+AC_DEFUN([BOOST_CONVERSION],
+[BOOST_FIND_HEADER([boost/cast.hpp])
+BOOST_FIND_HEADER([boost/lexical_cast.hpp])
+])# BOOST_CONVERSION
+
+
+# BOOST_DATE_TIME([PREFERRED-RT-OPT])
+# -----------------------------------
+# Look for Boost.Date_Time.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_DATE_TIME],
+[BOOST_FIND_LIB([date_time], [$1],
+                [boost/date_time/posix_time/posix_time.hpp],
+                [boost::posix_time::ptime t;])
+])# BOOST_DATE_TIME
+
+
+# BOOST_FILESYSTEM([PREFERRED-RT-OPT])
+# ------------------------------------
+# Look for Boost.Filesystem.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_FILESYSTEM],
+[BOOST_FIND_LIB([filesystem], [$1],
+                [boost/filesystem.hpp], [boost::filesystem::path p;])
+])# BOOST_FILESYSTEM
+
+
+# BOOST_FOREACH()
+# ---------------
+# Look for Boost.Foreach
+AC_DEFUN([BOOST_FOREACH],
+[BOOST_FIND_HEADER([boost/foreach.hpp])])
+
+
+# BOOST_FORMAT()
+# --------------
+# Look for Boost.Format
+# Note: we can't check for boost/format/format_fwd.hpp because the header isn't
+# standalone.  It can't be compiled because it triggers the following error:
+# boost/format/detail/config_macros.hpp:88: error: 'locale' in namespace 'std'
+#                                                  does not name a type
+AC_DEFUN([BOOST_FORMAT],
+[BOOST_FIND_HEADER([boost/format.hpp])])
+
+
+# BOOST_FUNCTION()
+# ----------------
+# Look for Boost.Function
+AC_DEFUN([BOOST_FUNCTION],
+[BOOST_FIND_HEADER([boost/function.hpp])])
+
+
+# BOOST_GRAPH([PREFERRED-RT-OPT])
+# -------------------------------
+# Look for Boost.Graphs.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_GRAPH],
+[BOOST_FIND_LIB([graph], [$1],
+                [boost/graph/adjacency_list.hpp], [boost::adjacency_list<> g;])
+])# BOOST_GRAPH
+
+
+# BOOST_PROGRAM_OPTIONS([PREFERRED-RT-OPT])
+# -----------------------------------------
+# Look for Boost.Program_options.  For the documentation of PREFERRED-RT-OPT, see
+# the documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_PROGRAM_OPTIONS],
+[BOOST_FIND_LIB([program_options], [$1],
+                [boost/program_options.hpp],
+                [boost::program_options::options_description d("test");])
+])# BOOST_PROGRAM_OPTIONS
+
+# BOOST_RANDOM()
+# -----------
+# Look for Boost.Random
+AC_DEFUN([BOOST_RANDOM],
+[BOOST_FIND_HEADER([boost/random.hpp])])
+
+
+# BOOST_REF()
+# -----------
+# Look for Boost.Ref
+AC_DEFUN([BOOST_REF],
+[BOOST_FIND_HEADER([boost/ref.hpp])])
+
+
+# BOOST_REGEX([PREFERRED-RT-OPT])
+# -------------------------------
+# Look for Boost.Regex.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_REGEX],
+[BOOST_FIND_LIB([regex], [$1],
+                [boost/regex.hpp],
+                [boost::regex exp("*"); boost::regex_match("foo", exp);])
+])# BOOST_REGEX
+
+
+# BOOST_SIGNALS([PREFERRED-RT-OPT])
+# ---------------------------------
+# Look for Boost.Signals.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_SIGNALS],
+[BOOST_FIND_LIB([signals], [$1],
+                [boost/signal.hpp],
+                [boost::signal<void ()> s;])
+])# BOOST_SIGNALS
+
+
+# BOOST_SMART_PTR()
+# -----------------
+# Look for Boost.SmartPtr
+AC_DEFUN([BOOST_SMART_PTR],
+[BOOST_FIND_HEADER([boost/scoped_ptr.hpp])
+BOOST_FIND_HEADER([boost/shared_ptr.hpp])
+])
+
+
+# BOOST_STRING_ALGO()
+# -------------------
+# Look for Boost.StringAlgo
+AC_DEFUN([BOOST_STRING_ALGO],
+[BOOST_FIND_HEADER([boost/algorithm/string.hpp])
+])
+
+
+# BOOST_TEST([PREFERRED-RT-OPT])
+# ------------------------------
+# Look for Boost.Test.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_TEST],
+[m4_pattern_allow([^BOOST_CHECK$])dnl
+BOOST_FIND_LIB([unit_test_framework], [$1],
+               [boost/test/unit_test.hpp], [BOOST_CHECK(2==2);])
+])# BOOST_TEST
+
+
+# BOOST_TRIBOOL()
+# ---------------
+# Look for Boost.Tribool
+AC_DEFUN([BOOST_TRIBOOL],
+[BOOST_FIND_HEADER([boost/logic/tribool_fwd.hpp])
+BOOST_FIND_HEADER([boost/logic/tribool.hpp])
+])
+
+
+# BOOST_THREADS([PREFERRED-RT-OPT])
+# ---------------------------------
+# Look for Boost.Thread.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+# FIXME: Provide an alias "BOOST_THREAD".
+AC_DEFUN([BOOST_THREADS],
+[dnl Having the pthread flag is required at least on GCC3 where
+dnl boost/thread.hpp would complain if we try to compile without
+dnl -pthread on GNU/Linux.
+AC_REQUIRE([_BOOST_PTHREAD_FLAG])dnl
+boost_threads_save_LIBS=$LIBS
+boost_threads_save_CPPFLAGS=$CPPFLAGS
+LIBS="$LIBS $boost_cv_pthread_flag"
+# Yes, we *need* to put the -pthread thing in CPPFLAGS because with GCC3,
+# boost/thread.hpp will trigger a #error if -pthread isn't used:
+#   boost/config/requires_threads.hpp:47:5: #error "Compiler threading support
+#   is not turned on. Please set the correct command line options for
+#   threading: -pthread (Linux), -pthreads (Solaris) or -mthreads (Mingw32)"
+CPPFLAGS="$CPPFLAGS $boost_cv_pthread_flag"
+BOOST_FIND_LIB([thread], [$1],
+                [boost/thread.hpp], [boost::thread t; boost::mutex m;])
+BOOST_THREAD_LIBS="$BOOST_THREAD_LIBS $boost_cv_pthread_flag"
+BOOST_CPPFLAGS="$BOOST_CPPFLAGS $boost_cv_pthread_flag"
+LIBS=$boost_threads_save_LIBS
+CPPFLAGS=$boost_threads_save_CPPFLAGS
+])# BOOST_THREADS
+
+
+# BOOST_TUPLE()
+# -------------
+# Look for Boost.Tuple
+AC_DEFUN([BOOST_TUPLE],
+[BOOST_FIND_HEADER([boost/tuple/tuple.hpp])])
+
+
+# BOOST_UTILITY()
+# ---------------
+# Look for Boost.Utility (noncopyable, result_of, base-from-member idiom,
+# etc.)
+AC_DEFUN([BOOST_UTILITY],
+[BOOST_FIND_HEADER([boost/utility.hpp])])
+
+
+# BOOST_VARIANT()
+# ---------------
+# Look for Boost.Variant.
+AC_DEFUN([BOOST_VARIANT],
+[BOOST_FIND_HEADER([boost/variant/variant_fwd.hpp])
+BOOST_FIND_HEADER([boost/variant.hpp])])
+
+
+# BOOST_WAVE([PREFERRED-RT-OPT])
+# ------------------------------
+# Look for Boost.Wave.  For the documentation of PREFERRED-RT-OPT, see the
+# documentation of BOOST_FIND_LIB above.
+AC_DEFUN([BOOST_WAVE],
+[BOOST_FIND_LIB([wave], [$1],
+                [boost/wave.hpp],
+                [boost::wave::token_id id; get_token_name(id);])])
+
+
+# ----------------- #
+# Internal helpers. #
+# ----------------- #
+
+
+# _BOOST_PTHREAD_FLAG()
+# ---------------------
+# Internal helper for BOOST_THREADS.  Based on ACX_PTHREAD:
+# http://autoconf-archive.cryp.to/acx_pthread.html
+AC_DEFUN([_BOOST_PTHREAD_FLAG],
+[AC_REQUIRE([AC_PROG_CXX])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_LANG_PUSH([C++])dnl
+AC_CACHE_CHECK([for the flags needed to use pthreads], [boost_cv_pthread_flag],
+[ boost_cv_pthread_flag=
+  # The ordering *is* (sometimes) important.  Some notes on the
+  # individual items follow:
+  # (none): in case threads are in libc; should be tried before -Kthread and
+  #       other compiler flags to prevent continual compiler warnings
+  # -lpthreads: AIX (must check this before -lpthread)
+  # -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
+  # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+  # -llthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+  # -pthread: GNU Linux/GCC (kernel threads), BSD/GCC (userland threads)
+  # -pthreads: Solaris/GCC
+  # -mthreads: MinGW32/GCC, Lynx/GCC
+  # -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
+  #      doesn't hurt to check since this sometimes defines pthreads too;
+  #      also defines -D_REENTRANT)
+  #      ... -mt is also the pthreads flag for HP/aCC
+  # -lpthread: GNU Linux, etc.
+  # --thread-safe: KAI C++
+  case $host_os in #(
+    *solaris*)
+      # On Solaris (at least, for some versions), libc contains stubbed
+      # (non-functional) versions of the pthreads routines, so link-based
+      # tests will erroneously succeed.  (We need to link with -pthreads/-mt/
+      # -lpthread.)  (The stubs are missing pthread_cleanup_push, or rather
+      # a function called by this macro, so we could check for that, but
+      # who knows whether they'll stub that too in a future libc.)  So,
+      # we'll just look for -pthreads and -lpthread first:
+      boost_pthread_flags="-pthreads -lpthread -mt -pthread";; #(
+    *)
+      boost_pthread_flags="-lpthreads -Kthread -kthread -llthread -pthread \
+                           -pthreads -mthreads -lpthread --thread-safe -mt";;
+  esac
+  # Generate the test file.
+  AC_LANG_CONFTEST([AC_LANG_PROGRAM([#include <pthread.h>],
+    [pthread_t th; pthread_join(th, 0);
+    pthread_attr_init(0); pthread_cleanup_push(0, 0);
+    pthread_create(0,0,0,0); pthread_cleanup_pop(0);])])
+  for boost_pthread_flag in '' $boost_pthread_flags; do
+    boost_pthread_ok=false
+dnl Re-use the test file already generated.
+    boost_pthreads__save_LIBS=$LIBS
+    LIBS="$LIBS $boost_pthread_flag"
+    AC_LINK_IFELSE([],
+      [if grep ".*$boost_pthread_flag" conftest.err; then
+         echo "This flag seems to have triggered warnings" >&AS_MESSAGE_LOG_FD
+       else
+         boost_pthread_ok=:; boost_cv_pthread_flag=$boost_pthread_flag
+       fi])
+    LIBS=$boost_pthreads__save_LIBS
+    $boost_pthread_ok && break
+  done
+])
+AC_LANG_POP([C++])dnl
+])# _BOOST_PTHREAD_FLAG
+
+
+# _BOOST_gcc_test(MAJOR, MINOR)
+# -----------------------------
+# Internal helper for _BOOST_FIND_COMPILER_TAG.
+m4_define([_BOOST_gcc_test],
+["defined __GNUC__ && __GNUC__ == $1 && __GNUC_MINOR__ == $2 && !defined __ICC @ gcc$1$2"])dnl
+
+
+# _BOOST_FIND_COMPILER_TAG()
+# --------------------------
+# Internal.  When Boost is installed without --layout=system, each library
+# filename will hold a suffix that encodes the compiler used during the
+# build.  The Boost build system seems to call this a `tag'.
+AC_DEFUN([_BOOST_FIND_COMPILER_TAG],
+[AC_REQUIRE([AC_PROG_CXX])dnl
+AC_CACHE_CHECK([for the toolset name used by Boost for $CXX], [boost_cv_lib_tag],
+[AC_LANG_PUSH([C++])dnl
+  boost_cv_lib_tag=unknown
+  # The following tests are mostly inspired by boost/config/auto_link.hpp
+  # The list is sorted to most recent/common to oldest compiler (in order
+  # to increase the likelihood of finding the right compiler with the
+  # least number of compilation attempt).
+  # Beware that some tests are sensible to the order (for instance, we must
+  # look for MinGW before looking for GCC3).
+  # I used one compilation test per compiler with a #error to recognize
+  # each compiler so that it works even when cross-compiling (let me know
+  # if you know a better approach).
+  # Known missing tags (known from Boost's tools/build/v2/tools/common.jam):
+  #   como, edg, kcc, bck, mp, sw, tru, xlc
+  # I'm not sure about my test for `il' (be careful: Intel's ICC pre-defines
+  # the same defines as GCC's).
+  # TODO: Move the test on GCC 4.3 up once it's released.
+  for i in \
+    _BOOST_gcc_test(4, 2) \
+    _BOOST_gcc_test(4, 1) \
+    _BOOST_gcc_test(4, 0) \
+    "defined __GNUC__ && __GNUC__ == 3 && !defined __ICC \
+     && (defined WIN32 || defined WINNT || defined _WIN32 || defined __WIN32 \
+         || defined __WIN32__ || defined __WINNT || defined __WINNT__) @ mgw" \
+    _BOOST_gcc_test(3, 4) \
+    _BOOST_gcc_test(3, 3) \
+    "defined _MSC_VER && _MSC_VER >= 1400 @ vc80" \
+    _BOOST_gcc_test(3, 2) \
+    "defined _MSC_VER && _MSC_VER == 1310 @ vc71" \
+    _BOOST_gcc_test(3, 1) \
+    _BOOST_gcc_test(3, 0) \
+    "defined __BORLANDC__ @ bcb" \
+    "defined __ICC && (defined __unix || defined __unix__) @ il" \
+    "defined __ICL @ iw" \
+    "defined _MSC_VER && _MSC_VER == 1300 @ vc7" \
+    _BOOST_gcc_test(4, 3) \
+    _BOOST_gcc_test(2, 95) \
+    "defined __MWERKS__ && __MWERKS__ <= 0x32FF @ cw9" \
+    "defined _MSC_VER && _MSC_VER < 1300 && !defined UNDER_CE @ vc6" \
+    "defined _MSC_VER && _MSC_VER < 1300 && defined UNDER_CE @ evc4" \
+    "defined __MWERKS__ && __MWERKS__ <= 0x31FF @ cw8"
+  do
+    boost_tag_test=`expr "X$i" : 'X\([[^@]]*\) @ '`
+    boost_tag=`expr "X$i" : 'X[[^@]]* @ \(.*\)'`
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if $boost_tag_test
+/* OK */
+#else
+# error $boost_tag_test
+#endif
+]])], [boost_cv_lib_tag=$boost_tag; break], [])
+  done
+AC_LANG_POP([C++])dnl
+])
+  if test x"$boost_cv_lib_tag" = xunknown; then
+    AC_MSG_WARN([[could not figure out which toolset name to use for $CXX]])
+    boost_cv_lib_tag=
+  fi
+])# _BOOST_FIND_COMPILER_TAG
+
+
+# _BOOST_GUESS_WHETHER_TO_USE_MT()
+# --------------------------------
+# Compile a small test to try to guess whether we should favor MT (Multi
+# Thread) flavors of Boost.  Sets boost_guess_use_mt accordingly.
+AC_DEFUN([_BOOST_GUESS_WHETHER_TO_USE_MT],
+[# Check whether we do better use `mt' even though we weren't ask to.
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#if defined _REENTRANT || defined _MT || defined __MT__
+/* use -mt */
+#else
+# error MT not needed
+#endif
+]])], [boost_guess_use_mt=:], [boost_guess_use_mt=false])
+])
+
+# _BOOST_AC_LINK_IFELSE(PROGRAM, [ACTION-IF-TRUE], [ACTION-IF-FALSE])
+# -------------------------------------------------------------------
+# Fork of _AC_LINK_IFELSE that preserves conftest.o across calls.  Fragile,
+# will break when Autoconf changes its internals.  Requires that you manually
+# rm -f conftest.$ac_objext in between to really different tests, otherwise
+# you will try to link a conftest.o left behind by a previous test.
+# Used to aggressively optimize BOOST_FIND_LIB (see the big comment in this
+# macro)
+m4_define([_BOOST_AC_LINK_IFELSE],
+[m4_ifvaln([$1], [AC_LANG_CONFTEST([$1])])dnl
+rm -f conftest$ac_exeext
+boost_ac_ext_save=$ac_ext
+boost_use_source=:
+# If we already have a .o, re-use it.  We change $ac_ext so that $ac_link
+# tries to link the existing object file instead of compiling from source.
+test -f conftest.$ac_objext && ac_ext=$ac_objext && boost_use_source=false &&
+  _AS_ECHO_LOG([re-using the existing conftest.$ac_objext])
+AS_IF([_AC_DO_STDERR($ac_link) && {
+	 test -z "$ac_[]_AC_LANG_ABBREV[]_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 AS_TEST_X([conftest$ac_exeext])
+       }],
+      [$2],
+      [if $boost_use_source; then
+         _AC_MSG_LOG_CONFTEST
+       fi
+       $3])
+dnl Delete also the IPA/IPO (Inter Procedural Analysis/Optimization)
+dnl information created by the PGI compiler (conftest_ipa8_conftest.oo),
+dnl as it would interfere with the next link command.
+rm -f core conftest.err conftest_ipa8_conftest.oo \
+      conftest$ac_exeext m4_ifval([$1], [conftest.$ac_ext])[]dnl
+])# _BOOST_AC_LINK_IFELSE
Index: ode/src/optimize.h
===================================================================
--- ode/src/optimize.h	(revision 0)
+++ ode/src/optimize.h	(revision 0)
@@ -0,0 +1,54 @@
+#ifndef _ODE_OPTIMIZE_H
+#define _ODE_OPTIMIZE_H
+
+#include <ode/odemath.h>
+#include <vector>
+#include <boost/shared_array.hpp>
+
+struct CvxOptParams
+{
+  int m;               // number of inequality constraints
+  int nu_len;          // number of equality constraints (rows of A)
+  dReal* A;            // equality constraint matrix
+  dReal* b;            // equality constraint vector
+  dReal mu;            // mu parameter for convex optimization
+  void* data;          // user data passed to functions 
+  int iterations;      // number of iterations performed (on exit)
+  int max_iterations;  // maximum number of iterations to be performed
+  dReal beta;          // exponential factor used in backtracking line search
+  dReal alpha;         // tolerance factor used in backtracking line search
+  dReal eps;           // tolerance to which the problem should be solved
+
+  // user defined functions
+  bool (*tcheck)(dReal*,int,void*);  // early exit testing function
+  void (*fx)(dReal*,int,dReal*,int,void*);   // objective/constraint function
+  void (*grad)(dReal*,int,int,dReal*,void*); // gradient function
+  bool (*hess)(dReal*,int,int,dReal*,void*); // hessian function
+
+  CvxOptParams()
+  {
+    m = nu_len = 0;
+    A = b = NULL;
+    data = NULL;
+    iterations = 0;
+    max_iterations = 0;
+    eps = (dReal) 0.0;
+
+    // setup reasonable values for alpha, beta, and mu
+    alpha = (dReal) 0.05;
+    beta = (dReal) 0.5;
+    mu = (dReal) 10.0;
+
+    tcheck = NULL;
+    fx = NULL;
+    grad = NULL;
+    hess = NULL;
+  }
+};
+
+bool dSolveLCPIP(dReal* M, dReal* q, dReal* x, int n, dReal eps_feas);
+bool dMakeFeasibleConvex(CvxOptParams& cparams, dReal eps_feas, dReal* x, int n);
+bool dOptimizeConvexPrimalDual(CvxOptParams& cparams, dReal eps_feas, dReal* x, int n);
+
+#endif
+
Index: ode/src/symm.c
===================================================================
--- ode/src/symm.c	(revision 0)
+++ ode/src/symm.c	(revision 0)
@@ -0,0 +1,5279 @@
+/* ilaenv.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+#include <ode/common.h>
+#include <math.h>
+
+// f2c stuff
+typedef int integer;
+typedef dReal real;
+typedef short ftnlen;
+typedef int logical;
+typedef double doublereal;
+
+#define dabs(x) (doublereal)abs(x)
+#define min(a,b) ((a) <= (b) ? (a) : (b))
+#define max(a,b) ((a) >= (b) ? (a) : (b))
+#define dmax(a,b) (doublereal)max(a,b)
+
+/* Table of constant values */
+
+static integer c__1 = 1;
+static real c_b163 = 0.f;
+static real c_b164 = 1.f;
+static integer c__0 = 0;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* assign strings:  a = b */
+
+#ifdef KR_headers
+VOID s_copy(a, b, la, lb) register char *a, *b; ftnlen la, lb;
+#else
+void s_copy(register char *a, register char *b, ftnlen la, ftnlen lb)
+#endif
+{
+	register char *aend, *bend;
+
+	aend = a + la;
+
+	if(la <= lb)
+#ifndef NO_OVERWRITE
+		if (a <= b || a >= b + la)
+#endif
+			while(a < aend)
+				*a++ = *b++;
+#ifndef NO_OVERWRITE
+		else
+			for(b += la; a < aend; )
+				*--aend = *--b;
+#endif
+
+	else {
+		bend = b + lb;
+#ifndef NO_OVERWRITE
+		if (a <= b || a >= bend)
+#endif
+			while(b < bend)
+				*a++ = *b++;
+#ifndef NO_OVERWRITE
+		else {
+			a += lb;
+			while(b < bend)
+				*--a = *--bend;
+			a += lb;
+			}
+#endif
+		while(a < aend)
+			*a++ = ' ';
+		}
+	}
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* compare two strings */
+
+#ifdef KR_headers
+integer s_cmp(a0, b0, la, lb) char *a0, *b0; ftnlen la, lb;
+#else
+integer s_cmp(char *a0, char *b0, ftnlen la, ftnlen lb)
+#endif
+{
+register unsigned char *a, *aend, *b, *bend;
+a = (unsigned char *)a0;
+b = (unsigned char *)b0;
+aend = a + la;
+bend = b + lb;
+
+if(la <= lb)
+	{
+	while(a < aend)
+		if(*a != *b)
+			return( *a - *b );
+		else
+			{ ++a; ++b; }
+
+	while(b < bend)
+		if(*b != ' ')
+			return( ' ' - *b );
+		else	++b;
+	}
+
+else
+	{
+	while(b < bend)
+		if(*a == *b)
+			{ ++a; ++b; }
+		else
+			return( *a - *b );
+	while(a < aend)
+		if(*a != ' ')
+			return(*a - ' ');
+		else	++a;
+	}
+return(0);
+}
+#ifdef __cplusplus
+}
+#endif
+
+integer ieeeck_(integer *ispec, real *zero, real *one)
+{
+    /* System generated locals */
+    integer ret_val;
+
+    /* Local variables */
+    static real nan1, nan2, nan3, nan4, nan5, nan6, neginf, posinf, negzro, 
+	    newzro;
+
+
+/*  -- LAPACK auxiliary routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  IEEECK is called from the ILAENV to verify that Infinity and */
+/*  possibly NaN arithmetic is safe (i.e. will not trap). */
+
+/*  Arguments */
+/*  ========= */
+
+/*  ISPEC   (input) INTEGER */
+/*          Specifies whether to test just for inifinity arithmetic */
+/*          or whether to test for infinity and NaN arithmetic. */
+/*          = 0: Verify infinity arithmetic only. */
+/*          = 1: Verify infinity and NaN arithmetic. */
+
+/*  ZERO    (input) REAL */
+/*          Must contain the value 0.0 */
+/*          This is passed to prevent the compiler from optimizing */
+/*          away this code. */
+
+/*  ONE     (input) REAL */
+/*          Must contain the value 1.0 */
+/*          This is passed to prevent the compiler from optimizing */
+/*          away this code. */
+
+/*  RETURN VALUE:  INTEGER */
+/*          = 0:  Arithmetic failed to produce the correct answers */
+/*          = 1:  Arithmetic produced the correct answers */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Executable Statements .. */
+    ret_val = 1;
+
+    posinf = *one / *zero;
+    if (posinf <= *one) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    neginf = -(*one) / *zero;
+    if (neginf >= *zero) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    negzro = *one / (neginf + *one);
+    if (negzro != *zero) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    neginf = *one / negzro;
+    if (neginf >= *zero) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    newzro = negzro + *zero;
+    if (newzro != *zero) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    posinf = *one / newzro;
+    if (posinf <= *one) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    neginf *= posinf;
+    if (neginf >= *zero) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    posinf *= posinf;
+    if (posinf <= *one) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+
+
+
+/*     Return if we were only asked to check infinity arithmetic */
+
+    if (*ispec == 0) {
+	return ret_val;
+    }
+
+    nan1 = posinf + neginf;
+
+    nan2 = posinf / neginf;
+
+    nan3 = posinf / posinf;
+
+    nan4 = posinf * *zero;
+
+    nan5 = neginf * negzro;
+
+    nan6 = nan5 * 0.f;
+
+    if (nan1 == nan1) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    if (nan2 == nan2) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    if (nan3 == nan3) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    if (nan4 == nan4) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    if (nan5 == nan5) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    if (nan6 == nan6) {
+	ret_val = 0;
+	return ret_val;
+    }
+
+    return ret_val;
+} /* ieeeck_ */
+
+integer ilaenv_(integer *ispec, char *name__, char *opts, integer *n1, 
+	integer *n2, integer *n3, integer *n4, ftnlen name_len, ftnlen 
+	opts_len)
+{
+    /* System generated locals */
+    integer ret_val;
+
+    /* Local variables */
+    static integer i__;
+    static char c1[1], c2[2], c3[3], c4[2];
+    static integer ic, nb, iz, nx;
+    static logical cname;
+    static integer nbmin;
+    static logical sname;
+    extern integer ieeeck_(integer *, real *, real *);
+    static char subnam[6];
+    extern integer iparmq_(integer *, char *, char *, integer *, integer *, 
+	    integer *, integer *, ftnlen, ftnlen);
+
+
+/*  -- LAPACK auxiliary routine (version 3.2.1)                        -- */
+
+/*  -- April 2009                                                      -- */
+
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  ILAENV is called from the LAPACK routines to choose problem-dependent */
+/*  parameters for the local environment.  See ISPEC for a description of */
+/*  the parameters. */
+
+/*  ILAENV returns an INTEGER */
+/*  if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC */
+/*  if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value. */
+
+/*  This version provides a set of parameters which should give good, */
+/*  but not optimal, performance on many of the currently available */
+/*  computers.  Users are encouraged to modify this subroutine to set */
+/*  the tuning parameters for their particular machine using the option */
+/*  and problem size information in the arguments. */
+
+/*  This routine will not function correctly if it is converted to all */
+/*  lower case.  Converting it to all upper case is allowed. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  ISPEC   (input) INTEGER */
+/*          Specifies the parameter to be returned as the value of */
+/*          ILAENV. */
+/*          = 1: the optimal blocksize; if this value is 1, an unblocked */
+/*               algorithm will give the best performance. */
+/*          = 2: the minimum block size for which the block routine */
+/*               should be used; if the usable block size is less than */
+/*               this value, an unblocked routine should be used. */
+/*          = 3: the crossover point (in a block routine, for N less */
+/*               than this value, an unblocked routine should be used) */
+/*          = 4: the number of shifts, used in the nonsymmetric */
+/*               eigenvalue routines (DEPRECATED) */
+/*          = 5: the minimum column dimension for blocking to be used; */
+/*               rectangular blocks must have dimension at least k by m, */
+/*               where k is given by ILAENV(2,...) and m by ILAENV(5,...) */
+/*          = 6: the crossover point for the SVD (when reducing an m by n */
+/*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds */
+/*               this value, a QR factorization is used first to reduce */
+/*               the matrix to a triangular form.) */
+/*          = 7: the number of processors */
+/*          = 8: the crossover point for the multishift QR method */
+/*               for nonsymmetric eigenvalue problems (DEPRECATED) */
+/*          = 9: maximum size of the subproblems at the bottom of the */
+/*               computation tree in the divide-and-conquer algorithm */
+/*               (used by xGELSD and xGESDD) */
+/*          =10: ieee NaN arithmetic can be trusted not to trap */
+/*          =11: infinity arithmetic can be trusted not to trap */
+/*          12 <= ISPEC <= 16: */
+/*               xHSEQR or one of its subroutines, */
+/*               see IPARMQ for detailed explanation */
+
+/*  NAME    (input) CHARACTER*(*) */
+/*          The name of the calling subroutine, in either upper case or */
+/*          lower case. */
+
+/*  OPTS    (input) CHARACTER*(*) */
+/*          The character options to the subroutine NAME, concatenated */
+/*          into a single character string.  For example, UPLO = 'U', */
+/*          TRANS = 'T', and DIAG = 'N' for a triangular routine would */
+/*          be specified as OPTS = 'UTN'. */
+
+/*  N1      (input) INTEGER */
+/*  N2      (input) INTEGER */
+/*  N3      (input) INTEGER */
+/*  N4      (input) INTEGER */
+/*          Problem dimensions for the subroutine NAME; these may not all */
+/*          be required. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  The following conventions have been used when calling ILAENV from the */
+/*  LAPACK routines: */
+/*  1)  OPTS is a concatenation of all of the character options to */
+/*      subroutine NAME, in the same order that they appear in the */
+/*      argument list for NAME, even if they are not used in determining */
+/*      the value of the parameter specified by ISPEC. */
+/*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order */
+/*      that they appear in the argument list for NAME.  N1 is used */
+/*      first, N2 second, and so on, and unused problem dimensions are */
+/*      passed a value of -1. */
+/*  3)  The parameter value returned by ILAENV is checked for validity in */
+/*      the calling subroutine.  For example, ILAENV is used to retrieve */
+/*      the optimal blocksize for STRTRI as follows: */
+
+/*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 ) */
+/*      IF( NB.LE.1 ) NB = MAX( 1, N ) */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+    switch (*ispec) {
+	case 1:  goto L10;
+	case 2:  goto L10;
+	case 3:  goto L10;
+	case 4:  goto L80;
+	case 5:  goto L90;
+	case 6:  goto L100;
+	case 7:  goto L110;
+	case 8:  goto L120;
+	case 9:  goto L130;
+	case 10:  goto L140;
+	case 11:  goto L150;
+	case 12:  goto L160;
+	case 13:  goto L160;
+	case 14:  goto L160;
+	case 15:  goto L160;
+	case 16:  goto L160;
+    }
+
+/*     Invalid value for ISPEC */
+
+    ret_val = -1;
+    return ret_val;
+
+L10:
+
+/*     Convert NAME to upper case if the first character is lower case. */
+
+    ret_val = 1;
+    s_copy(subnam, name__, (ftnlen)6, name_len);
+    ic = *(unsigned char *)subnam;
+    iz = 'Z';
+    if (iz == 90 || iz == 122) {
+
+/*        ASCII character set */
+
+	if (ic >= 97 && ic <= 122) {
+	    *(unsigned char *)subnam = (char) (ic - 32);
+	    for (i__ = 2; i__ <= 6; ++i__) {
+		ic = *(unsigned char *)&subnam[i__ - 1];
+		if (ic >= 97 && ic <= 122) {
+		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);
+		}
+/* L20: */
+	    }
+	}
+
+    } else if (iz == 233 || iz == 169) {
+
+/*        EBCDIC character set */
+
+	if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 162 && 
+		ic <= 169) {
+	    *(unsigned char *)subnam = (char) (ic + 64);
+	    for (i__ = 2; i__ <= 6; ++i__) {
+		ic = *(unsigned char *)&subnam[i__ - 1];
+		if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 
+			162 && ic <= 169) {
+		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic + 64);
+		}
+/* L30: */
+	    }
+	}
+
+    } else if (iz == 218 || iz == 250) {
+
+/*        Prime machines:  ASCII+128 */
+
+	if (ic >= 225 && ic <= 250) {
+	    *(unsigned char *)subnam = (char) (ic - 32);
+	    for (i__ = 2; i__ <= 6; ++i__) {
+		ic = *(unsigned char *)&subnam[i__ - 1];
+		if (ic >= 225 && ic <= 250) {
+		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);
+		}
+/* L40: */
+	    }
+	}
+    }
+
+    *(unsigned char *)c1 = *(unsigned char *)subnam;
+    sname = *(unsigned char *)c1 == 'S' || *(unsigned char *)c1 == 'D';
+    cname = *(unsigned char *)c1 == 'C' || *(unsigned char *)c1 == 'Z';
+    if (! (cname || sname)) {
+	return ret_val;
+    }
+    s_copy(c2, subnam + 1, (ftnlen)2, (ftnlen)2);
+    s_copy(c3, subnam + 3, (ftnlen)3, (ftnlen)3);
+    s_copy(c4, c3 + 1, (ftnlen)2, (ftnlen)2);
+
+    switch (*ispec) {
+	case 1:  goto L50;
+	case 2:  goto L60;
+	case 3:  goto L70;
+    }
+
+L50:
+
+/*     ISPEC = 1:  block size */
+
+/*     In these examples, separate code is provided for setting NB for */
+/*     real and complex.  We assume that NB will take the same value in */
+/*     single or double precision. */
+
+    nb = 1;
+
+    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	} else if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, 
+		"RQF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)
+		3, (ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) 
+		== 0) {
+	    if (sname) {
+		nb = 32;
+	    } else {
+		nb = 32;
+	    }
+	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 32;
+	    } else {
+		nb = 32;
+	    }
+	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 32;
+	    } else {
+		nb = 32;
+	    }
+	} else if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	}
+    } else if (s_cmp(c2, "PO", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	}
+    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	} else if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 32;
+	} else if (sname && s_cmp(c3, "GST", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 64;
+	}
+    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 64;
+	} else if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 32;
+	} else if (s_cmp(c3, "GST", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 64;
+	}
+    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nb = 32;
+	    }
+	} else if (*(unsigned char *)c3 == 'M') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nb = 32;
+	    }
+	}
+    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nb = 32;
+	    }
+	} else if (*(unsigned char *)c3 == 'M') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nb = 32;
+	    }
+	}
+    } else if (s_cmp(c2, "GB", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		if (*n4 <= 64) {
+		    nb = 1;
+		} else {
+		    nb = 32;
+		}
+	    } else {
+		if (*n4 <= 64) {
+		    nb = 1;
+		} else {
+		    nb = 32;
+		}
+	    }
+	}
+    } else if (s_cmp(c2, "PB", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		if (*n2 <= 64) {
+		    nb = 1;
+		} else {
+		    nb = 32;
+		}
+	    } else {
+		if (*n2 <= 64) {
+		    nb = 1;
+		} else {
+		    nb = 32;
+		}
+	    }
+	}
+    } else if (s_cmp(c2, "TR", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	}
+    } else if (s_cmp(c2, "LA", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "UUM", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nb = 64;
+	    } else {
+		nb = 64;
+	    }
+	}
+    } else if (sname && s_cmp(c2, "ST", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "EBZ", (ftnlen)3, (ftnlen)3) == 0) {
+	    nb = 1;
+	}
+    }
+    ret_val = nb;
+    return ret_val;
+
+L60:
+
+/*     ISPEC = 2:  minimum block size */
+
+    nbmin = 2;
+    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "RQF", (
+		ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)3, (
+		ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) == 0)
+		 {
+	    if (sname) {
+		nbmin = 2;
+	    } else {
+		nbmin = 2;
+	    }
+	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nbmin = 2;
+	    } else {
+		nbmin = 2;
+	    }
+	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nbmin = 2;
+	    } else {
+		nbmin = 2;
+	    }
+	} else if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nbmin = 2;
+	    } else {
+		nbmin = 2;
+	    }
+	}
+    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nbmin = 8;
+	    } else {
+		nbmin = 8;
+	    }
+	} else if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nbmin = 2;
+	}
+    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nbmin = 2;
+	}
+    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nbmin = 2;
+	    }
+	} else if (*(unsigned char *)c3 == 'M') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nbmin = 2;
+	    }
+	}
+    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nbmin = 2;
+	    }
+	} else if (*(unsigned char *)c3 == 'M') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nbmin = 2;
+	    }
+	}
+    }
+    ret_val = nbmin;
+    return ret_val;
+
+L70:
+
+/*     ISPEC = 3:  crossover point */
+
+    nx = 0;
+    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "RQF", (
+		ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)3, (
+		ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) == 0)
+		 {
+	    if (sname) {
+		nx = 128;
+	    } else {
+		nx = 128;
+	    }
+	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nx = 128;
+	    } else {
+		nx = 128;
+	    }
+	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    if (sname) {
+		nx = 128;
+	    } else {
+		nx = 128;
+	    }
+	}
+    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
+	if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nx = 32;
+	}
+    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
+	if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
+	    nx = 32;
+	}
+    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nx = 128;
+	    }
+	}
+    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
+	if (*(unsigned char *)c3 == 'G') {
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
+		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
+		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
+		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
+		    ftnlen)2, (ftnlen)2) == 0) {
+		nx = 128;
+	    }
+	}
+    }
+    ret_val = nx;
+    return ret_val;
+
+L80:
+
+/*     ISPEC = 4:  number of shifts (used by xHSEQR) */
+
+    ret_val = 6;
+    return ret_val;
+
+L90:
+
+/*     ISPEC = 5:  minimum column dimension (not used) */
+
+    ret_val = 2;
+    return ret_val;
+
+L100:
+
+/*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD) */
+
+    ret_val = (integer) ((real) min(*n1,*n2) * 1.6f);
+    return ret_val;
+
+L110:
+
+/*     ISPEC = 7:  number of processors (not used) */
+
+    ret_val = 1;
+    return ret_val;
+
+L120:
+
+/*     ISPEC = 8:  crossover point for multishift (used by xHSEQR) */
+
+    ret_val = 50;
+    return ret_val;
+
+L130:
+
+/*     ISPEC = 9:  maximum size of the subproblems at the bottom of the */
+/*                 computation tree in the divide-and-conquer algorithm */
+/*                 (used by xGELSD and xGESDD) */
+
+    ret_val = 25;
+    return ret_val;
+
+L140:
+
+/*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap */
+
+/*     ILAENV = 0 */
+    ret_val = 1;
+    if (ret_val == 1) {
+	ret_val = ieeeck_(&c__1, &c_b163, &c_b164);
+    }
+    return ret_val;
+
+L150:
+
+/*     ISPEC = 11: infinity arithmetic can be trusted not to trap */
+
+/*     ILAENV = 0 */
+    ret_val = 1;
+    if (ret_val == 1) {
+	ret_val = ieeeck_(&c__0, &c_b163, &c_b164);
+    }
+    return ret_val;
+
+L160:
+
+/*     12 <= ISPEC <= 16: xHSEQR or one of its subroutines. */
+
+    ret_val = iparmq_(ispec, name__, opts, n1, n2, n3, n4, name_len, opts_len)
+	    ;
+    return ret_val;
+
+/*     End of ILAENV */
+
+} /* ilaenv_ */
+
+#ifdef KR_headers
+double floor();
+integer i_nint(x) real *x;
+#else
+#undef abs
+#include "math.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+integer i_nint(real *x)
+#endif
+{
+return (integer)(*x >= 0 ? floor(*x + .5) : -floor(.5 - *x));
+}
+#ifdef __cplusplus
+}
+#endif
+
+integer iparmq_(integer *ispec, char *name__, char *opts, integer *n, integer 
+	*ilo, integer *ihi, integer *lwork, ftnlen name_len, ftnlen opts_len)
+{
+    /* System generated locals */
+    integer ret_val, i__1, i__2;
+    real r__1;
+
+    /* Builtin functions */
+    double log(doublereal);
+    integer i_nint(real *);
+
+    /* Local variables */
+    static integer nh, ns;
+
+
+/*  -- LAPACK auxiliary routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*       This program sets problem and machine dependent parameters */
+/*       useful for xHSEQR and its subroutines. It is called whenever */
+/*       ILAENV is called with 12 <= ISPEC <= 16 */
+
+/*  Arguments */
+/*  ========= */
+
+/*       ISPEC  (input) integer scalar */
+/*              ISPEC specifies which tunable parameter IPARMQ should */
+/*              return. */
+
+/*              ISPEC=12: (INMIN)  Matrices of order nmin or less */
+/*                        are sent directly to xLAHQR, the implicit */
+/*                        double shift QR algorithm.  NMIN must be */
+/*                        at least 11. */
+
+/*              ISPEC=13: (INWIN)  Size of the deflation window. */
+/*                        This is best set greater than or equal to */
+/*                        the number of simultaneous shifts NS. */
+/*                        Larger matrices benefit from larger deflation */
+/*                        windows. */
+
+/*              ISPEC=14: (INIBL) Determines when to stop nibbling and */
+/*                        invest in an (expensive) multi-shift QR sweep. */
+/*                        If the aggressive early deflation subroutine */
+/*                        finds LD converged eigenvalues from an order */
+/*                        NW deflation window and LD.GT.(NW*NIBBLE)/100, */
+/*                        then the next QR sweep is skipped and early */
+/*                        deflation is applied immediately to the */
+/*                        remaining active diagonal block.  Setting */
+/*                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a */
+/*                        multi-shift QR sweep whenever early deflation */
+/*                        finds a converged eigenvalue.  Setting */
+/*                        IPARMQ(ISPEC=14) greater than or equal to 100 */
+/*                        prevents TTQRE from skipping a multi-shift */
+/*                        QR sweep. */
+
+/*              ISPEC=15: (NSHFTS) The number of simultaneous shifts in */
+/*                        a multi-shift QR iteration. */
+
+/*              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the */
+/*                        following meanings. */
+/*                        0:  During the multi-shift QR sweep, */
+/*                            xLAQR5 does not accumulate reflections and */
+/*                            does not use matrix-matrix multiply to */
+/*                            update the far-from-diagonal matrix */
+/*                            entries. */
+/*                        1:  During the multi-shift QR sweep, */
+/*                            xLAQR5 and/or xLAQRaccumulates reflections and uses */
+/*                            matrix-matrix multiply to update the */
+/*                            far-from-diagonal matrix entries. */
+/*                        2:  During the multi-shift QR sweep. */
+/*                            xLAQR5 accumulates reflections and takes */
+/*                            advantage of 2-by-2 block structure during */
+/*                            matrix-matrix multiplies. */
+/*                        (If xTRMM is slower than xGEMM, then */
+/*                        IPARMQ(ISPEC=16)=1 may be more efficient than */
+/*                        IPARMQ(ISPEC=16)=2 despite the greater level of */
+/*                        arithmetic work implied by the latter choice.) */
+
+/*       NAME    (input) character string */
+/*               Name of the calling subroutine */
+
+/*       OPTS    (input) character string */
+/*               This is a concatenation of the string arguments to */
+/*               TTQRE. */
+
+/*       N       (input) integer scalar */
+/*               N is the order of the Hessenberg matrix H. */
+
+/*       ILO     (input) INTEGER */
+/*       IHI     (input) INTEGER */
+/*               It is assumed that H is already upper triangular */
+/*               in rows and columns 1:ILO-1 and IHI+1:N. */
+
+/*       LWORK   (input) integer scalar */
+/*               The amount of workspace available. */
+
+/*  Further Details */
+/*  =============== */
+
+/*       Little is known about how best to choose these parameters. */
+/*       It is possible to use different values of the parameters */
+/*       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR. */
+
+/*       It is probably best to choose different parameters for */
+/*       different matrices and different parameters at different */
+/*       times during the iteration, but this has not been */
+/*       implemented --- yet. */
+
+
+/*       The best choices of most of the parameters depend */
+/*       in an ill-understood way on the relative execution */
+/*       rate of xLAQR3 and xLAQR5 and on the nature of each */
+/*       particular eigenvalue problem.  Experiment may be the */
+/*       only practical way to determine which choices are most */
+/*       effective. */
+
+/*       Following is a list of default values supplied by IPARMQ. */
+/*       These defaults may be adjusted in order to attain better */
+/*       performance in any particular computational environment. */
+
+/*       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point. */
+/*                        Default: 75. (Must be at least 11.) */
+
+/*       IPARMQ(ISPEC=13) Recommended deflation window size. */
+/*                        This depends on ILO, IHI and NS, the */
+/*                        number of simultaneous shifts returned */
+/*                        by IPARMQ(ISPEC=15).  The default for */
+/*                        (IHI-ILO+1).LE.500 is NS.  The default */
+/*                        for (IHI-ILO+1).GT.500 is 3*NS/2. */
+
+/*       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14. */
+
+/*       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS. */
+/*                        a multi-shift QR iteration. */
+
+/*                        If IHI-ILO+1 is ... */
+
+/*                        greater than      ...but less    ... the */
+/*                        or equal to ...      than        default is */
+
+/*                                0               30       NS =   2+ */
+/*                               30               60       NS =   4+ */
+/*                               60              150       NS =  10 */
+/*                              150              590       NS =  ** */
+/*                              590             3000       NS =  64 */
+/*                             3000             6000       NS = 128 */
+/*                             6000             infinity   NS = 256 */
+
+/*                    (+)  By default matrices of this order are */
+/*                         passed to the implicit double shift routine */
+/*                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These */
+/*                         values of NS are used only in case of a rare */
+/*                         xLAHQR failure. */
+
+/*                    (**) The asterisks (**) indicate an ad-hoc */
+/*                         function increasing from 10 to 64. */
+
+/*       IPARMQ(ISPEC=16) Select structured matrix multiply. */
+/*                        (See ISPEC=16 above for details.) */
+/*                        Default: 3. */
+
+/*     ================================================================ */
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+    if (*ispec == 15 || *ispec == 13 || *ispec == 16) {
+
+/*        ==== Set the number simultaneous shifts ==== */
+
+	nh = *ihi - *ilo + 1;
+	ns = 2;
+	if (nh >= 30) {
+	    ns = 4;
+	}
+	if (nh >= 60) {
+	    ns = 10;
+	}
+	if (nh >= 150) {
+/* Computing MAX */
+	    r__1 = log((real) nh) / log(2.f);
+	    i__1 = 10, i__2 = nh / i_nint(&r__1);
+	    ns = max(i__1,i__2);
+	}
+	if (nh >= 590) {
+	    ns = 64;
+	}
+	if (nh >= 3000) {
+	    ns = 128;
+	}
+	if (nh >= 6000) {
+	    ns = 256;
+	}
+/* Computing MAX */
+	i__1 = 2, i__2 = ns - ns % 2;
+	ns = max(i__1,i__2);
+    }
+
+    if (*ispec == 12) {
+
+
+/*        ===== Matrices of order smaller than NMIN get sent */
+/*        .     to xLAHQR, the classic double shift algorithm. */
+/*        .     This must be at least 11. ==== */
+
+	ret_val = 75;
+
+    } else if (*ispec == 14) {
+
+/*        ==== INIBL: skip a multi-shift qr iteration and */
+/*        .    whenever aggressive early deflation finds */
+/*        .    at least (NIBBLE*(window size)/100) deflations. ==== */
+
+	ret_val = 14;
+
+    } else if (*ispec == 15) {
+
+/*        ==== NSHFTS: The number of simultaneous shifts ===== */
+
+	ret_val = ns;
+
+    } else if (*ispec == 13) {
+
+/*        ==== NW: deflation window size.  ==== */
+
+	if (nh <= 500) {
+	    ret_val = ns;
+	} else {
+	    ret_val = ns * 3 / 2;
+	}
+
+    } else if (*ispec == 16) {
+
+/*        ==== IACC22: Whether to accumulate reflections */
+/*        .     before updating the far-from-diagonal elements */
+/*        .     and whether to use 2-by-2 block structure while */
+/*        .     doing it.  A small amount of work could be saved */
+/*        .     by making this choice dependent also upon the */
+/*        .     NH=IHI-ILO+1. */
+
+	ret_val = 0;
+	if (ns >= 14) {
+	    ret_val = 1;
+	}
+	if (ns >= 14) {
+	    ret_val = 2;
+	}
+
+    } else {
+/*        ===== invalid value of ispec ===== */
+	ret_val = -1;
+
+    }
+
+/*     ==== End of IPARMQ ==== */
+
+    return ret_val;
+} /* iparmq_ */
+
+
+/* ../BLAS/SRC/isamax.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+integer isamax_(integer *n, real *sx, integer *incx)
+{
+    /* System generated locals */
+    integer ret_val, i__1;
+    real r__1;
+
+    /* Local variables */
+    static integer i__, ix;
+    static real smax;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*     ISAMAX finds the index of element having max. absolute value. */
+
+/*  Further Details */
+/*  =============== */
+
+/*     jack dongarra, linpack, 3/11/78. */
+/*     modified 3/93 to return if incx .le. 0. */
+/*     modified 12/3/93, array(1) declarations changed to array(*) */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+    /* Parameter adjustments */
+    --sx;
+
+    /* Function Body */
+    ret_val = 0;
+    if (*n < 1 || *incx <= 0) {
+	return ret_val;
+    }
+    ret_val = 1;
+    if (*n == 1) {
+	return ret_val;
+    }
+    if (*incx == 1) {
+	goto L20;
+    }
+
+/*        code for increment not equal to 1 */
+
+    ix = 1;
+    smax = dabs(sx[1]);
+    ix += *incx;
+    i__1 = *n;
+    for (i__ = 2; i__ <= i__1; ++i__) {
+	if ((r__1 = sx[ix], dabs(r__1)) <= smax) {
+	    goto L5;
+	}
+	ret_val = i__;
+	smax = (r__1 = sx[ix], dabs(r__1));
+L5:
+	ix += *incx;
+/* L10: */
+    }
+    return ret_val;
+
+/*        code for increment equal to 1 */
+
+L20:
+    smax = dabs(sx[1]);
+    i__1 = *n;
+    for (i__ = 2; i__ <= i__1; ++i__) {
+	if ((r__1 = sx[i__], dabs(r__1)) <= smax) {
+	    goto L30;
+	}
+	ret_val = i__;
+	smax = (r__1 = sx[i__], dabs(r__1));
+L30:
+	;
+    }
+    return ret_val;
+} /* isamax_ */
+
+/* ../BLAS/SRC/lsame.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+logical lsame_(char *ca, char *cb, ftnlen ca_len, ftnlen cb_len)
+{
+    /* System generated locals */
+    logical ret_val;
+
+    /* Local variables */
+    static integer inta, intb, zcode;
+
+
+/*  -- LAPACK auxiliary routine (version 3.1) -- */
+/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  LSAME returns .TRUE. if CA is the same letter as CB regardless of */
+/*  case. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  CA      (input) CHARACTER*1 */
+
+/*  CB      (input) CHARACTER*1 */
+/*          CA and CB specify the single characters to be compared. */
+
+/* ===================================================================== */
+
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+
+/*     Test if the characters are equal */
+
+    ret_val = *(unsigned char *)ca == *(unsigned char *)cb;
+    if (ret_val) {
+	return ret_val;
+    }
+
+/*     Now test for equivalence if both characters are alphabetic. */
+
+    zcode = 'Z';
+
+/*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime */
+/*     machines, on which ICHAR returns a value with bit 8 set. */
+/*     ICHAR('A') on Prime machines returns 193 which is the same as */
+/*     ICHAR('A') on an EBCDIC machine. */
+
+    inta = *(unsigned char *)ca;
+    intb = *(unsigned char *)cb;
+
+    if (zcode == 90 || zcode == 122) {
+
+/*        ASCII is assumed - ZCODE is the ASCII code of either lower or */
+/*        upper case 'Z'. */
+
+	if (inta >= 97 && inta <= 122) {
+	    inta += -32;
+	}
+	if (intb >= 97 && intb <= 122) {
+	    intb += -32;
+	}
+
+    } else if (zcode == 233 || zcode == 169) {
+
+/*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or */
+/*        upper case 'Z'. */
+
+	if (inta >= 129 && inta <= 137 || inta >= 145 && inta <= 153 || inta 
+		>= 162 && inta <= 169) {
+	    inta += 64;
+	}
+	if (intb >= 129 && intb <= 137 || intb >= 145 && intb <= 153 || intb 
+		>= 162 && intb <= 169) {
+	    intb += 64;
+	}
+
+    } else if (zcode == 218 || zcode == 250) {
+
+/*        ASCII is assumed, on Prime machines - ZCODE is the ASCII code */
+/*        plus 128 of either lower or upper case 'Z'. */
+
+	if (inta >= 225 && inta <= 250) {
+	    inta += -32;
+	}
+	if (intb >= 225 && intb <= 250) {
+	    intb += -32;
+	}
+    }
+    ret_val = inta == intb;
+
+/*     RETURN */
+
+/*     End of LSAME */
+
+    return ret_val;
+} /* lsame_ */
+
+/* ../BLAS/SRC/scopy.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int scopy_(integer *n, real *sx, integer *incx, real *sy, 
+	integer *incy)
+{
+    /* System generated locals */
+    integer i__1;
+
+    /* Local variables */
+    static integer i__, m, ix, iy, mp1;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*     SCOPY copies a vector, x, to a vector, y. */
+/*     uses unrolled loops for increments equal to 1. */
+
+/*  Further Details */
+/*  =============== */
+
+/*     jack dongarra, linpack, 3/11/78. */
+/*     modified 12/3/93, array(1) declarations changed to array(*) */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+    /* Parameter adjustments */
+    --sy;
+    --sx;
+
+    /* Function Body */
+    if (*n <= 0) {
+	return 0;
+    }
+    if (*incx == 1 && *incy == 1) {
+	goto L20;
+    }
+
+/*        code for unequal increments or equal increments */
+/*          not equal to 1 */
+
+    ix = 1;
+    iy = 1;
+    if (*incx < 0) {
+	ix = (-(*n) + 1) * *incx + 1;
+    }
+    if (*incy < 0) {
+	iy = (-(*n) + 1) * *incy + 1;
+    }
+    i__1 = *n;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sy[iy] = sx[ix];
+	ix += *incx;
+	iy += *incy;
+/* L10: */
+    }
+    return 0;
+
+/*        code for both increments equal to 1 */
+
+
+/*        clean-up loop */
+
+L20:
+    m = *n % 7;
+    if (m == 0) {
+	goto L40;
+    }
+    i__1 = m;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	sy[i__] = sx[i__];
+/* L30: */
+    }
+    if (*n < 7) {
+	return 0;
+    }
+L40:
+    mp1 = m + 1;
+    i__1 = *n;
+    for (i__ = mp1; i__ <= i__1; i__ += 7) {
+	sy[i__] = sx[i__];
+	sy[i__ + 1] = sx[i__ + 1];
+	sy[i__ + 2] = sx[i__ + 2];
+	sy[i__ + 3] = sx[i__ + 3];
+	sy[i__ + 4] = sx[i__ + 4];
+	sy[i__ + 5] = sx[i__ + 5];
+	sy[i__ + 6] = sx[i__ + 6];
+/* L50: */
+    }
+    return 0;
+} /* scopy_ */
+
+/* ../BLAS/SRC/sgemm.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int sgemm_(char *transa, char *transb, integer *m, integer *
+	n, integer *k, real *alpha, real *a, integer *lda, real *b, integer *
+	ldb, real *beta, real *c__, integer *ldc, ftnlen transa_len, ftnlen 
+	transb_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
+	    i__3;
+
+    /* Local variables */
+    static integer i__, j, l, info;
+    static logical nota, notb;
+    static real temp;
+    static integer ncola;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    static integer nrowa, nrowb;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SGEMM  performs one of the matrix-matrix operations */
+
+/*     C := alpha*op( A )*op( B ) + beta*C, */
+
+/*  where  op( X ) is one of */
+
+/*     op( X ) = X   or   op( X ) = X', */
+
+/*  alpha and beta are scalars, and A, B and C are matrices, with op( A ) */
+/*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix. */
+
+/*  Arguments */
+/*  ========== */
+
+/*  TRANSA - CHARACTER*1. */
+/*           On entry, TRANSA specifies the form of op( A ) to be used in */
+/*           the matrix multiplication as follows: */
+
+/*              TRANSA = 'N' or 'n',  op( A ) = A. */
+
+/*              TRANSA = 'T' or 't',  op( A ) = A'. */
+
+/*              TRANSA = 'C' or 'c',  op( A ) = A'. */
+
+/*           Unchanged on exit. */
+
+/*  TRANSB - CHARACTER*1. */
+/*           On entry, TRANSB specifies the form of op( B ) to be used in */
+/*           the matrix multiplication as follows: */
+
+/*              TRANSB = 'N' or 'n',  op( B ) = B. */
+
+/*              TRANSB = 'T' or 't',  op( B ) = B'. */
+
+/*              TRANSB = 'C' or 'c',  op( B ) = B'. */
+
+/*           Unchanged on exit. */
+
+/*  M      - INTEGER. */
+/*           On entry,  M  specifies  the number  of rows  of the  matrix */
+/*           op( A )  and of the  matrix  C.  M  must  be at least  zero. */
+/*           Unchanged on exit. */
+
+/*  N      - INTEGER. */
+/*           On entry,  N  specifies the number  of columns of the matrix */
+/*           op( B ) and the number of columns of the matrix C. N must be */
+/*           at least zero. */
+/*           Unchanged on exit. */
+
+/*  K      - INTEGER. */
+/*           On entry,  K  specifies  the number of columns of the matrix */
+/*           op( A ) and the number of rows of the matrix op( B ). K must */
+/*           be at least  zero. */
+/*           Unchanged on exit. */
+
+/*  ALPHA  - REAL            . */
+/*           On entry, ALPHA specifies the scalar alpha. */
+/*           Unchanged on exit. */
+
+/*  A      - REAL             array of DIMENSION ( LDA, ka ), where ka is */
+/*           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise. */
+/*           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k */
+/*           part of the array  A  must contain the matrix  A,  otherwise */
+/*           the leading  k by m  part of the array  A  must contain  the */
+/*           matrix A. */
+/*           Unchanged on exit. */
+
+/*  LDA    - INTEGER. */
+/*           On entry, LDA specifies the first dimension of A as declared */
+/*           in the calling (sub) program. When  TRANSA = 'N' or 'n' then */
+/*           LDA must be at least  max( 1, m ), otherwise  LDA must be at */
+/*           least  max( 1, k ). */
+/*           Unchanged on exit. */
+
+/*  B      - REAL             array of DIMENSION ( LDB, kb ), where kb is */
+/*           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. */
+/*           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n */
+/*           part of the array  B  must contain the matrix  B,  otherwise */
+/*           the leading  n by k  part of the array  B  must contain  the */
+/*           matrix B. */
+/*           Unchanged on exit. */
+
+/*  LDB    - INTEGER. */
+/*           On entry, LDB specifies the first dimension of B as declared */
+/*           in the calling (sub) program. When  TRANSB = 'N' or 'n' then */
+/*           LDB must be at least  max( 1, k ), otherwise  LDB must be at */
+/*           least  max( 1, n ). */
+/*           Unchanged on exit. */
+
+/*  BETA   - REAL            . */
+/*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is */
+/*           supplied as zero then C need not be set on input. */
+/*           Unchanged on exit. */
+
+/*  C      - REAL             array of DIMENSION ( LDC, n ). */
+/*           Before entry, the leading  m by n  part of the array  C must */
+/*           contain the matrix  C,  except when  beta  is zero, in which */
+/*           case C need not be set on entry. */
+/*           On exit, the array  C  is overwritten by the  m by n  matrix */
+/*           ( alpha*op( A )*op( B ) + beta*C ). */
+
+/*  LDC    - INTEGER. */
+/*           On entry, LDC specifies the first dimension of C as declared */
+/*           in  the  calling  (sub)  program.   LDC  must  be  at  least */
+/*           max( 1, m ). */
+/*           Unchanged on exit. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  Level 3 Blas routine. */
+
+/*  -- Written on 8-February-1989. */
+/*     Jack Dongarra, Argonne National Laboratory. */
+/*     Iain Duff, AERE Harwell. */
+/*     Jeremy Du Croz, Numerical Algorithms Group Ltd. */
+/*     Sven Hammarling, Numerical Algorithms Group Ltd. */
+
+/*  ===================================================================== */
+
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Parameters .. */
+/*     .. */
+
+/*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not */
+/*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows */
+/*     and  columns of  A  and the  number of  rows  of  B  respectively. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    b_dim1 = *ldb;
+    b_offset = 1 + b_dim1;
+    b -= b_offset;
+    c_dim1 = *ldc;
+    c_offset = 1 + c_dim1;
+    c__ -= c_offset;
+
+    /* Function Body */
+    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
+    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
+    if (nota) {
+	nrowa = *m;
+	ncola = *k;
+    } else {
+	nrowa = *k;
+	ncola = *m;
+    }
+    if (notb) {
+	nrowb = *k;
+    } else {
+	nrowb = *n;
+    }
+
+/*     Test the input parameters. */
+
+    info = 0;
+    if (! nota && ! lsame_(transa, "C", (ftnlen)1, (ftnlen)1) && ! lsame_(
+	    transa, "T", (ftnlen)1, (ftnlen)1)) {
+	info = 1;
+    } else if (! notb && ! lsame_(transb, "C", (ftnlen)1, (ftnlen)1) && ! 
+	    lsame_(transb, "T", (ftnlen)1, (ftnlen)1)) {
+	info = 2;
+    } else if (*m < 0) {
+	info = 3;
+    } else if (*n < 0) {
+	info = 4;
+    } else if (*k < 0) {
+	info = 5;
+    } else if (*lda < max(1,nrowa)) {
+	info = 8;
+    } else if (*ldb < max(1,nrowb)) {
+	info = 10;
+    } else if (*ldc < max(1,*m)) {
+	info = 13;
+    }
+    if (info != 0) {
+	return 0;
+    }
+
+/*     Quick return if possible. */
+
+    if (*m == 0 || *n == 0 || (*alpha == 0.f || *k == 0) && *beta == 1.f) {
+	return 0;
+    }
+
+/*     And if  alpha.eq.zero. */
+
+    if (*alpha == 0.f) {
+	if (*beta == 0.f) {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    c__[i__ + j * c_dim1] = 0.f;
+/* L10: */
+		}
+/* L20: */
+	    }
+	} else {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
+/* L30: */
+		}
+/* L40: */
+	    }
+	}
+	return 0;
+    }
+
+/*     Start the operations. */
+
+    if (notb) {
+	if (nota) {
+
+/*           Form  C := alpha*A*B + beta*C. */
+
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (*beta == 0.f) {
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			c__[i__ + j * c_dim1] = 0.f;
+/* L50: */
+		    }
+		} else if (*beta != 1.f) {
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
+/* L60: */
+		    }
+		}
+		i__2 = *k;
+		for (l = 1; l <= i__2; ++l) {
+		    if (b[l + j * b_dim1] != 0.f) {
+			temp = *alpha * b[l + j * b_dim1];
+			i__3 = *m;
+			for (i__ = 1; i__ <= i__3; ++i__) {
+			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
+				    a_dim1];
+/* L70: */
+			}
+		    }
+/* L80: */
+		}
+/* L90: */
+	    }
+	} else {
+
+/*           Form  C := alpha*A'*B + beta*C */
+
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    temp = 0.f;
+		    i__3 = *k;
+		    for (l = 1; l <= i__3; ++l) {
+			temp += a[l + i__ * a_dim1] * b[l + j * b_dim1];
+/* L100: */
+		    }
+		    if (*beta == 0.f) {
+			c__[i__ + j * c_dim1] = *alpha * temp;
+		    } else {
+			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
+				i__ + j * c_dim1];
+		    }
+/* L110: */
+		}
+/* L120: */
+	    }
+	}
+    } else {
+	if (nota) {
+
+/*           Form  C := alpha*A*B' + beta*C */
+
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (*beta == 0.f) {
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			c__[i__ + j * c_dim1] = 0.f;
+/* L130: */
+		    }
+		} else if (*beta != 1.f) {
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
+/* L140: */
+		    }
+		}
+		i__2 = *k;
+		for (l = 1; l <= i__2; ++l) {
+		    if (b[j + l * b_dim1] != 0.f) {
+			temp = *alpha * b[j + l * b_dim1];
+			i__3 = *m;
+			for (i__ = 1; i__ <= i__3; ++i__) {
+			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
+				    a_dim1];
+/* L150: */
+			}
+		    }
+/* L160: */
+		}
+/* L170: */
+	    }
+	} else {
+
+/*           Form  C := alpha*A'*B' + beta*C */
+
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    temp = 0.f;
+		    i__3 = *k;
+		    for (l = 1; l <= i__3; ++l) {
+			temp += a[l + i__ * a_dim1] * b[j + l * b_dim1];
+/* L180: */
+		    }
+		    if (*beta == 0.f) {
+			c__[i__ + j * c_dim1] = *alpha * temp;
+		    } else {
+			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
+				i__ + j * c_dim1];
+		    }
+/* L190: */
+		}
+/* L200: */
+	    }
+	}
+    }
+
+    return 0;
+
+/*     End of SGEMM . */
+
+} /* sgemm_ */
+
+/* ../BLAS/SRC/sgemv.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int sgemv_(char *trans, integer *m, integer *n, real *alpha, 
+	real *a, integer *lda, real *x, integer *incx, real *beta, real *y, 
+	integer *incy, ftnlen trans_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+
+    /* Local variables */
+    static integer i__, j, ix, iy, jx, jy, kx, ky, info;
+    static real temp;
+    static integer lenx, leny;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SGEMV  performs one of the matrix-vector operations */
+
+/*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y, */
+
+/*  where alpha and beta are scalars, x and y are vectors and A is an */
+/*  m by n matrix. */
+
+/*  Arguments */
+/*  ========== */
+
+/*  TRANS  - CHARACTER*1. */
+/*           On entry, TRANS specifies the operation to be performed as */
+/*           follows: */
+
+/*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y. */
+
+/*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y. */
+
+/*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y. */
+
+/*           Unchanged on exit. */
+
+/*  M      - INTEGER. */
+/*           On entry, M specifies the number of rows of the matrix A. */
+/*           M must be at least zero. */
+/*           Unchanged on exit. */
+
+/*  N      - INTEGER. */
+/*           On entry, N specifies the number of columns of the matrix A. */
+/*           N must be at least zero. */
+/*           Unchanged on exit. */
+
+/*  ALPHA  - REAL            . */
+/*           On entry, ALPHA specifies the scalar alpha. */
+/*           Unchanged on exit. */
+
+/*  A      - REAL             array of DIMENSION ( LDA, n ). */
+/*           Before entry, the leading m by n part of the array A must */
+/*           contain the matrix of coefficients. */
+/*           Unchanged on exit. */
+
+/*  LDA    - INTEGER. */
+/*           On entry, LDA specifies the first dimension of A as declared */
+/*           in the calling (sub) program. LDA must be at least */
+/*           max( 1, m ). */
+/*           Unchanged on exit. */
+
+/*  X      - REAL             array of DIMENSION at least */
+/*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n' */
+/*           and at least */
+/*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise. */
+/*           Before entry, the incremented array X must contain the */
+/*           vector x. */
+/*           Unchanged on exit. */
+
+/*  INCX   - INTEGER. */
+/*           On entry, INCX specifies the increment for the elements of */
+/*           X. INCX must not be zero. */
+/*           Unchanged on exit. */
+
+/*  BETA   - REAL            . */
+/*           On entry, BETA specifies the scalar beta. When BETA is */
+/*           supplied as zero then Y need not be set on input. */
+/*           Unchanged on exit. */
+
+/*  Y      - REAL             array of DIMENSION at least */
+/*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n' */
+/*           and at least */
+/*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise. */
+/*           Before entry with BETA non-zero, the incremented array Y */
+/*           must contain the vector y. On exit, Y is overwritten by the */
+/*           updated vector y. */
+
+/*  INCY   - INTEGER. */
+/*           On entry, INCY specifies the increment for the elements of */
+/*           Y. INCY must not be zero. */
+/*           Unchanged on exit. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  Level 2 Blas routine. */
+
+/*  -- Written on 22-October-1986. */
+/*     Jack Dongarra, Argonne National Lab. */
+/*     Jeremy Du Croz, Nag Central Office. */
+/*     Sven Hammarling, Nag Central Office. */
+/*     Richard Hanson, Sandia National Labs. */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --x;
+    --y;
+
+    /* Function Body */
+    info = 0;
+    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
+	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
+	    ) {
+	info = 1;
+    } else if (*m < 0) {
+	info = 2;
+    } else if (*n < 0) {
+	info = 3;
+    } else if (*lda < max(1,*m)) {
+	info = 6;
+    } else if (*incx == 0) {
+	info = 8;
+    } else if (*incy == 0) {
+	info = 11;
+    }
+    if (info != 0) {
+	return 0;
+    }
+
+/*     Quick return if possible. */
+
+    if (*m == 0 || *n == 0 || *alpha == 0.f && *beta == 1.f) {
+	return 0;
+    }
+
+/*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
+/*     up the start points in  X  and  Y. */
+
+    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+	lenx = *n;
+	leny = *m;
+    } else {
+	lenx = *m;
+	leny = *n;
+    }
+    if (*incx > 0) {
+	kx = 1;
+    } else {
+	kx = 1 - (lenx - 1) * *incx;
+    }
+    if (*incy > 0) {
+	ky = 1;
+    } else {
+	ky = 1 - (leny - 1) * *incy;
+    }
+
+/*     Start the operations. In this version the elements of A are */
+/*     accessed sequentially with one pass through A. */
+
+/*     First form  y := beta*y. */
+
+    if (*beta != 1.f) {
+	if (*incy == 1) {
+	    if (*beta == 0.f) {
+		i__1 = leny;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    y[i__] = 0.f;
+/* L10: */
+		}
+	    } else {
+		i__1 = leny;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    y[i__] = *beta * y[i__];
+/* L20: */
+		}
+	    }
+	} else {
+	    iy = ky;
+	    if (*beta == 0.f) {
+		i__1 = leny;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    y[iy] = 0.f;
+		    iy += *incy;
+/* L30: */
+		}
+	    } else {
+		i__1 = leny;
+		for (i__ = 1; i__ <= i__1; ++i__) {
+		    y[iy] = *beta * y[iy];
+		    iy += *incy;
+/* L40: */
+		}
+	    }
+	}
+    }
+    if (*alpha == 0.f) {
+	return 0;
+    }
+    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
+
+/*        Form  y := alpha*A*x + y. */
+
+	jx = kx;
+	if (*incy == 1) {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[jx] != 0.f) {
+		    temp = *alpha * x[jx];
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			y[i__] += temp * a[i__ + j * a_dim1];
+/* L50: */
+		    }
+		}
+		jx += *incx;
+/* L60: */
+	    }
+	} else {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[jx] != 0.f) {
+		    temp = *alpha * x[jx];
+		    iy = ky;
+		    i__2 = *m;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			y[iy] += temp * a[i__ + j * a_dim1];
+			iy += *incy;
+/* L70: */
+		    }
+		}
+		jx += *incx;
+/* L80: */
+	    }
+	}
+    } else {
+
+/*        Form  y := alpha*A'*x + y. */
+
+	jy = ky;
+	if (*incx == 1) {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		temp = 0.f;
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    temp += a[i__ + j * a_dim1] * x[i__];
+/* L90: */
+		}
+		y[jy] += *alpha * temp;
+		jy += *incy;
+/* L100: */
+	    }
+	} else {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		temp = 0.f;
+		ix = kx;
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    temp += a[i__ + j * a_dim1] * x[ix];
+		    ix += *incx;
+/* L110: */
+		}
+		y[jy] += *alpha * temp;
+		jy += *incy;
+/* L120: */
+	    }
+	}
+    }
+
+    return 0;
+
+/*     End of SGEMV . */
+
+} /* sgemv_ */
+
+/* Subroutine */ int sger_(integer *m, integer *n, real *alpha, real *x, 
+	integer *incx, real *y, integer *incy, real *a, integer *lda)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+
+    /* Local variables */
+    static integer i__, j, ix, jy, kx, info;
+    static real temp;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SGER   performs the rank 1 operation */
+
+/*     A := alpha*x*y' + A, */
+
+/*  where alpha is a scalar, x is an m element vector, y is an n element */
+/*  vector and A is an m by n matrix. */
+
+/*  Arguments */
+/*  ========== */
+
+/*  M      - INTEGER. */
+/*           On entry, M specifies the number of rows of the matrix A. */
+/*           M must be at least zero. */
+/*           Unchanged on exit. */
+
+/*  N      - INTEGER. */
+/*           On entry, N specifies the number of columns of the matrix A. */
+/*           N must be at least zero. */
+/*           Unchanged on exit. */
+
+/*  ALPHA  - REAL            . */
+/*           On entry, ALPHA specifies the scalar alpha. */
+/*           Unchanged on exit. */
+
+/*  X      - REAL             array of dimension at least */
+/*           ( 1 + ( m - 1 )*abs( INCX ) ). */
+/*           Before entry, the incremented array X must contain the m */
+/*           element vector x. */
+/*           Unchanged on exit. */
+
+/*  INCX   - INTEGER. */
+/*           On entry, INCX specifies the increment for the elements of */
+/*           X. INCX must not be zero. */
+/*           Unchanged on exit. */
+
+/*  Y      - REAL             array of dimension at least */
+/*           ( 1 + ( n - 1 )*abs( INCY ) ). */
+/*           Before entry, the incremented array Y must contain the n */
+/*           element vector y. */
+/*           Unchanged on exit. */
+
+/*  INCY   - INTEGER. */
+/*           On entry, INCY specifies the increment for the elements of */
+/*           Y. INCY must not be zero. */
+/*           Unchanged on exit. */
+
+/*  A      - REAL             array of DIMENSION ( LDA, n ). */
+/*           Before entry, the leading m by n part of the array A must */
+/*           contain the matrix of coefficients. On exit, A is */
+/*           overwritten by the updated matrix. */
+
+/*  LDA    - INTEGER. */
+/*           On entry, LDA specifies the first dimension of A as declared */
+/*           in the calling (sub) program. LDA must be at least */
+/*           max( 1, m ). */
+/*           Unchanged on exit. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  Level 2 Blas routine. */
+
+/*  -- Written on 22-October-1986. */
+/*     Jack Dongarra, Argonne National Lab. */
+/*     Jeremy Du Croz, Nag Central Office. */
+/*     Sven Hammarling, Nag Central Office. */
+/*     Richard Hanson, Sandia National Labs. */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    --x;
+    --y;
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+
+    /* Function Body */
+    info = 0;
+    if (*m < 0) {
+	info = 1;
+    } else if (*n < 0) {
+	info = 2;
+    } else if (*incx == 0) {
+	info = 5;
+    } else if (*incy == 0) {
+	info = 7;
+    } else if (*lda < max(1,*m)) {
+	info = 9;
+    }
+    if (info != 0) {
+	return 0;
+    }
+
+/*     Quick return if possible. */
+
+    if (*m == 0 || *n == 0 || *alpha == 0.f) {
+	return 0;
+    }
+
+/*     Start the operations. In this version the elements of A are */
+/*     accessed sequentially with one pass through A. */
+
+    if (*incy > 0) {
+	jy = 1;
+    } else {
+	jy = 1 - (*n - 1) * *incy;
+    }
+    if (*incx == 1) {
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (y[jy] != 0.f) {
+		temp = *alpha * y[jy];
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    a[i__ + j * a_dim1] += x[i__] * temp;
+/* L10: */
+		}
+	    }
+	    jy += *incy;
+/* L20: */
+	}
+    } else {
+	if (*incx > 0) {
+	    kx = 1;
+	} else {
+	    kx = 1 - (*m - 1) * *incx;
+	}
+	i__1 = *n;
+	for (j = 1; j <= i__1; ++j) {
+	    if (y[jy] != 0.f) {
+		temp = *alpha * y[jy];
+		ix = kx;
+		i__2 = *m;
+		for (i__ = 1; i__ <= i__2; ++i__) {
+		    a[i__ + j * a_dim1] += x[ix] * temp;
+		    ix += *incx;
+/* L30: */
+		}
+	    }
+	    jy += *incy;
+/* L40: */
+	}
+    }
+
+    return 0;
+
+/*     End of SGER  . */
+
+} /* sger_ */
+
+
+/* sisnan.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+logical sisnan_(real *sin__)
+{
+    /* System generated locals */
+    logical ret_val;
+
+    /* Local variables */
+    extern logical slaisnan_(real *, real *);
+
+
+/*  -- LAPACK auxiliary routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SISNAN returns .TRUE. if its argument is NaN, and .FALSE. */
+/*  otherwise.  To be replaced by the Fortran 2003 intrinsic in the */
+/*  future. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  SIN      (input) REAL */
+/*          Input to test for NaN. */
+
+/*  ===================================================================== */
+
+/*  .. External Functions .. */
+/*  .. */
+/*  .. Executable Statements .. */
+    ret_val = slaisnan_(sin__, sin__);
+    return ret_val;
+} /* sisnan_ */
+
+
+logical slaisnan_(real *sin1, real *sin2)
+{
+    /* System generated locals */
+    logical ret_val;
+
+
+/*  -- LAPACK auxiliary routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  This routine is not for general use.  It exists solely to avoid */
+/*  over-optimization in SISNAN. */
+
+/*  SLAISNAN checks for NaNs by comparing its two arguments for */
+/*  inequality.  NaN is the only floating-point value where NaN != NaN */
+/*  returns .TRUE.  To check for NaNs, pass the same variable as both */
+/*  arguments. */
+
+/*  A compiler must assume that the two arguments are */
+/*  not the same variable, and the test will not be optimized away. */
+/*  Interprocedural or whole-program optimization may delete this */
+/*  test.  The ISNAN functions will be replaced by the correct */
+/*  Fortran 03 intrinsic once the intrinsic is widely available. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  SIN1     (input) REAL */
+/*  SIN2     (input) REAL */
+/*          Two numbers to compare for inequality. */
+
+/*  ===================================================================== */
+
+/*  .. Executable Statements .. */
+    ret_val = *sin1 != *sin2;
+    return ret_val;
+} /* slaisnan_ */
+
+/* slasyf.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Table of constant values */
+
+static real c_b8 = -1.f;
+static real c_b9 = 1.f;
+
+/* Subroutine */ int slasyf_(char *uplo, integer *n, integer *nb, integer *kb,
+	 real *a, integer *lda, integer *ipiv, real *w, integer *ldw, integer 
+	*info, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, w_dim1, w_offset, i__1, i__2, i__3, i__4, i__5;
+    real r__1, r__2, r__3;
+
+    /* Builtin functions */
+    double sqrt(doublereal);
+
+    /* Local variables */
+    static integer j, k;
+    static real t, r1, d11, d21, d22;
+    static integer jb, jj, kk, jp, kp, kw, kkw, imax, jmax;
+    static real alpha;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
+	    sgemm_(char *, char *, integer *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    ftnlen, ftnlen), sgemv_(char *, integer *, integer *, real *, 
+	    real *, integer *, real *, integer *, real *, real *, integer *, 
+	    ftnlen);
+    static integer kstep;
+    extern /* Subroutine */ int scopy_(integer *, real *, integer *, real *, 
+	    integer *), sswap_(integer *, real *, integer *, real *, integer *
+	    );
+    static real absakk;
+    extern integer isamax_(integer *, real *, integer *);
+    static real colmax, rowmax;
+
+
+/*  -- LAPACK routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SLASYF computes a partial factorization of a real symmetric matrix A */
+/*  using the Bunch-Kaufman diagonal pivoting method. The partial */
+/*  factorization has the form: */
+
+/*  A  =  ( I  U12 ) ( A11  0  ) (  I    0   )  if UPLO = 'U', or: */
+/*        ( 0  U22 ) (  0   D  ) ( U12' U22' ) */
+
+/*  A  =  ( L11  0 ) (  D   0  ) ( L11' L21' )  if UPLO = 'L' */
+/*        ( L21  I ) (  0  A22 ) (  0    I   ) */
+
+/*  where the order of D is at most NB. The actual order is returned in */
+/*  the argument KB, and is either NB or NB-1, or N if N <= NB. */
+
+/*  SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code */
+/*  (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or */
+/*  A22 (if UPLO = 'L'). */
+
+/*  Arguments */
+/*  ========= */
+
+/*  UPLO    (input) CHARACTER*1 */
+/*          Specifies whether the upper or lower triangular part of the */
+/*          symmetric matrix A is stored: */
+/*          = 'U':  Upper triangular */
+/*          = 'L':  Lower triangular */
+
+/*  N       (input) INTEGER */
+/*          The order of the matrix A.  N >= 0. */
+
+/*  NB      (input) INTEGER */
+/*          The maximum number of columns of the matrix A that should be */
+/*          factored.  NB should be at least 2 to allow for 2-by-2 pivot */
+/*          blocks. */
+
+/*  KB      (output) INTEGER */
+/*          The number of columns of A that were actually factored. */
+/*          KB is either NB-1 or NB, or N if N <= NB. */
+
+/*  A       (input/output) REAL array, dimension (LDA,N) */
+/*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading */
+/*          n-by-n upper triangular part of A contains the upper */
+/*          triangular part of the matrix A, and the strictly lower */
+/*          triangular part of A is not referenced.  If UPLO = 'L', the */
+/*          leading n-by-n lower triangular part of A contains the lower */
+/*          triangular part of the matrix A, and the strictly upper */
+/*          triangular part of A is not referenced. */
+/*          On exit, A contains details of the partial factorization. */
+
+/*  LDA     (input) INTEGER */
+/*          The leading dimension of the array A.  LDA >= max(1,N). */
+
+/*  IPIV    (output) INTEGER array, dimension (N) */
+/*          Details of the interchanges and the block structure of D. */
+/*          If UPLO = 'U', only the last KB elements of IPIV are set; */
+/*          if UPLO = 'L', only the first KB elements are set. */
+
+/*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were */
+/*          interchanged and D(k,k) is a 1-by-1 diagonal block. */
+/*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and */
+/*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) */
+/*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) = */
+/*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were */
+/*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. */
+
+/*  W       (workspace) REAL array, dimension (LDW,NB) */
+
+/*  LDW     (input) INTEGER */
+/*          The leading dimension of the array W.  LDW >= max(1,N). */
+
+/*  INFO    (output) INTEGER */
+/*          = 0: successful exit */
+/*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization */
+/*               has been completed, but the block diagonal matrix D is */
+/*               exactly singular. */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ipiv;
+    w_dim1 = *ldw;
+    w_offset = 1 + w_dim1;
+    w -= w_offset;
+
+    /* Function Body */
+    *info = 0;
+
+/*     Initialize ALPHA for use in choosing pivot block size. */
+
+    alpha = (sqrt(17.f) + 1.f) / 8.f;
+
+    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+
+/*        Factorize the trailing columns of A using the upper triangle */
+/*        of A and working backwards, and compute the matrix W = U12*D */
+/*        for use in updating A11 */
+
+/*        K is the main loop index, decreasing from N in steps of 1 or 2 */
+
+/*        KW is the column of W which corresponds to column K of A */
+
+	k = *n;
+L10:
+	kw = *nb + k - *n;
+
+/*        Exit from loop */
+
+	if (k <= *n - *nb + 1 && *nb < *n || k < 1) {
+	    goto L30;
+	}
+
+/*        Copy column K of A to column KW of W and update it */
+
+	scopy_(&k, &a[k * a_dim1 + 1], &c__1, &w[kw * w_dim1 + 1], &c__1);
+	if (k < *n) {
+	    i__1 = *n - k;
+	    sgemv_("No transpose", &k, &i__1, &c_b8, &a[(k + 1) * a_dim1 + 1],
+		     lda, &w[k + (kw + 1) * w_dim1], ldw, &c_b9, &w[kw * 
+		    w_dim1 + 1], &c__1, (ftnlen)12);
+	}
+
+	kstep = 1;
+
+/*        Determine rows and columns to be interchanged and whether */
+/*        a 1-by-1 or 2-by-2 pivot block will be used */
+
+	absakk = (r__1 = w[k + kw * w_dim1], dabs(r__1));
+
+/*        IMAX is the row-index of the largest off-diagonal element in */
+/*        column K, and COLMAX is its absolute value */
+
+	if (k > 1) {
+	    i__1 = k - 1;
+	    imax = isamax_(&i__1, &w[kw * w_dim1 + 1], &c__1);
+	    colmax = (r__1 = w[imax + kw * w_dim1], dabs(r__1));
+	} else {
+	    colmax = 0.f;
+	}
+
+	if (dmax(absakk,colmax) == 0.f) {
+
+/*           Column K is zero: set INFO and continue */
+
+	    if (*info == 0) {
+		*info = k;
+	    }
+	    kp = k;
+	} else {
+	    if (absakk >= alpha * colmax) {
+
+/*              no interchange, use 1-by-1 pivot block */
+
+		kp = k;
+	    } else {
+
+/*              Copy column IMAX to column KW-1 of W and update it */
+
+		scopy_(&imax, &a[imax * a_dim1 + 1], &c__1, &w[(kw - 1) * 
+			w_dim1 + 1], &c__1);
+		i__1 = k - imax;
+		scopy_(&i__1, &a[imax + (imax + 1) * a_dim1], lda, &w[imax + 
+			1 + (kw - 1) * w_dim1], &c__1);
+		if (k < *n) {
+		    i__1 = *n - k;
+		    sgemv_("No transpose", &k, &i__1, &c_b8, &a[(k + 1) * 
+			    a_dim1 + 1], lda, &w[imax + (kw + 1) * w_dim1], 
+			    ldw, &c_b9, &w[(kw - 1) * w_dim1 + 1], &c__1, (
+			    ftnlen)12);
+		}
+
+/*              JMAX is the column-index of the largest off-diagonal */
+/*              element in row IMAX, and ROWMAX is its absolute value */
+
+		i__1 = k - imax;
+		jmax = imax + isamax_(&i__1, &w[imax + 1 + (kw - 1) * w_dim1],
+			 &c__1);
+		rowmax = (r__1 = w[jmax + (kw - 1) * w_dim1], dabs(r__1));
+		if (imax > 1) {
+		    i__1 = imax - 1;
+		    jmax = isamax_(&i__1, &w[(kw - 1) * w_dim1 + 1], &c__1);
+/* Computing MAX */
+		    r__2 = rowmax, r__3 = (r__1 = w[jmax + (kw - 1) * w_dim1],
+			     dabs(r__1));
+		    rowmax = dmax(r__2,r__3);
+		}
+
+		if (absakk >= alpha * colmax * (colmax / rowmax)) {
+
+/*                 no interchange, use 1-by-1 pivot block */
+
+		    kp = k;
+		} else if ((r__1 = w[imax + (kw - 1) * w_dim1], dabs(r__1)) >=
+			 alpha * rowmax) {
+
+/*                 interchange rows and columns K and IMAX, use 1-by-1 */
+/*                 pivot block */
+
+		    kp = imax;
+
+/*                 copy column KW-1 of W to column KW */
+
+		    scopy_(&k, &w[(kw - 1) * w_dim1 + 1], &c__1, &w[kw * 
+			    w_dim1 + 1], &c__1);
+		} else {
+
+/*                 interchange rows and columns K-1 and IMAX, use 2-by-2 */
+/*                 pivot block */
+
+		    kp = imax;
+		    kstep = 2;
+		}
+	    }
+
+	    kk = k - kstep + 1;
+	    kkw = *nb + kk - *n;
+
+/*           Updated column KP is already stored in column KKW of W */
+
+	    if (kp != kk) {
+
+/*              Copy non-updated column KK to column KP */
+
+		a[kp + k * a_dim1] = a[kk + k * a_dim1];
+		i__1 = k - 1 - kp;
+		scopy_(&i__1, &a[kp + 1 + kk * a_dim1], &c__1, &a[kp + (kp + 
+			1) * a_dim1], lda);
+		scopy_(&kp, &a[kk * a_dim1 + 1], &c__1, &a[kp * a_dim1 + 1], &
+			c__1);
+
+/*              Interchange rows KK and KP in last KK columns of A and W */
+
+		i__1 = *n - kk + 1;
+		sswap_(&i__1, &a[kk + kk * a_dim1], lda, &a[kp + kk * a_dim1],
+			 lda);
+		i__1 = *n - kk + 1;
+		sswap_(&i__1, &w[kk + kkw * w_dim1], ldw, &w[kp + kkw * 
+			w_dim1], ldw);
+	    }
+
+	    if (kstep == 1) {
+
+/*              1-by-1 pivot block D(k): column KW of W now holds */
+
+/*              W(k) = U(k)*D(k) */
+
+/*              where U(k) is the k-th column of U */
+
+/*              Store U(k) in column k of A */
+
+		scopy_(&k, &w[kw * w_dim1 + 1], &c__1, &a[k * a_dim1 + 1], &
+			c__1);
+		r1 = 1.f / a[k + k * a_dim1];
+		i__1 = k - 1;
+		sscal_(&i__1, &r1, &a[k * a_dim1 + 1], &c__1);
+	    } else {
+
+/*              2-by-2 pivot block D(k): columns KW and KW-1 of W now */
+/*              hold */
+
+/*              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k) */
+
+/*              where U(k) and U(k-1) are the k-th and (k-1)-th columns */
+/*              of U */
+
+		if (k > 2) {
+
+/*                 Store U(k) and U(k-1) in columns k and k-1 of A */
+
+		    d21 = w[k - 1 + kw * w_dim1];
+		    d11 = w[k + kw * w_dim1] / d21;
+		    d22 = w[k - 1 + (kw - 1) * w_dim1] / d21;
+		    t = 1.f / (d11 * d22 - 1.f);
+		    d21 = t / d21;
+		    i__1 = k - 2;
+		    for (j = 1; j <= i__1; ++j) {
+			a[j + (k - 1) * a_dim1] = d21 * (d11 * w[j + (kw - 1) 
+				* w_dim1] - w[j + kw * w_dim1]);
+			a[j + k * a_dim1] = d21 * (d22 * w[j + kw * w_dim1] - 
+				w[j + (kw - 1) * w_dim1]);
+/* L20: */
+		    }
+		}
+
+/*              Copy D(k) to A */
+
+		a[k - 1 + (k - 1) * a_dim1] = w[k - 1 + (kw - 1) * w_dim1];
+		a[k - 1 + k * a_dim1] = w[k - 1 + kw * w_dim1];
+		a[k + k * a_dim1] = w[k + kw * w_dim1];
+	    }
+	}
+
+/*        Store details of the interchanges in IPIV */
+
+	if (kstep == 1) {
+	    ipiv[k] = kp;
+	} else {
+	    ipiv[k] = -kp;
+	    ipiv[k - 1] = -kp;
+	}
+
+/*        Decrease K and return to the start of the main loop */
+
+	k -= kstep;
+	goto L10;
+
+L30:
+
+/*        Update the upper triangle of A11 (= A(1:k,1:k)) as */
+
+/*        A11 := A11 - U12*D*U12' = A11 - U12*W' */
+
+/*        computing blocks of NB columns at a time */
+
+	i__1 = -(*nb);
+	for (j = (k - 1) / *nb * *nb + 1; i__1 < 0 ? j >= 1 : j <= 1; j += 
+		i__1) {
+/* Computing MIN */
+	    i__2 = *nb, i__3 = k - j + 1;
+	    jb = min(i__2,i__3);
+
+/*           Update the upper triangle of the diagonal block */
+
+	    i__2 = j + jb - 1;
+	    for (jj = j; jj <= i__2; ++jj) {
+		i__3 = jj - j + 1;
+		i__4 = *n - k;
+		sgemv_("No transpose", &i__3, &i__4, &c_b8, &a[j + (k + 1) * 
+			a_dim1], lda, &w[jj + (kw + 1) * w_dim1], ldw, &c_b9, 
+			&a[j + jj * a_dim1], &c__1, (ftnlen)12);
+/* L40: */
+	    }
+
+/*           Update the rectangular superdiagonal block */
+
+	    i__2 = j - 1;
+	    i__3 = *n - k;
+	    sgemm_("No transpose", "Transpose", &i__2, &jb, &i__3, &c_b8, &a[(
+		    k + 1) * a_dim1 + 1], lda, &w[j + (kw + 1) * w_dim1], ldw,
+		     &c_b9, &a[j * a_dim1 + 1], lda, (ftnlen)12, (ftnlen)9);
+/* L50: */
+	}
+
+/*        Put U12 in standard form by partially undoing the interchanges */
+/*        in columns k+1:n */
+
+	j = k + 1;
+L60:
+	jj = j;
+	jp = ipiv[j];
+	if (jp < 0) {
+	    jp = -jp;
+	    ++j;
+	}
+	++j;
+	if (jp != jj && j <= *n) {
+	    i__1 = *n - j + 1;
+	    sswap_(&i__1, &a[jp + j * a_dim1], lda, &a[jj + j * a_dim1], lda);
+	}
+	if (j <= *n) {
+	    goto L60;
+	}
+
+/*        Set KB to the number of columns factorized */
+
+	*kb = *n - k;
+
+    } else {
+
+/*        Factorize the leading columns of A using the lower triangle */
+/*        of A and working forwards, and compute the matrix W = L21*D */
+/*        for use in updating A22 */
+
+/*        K is the main loop index, increasing from 1 in steps of 1 or 2 */
+
+	k = 1;
+L70:
+
+/*        Exit from loop */
+
+	if (k >= *nb && *nb < *n || k > *n) {
+	    goto L90;
+	}
+
+/*        Copy column K of A to column K of W and update it */
+
+	i__1 = *n - k + 1;
+	scopy_(&i__1, &a[k + k * a_dim1], &c__1, &w[k + k * w_dim1], &c__1);
+	i__1 = *n - k + 1;
+	i__2 = k - 1;
+	sgemv_("No transpose", &i__1, &i__2, &c_b8, &a[k + a_dim1], lda, &w[k 
+		+ w_dim1], ldw, &c_b9, &w[k + k * w_dim1], &c__1, (ftnlen)12);
+
+	kstep = 1;
+
+/*        Determine rows and columns to be interchanged and whether */
+/*        a 1-by-1 or 2-by-2 pivot block will be used */
+
+	absakk = (r__1 = w[k + k * w_dim1], dabs(r__1));
+
+/*        IMAX is the row-index of the largest off-diagonal element in */
+/*        column K, and COLMAX is its absolute value */
+
+	if (k < *n) {
+	    i__1 = *n - k;
+	    imax = k + isamax_(&i__1, &w[k + 1 + k * w_dim1], &c__1);
+	    colmax = (r__1 = w[imax + k * w_dim1], dabs(r__1));
+	} else {
+	    colmax = 0.f;
+	}
+
+	if (dmax(absakk,colmax) == 0.f) {
+
+/*           Column K is zero: set INFO and continue */
+
+	    if (*info == 0) {
+		*info = k;
+	    }
+	    kp = k;
+	} else {
+	    if (absakk >= alpha * colmax) {
+
+/*              no interchange, use 1-by-1 pivot block */
+
+		kp = k;
+	    } else {
+
+/*              Copy column IMAX to column K+1 of W and update it */
+
+		i__1 = imax - k;
+		scopy_(&i__1, &a[imax + k * a_dim1], lda, &w[k + (k + 1) * 
+			w_dim1], &c__1);
+		i__1 = *n - imax + 1;
+		scopy_(&i__1, &a[imax + imax * a_dim1], &c__1, &w[imax + (k + 
+			1) * w_dim1], &c__1);
+		i__1 = *n - k + 1;
+		i__2 = k - 1;
+		sgemv_("No transpose", &i__1, &i__2, &c_b8, &a[k + a_dim1], 
+			lda, &w[imax + w_dim1], ldw, &c_b9, &w[k + (k + 1) * 
+			w_dim1], &c__1, (ftnlen)12);
+
+/*              JMAX is the column-index of the largest off-diagonal */
+/*              element in row IMAX, and ROWMAX is its absolute value */
+
+		i__1 = imax - k;
+		jmax = k - 1 + isamax_(&i__1, &w[k + (k + 1) * w_dim1], &c__1)
+			;
+		rowmax = (r__1 = w[jmax + (k + 1) * w_dim1], dabs(r__1));
+		if (imax < *n) {
+		    i__1 = *n - imax;
+		    jmax = imax + isamax_(&i__1, &w[imax + 1 + (k + 1) * 
+			    w_dim1], &c__1);
+/* Computing MAX */
+		    r__2 = rowmax, r__3 = (r__1 = w[jmax + (k + 1) * w_dim1], 
+			    dabs(r__1));
+		    rowmax = dmax(r__2,r__3);
+		}
+
+		if (absakk >= alpha * colmax * (colmax / rowmax)) {
+
+/*                 no interchange, use 1-by-1 pivot block */
+
+		    kp = k;
+		} else if ((r__1 = w[imax + (k + 1) * w_dim1], dabs(r__1)) >= 
+			alpha * rowmax) {
+
+/*                 interchange rows and columns K and IMAX, use 1-by-1 */
+/*                 pivot block */
+
+		    kp = imax;
+
+/*                 copy column K+1 of W to column K */
+
+		    i__1 = *n - k + 1;
+		    scopy_(&i__1, &w[k + (k + 1) * w_dim1], &c__1, &w[k + k * 
+			    w_dim1], &c__1);
+		} else {
+
+/*                 interchange rows and columns K+1 and IMAX, use 2-by-2 */
+/*                 pivot block */
+
+		    kp = imax;
+		    kstep = 2;
+		}
+	    }
+
+	    kk = k + kstep - 1;
+
+/*           Updated column KP is already stored in column KK of W */
+
+	    if (kp != kk) {
+
+/*              Copy non-updated column KK to column KP */
+
+		a[kp + k * a_dim1] = a[kk + k * a_dim1];
+		i__1 = kp - k - 1;
+		scopy_(&i__1, &a[k + 1 + kk * a_dim1], &c__1, &a[kp + (k + 1) 
+			* a_dim1], lda);
+		i__1 = *n - kp + 1;
+		scopy_(&i__1, &a[kp + kk * a_dim1], &c__1, &a[kp + kp * 
+			a_dim1], &c__1);
+
+/*              Interchange rows KK and KP in first KK columns of A and W */
+
+		sswap_(&kk, &a[kk + a_dim1], lda, &a[kp + a_dim1], lda);
+		sswap_(&kk, &w[kk + w_dim1], ldw, &w[kp + w_dim1], ldw);
+	    }
+
+	    if (kstep == 1) {
+
+/*              1-by-1 pivot block D(k): column k of W now holds */
+
+/*              W(k) = L(k)*D(k) */
+
+/*              where L(k) is the k-th column of L */
+
+/*              Store L(k) in column k of A */
+
+		i__1 = *n - k + 1;
+		scopy_(&i__1, &w[k + k * w_dim1], &c__1, &a[k + k * a_dim1], &
+			c__1);
+		if (k < *n) {
+		    r1 = 1.f / a[k + k * a_dim1];
+		    i__1 = *n - k;
+		    sscal_(&i__1, &r1, &a[k + 1 + k * a_dim1], &c__1);
+		}
+	    } else {
+
+/*              2-by-2 pivot block D(k): columns k and k+1 of W now hold */
+
+/*              ( W(k) W(k+1) ) = ( L(k) L(k+1) )*D(k) */
+
+/*              where L(k) and L(k+1) are the k-th and (k+1)-th columns */
+/*              of L */
+
+		if (k < *n - 1) {
+
+/*                 Store L(k) and L(k+1) in columns k and k+1 of A */
+
+		    d21 = w[k + 1 + k * w_dim1];
+		    d11 = w[k + 1 + (k + 1) * w_dim1] / d21;
+		    d22 = w[k + k * w_dim1] / d21;
+		    t = 1.f / (d11 * d22 - 1.f);
+		    d21 = t / d21;
+		    i__1 = *n;
+		    for (j = k + 2; j <= i__1; ++j) {
+			a[j + k * a_dim1] = d21 * (d11 * w[j + k * w_dim1] - 
+				w[j + (k + 1) * w_dim1]);
+			a[j + (k + 1) * a_dim1] = d21 * (d22 * w[j + (k + 1) *
+				 w_dim1] - w[j + k * w_dim1]);
+/* L80: */
+		    }
+		}
+
+/*              Copy D(k) to A */
+
+		a[k + k * a_dim1] = w[k + k * w_dim1];
+		a[k + 1 + k * a_dim1] = w[k + 1 + k * w_dim1];
+		a[k + 1 + (k + 1) * a_dim1] = w[k + 1 + (k + 1) * w_dim1];
+	    }
+	}
+
+/*        Store details of the interchanges in IPIV */
+
+	if (kstep == 1) {
+	    ipiv[k] = kp;
+	} else {
+	    ipiv[k] = -kp;
+	    ipiv[k + 1] = -kp;
+	}
+
+/*        Increase K and return to the start of the main loop */
+
+	k += kstep;
+	goto L70;
+
+L90:
+
+/*        Update the lower triangle of A22 (= A(k:n,k:n)) as */
+
+/*        A22 := A22 - L21*D*L21' = A22 - L21*W' */
+
+/*        computing blocks of NB columns at a time */
+
+	i__1 = *n;
+	i__2 = *nb;
+	for (j = k; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
+/* Computing MIN */
+	    i__3 = *nb, i__4 = *n - j + 1;
+	    jb = min(i__3,i__4);
+
+/*           Update the lower triangle of the diagonal block */
+
+	    i__3 = j + jb - 1;
+	    for (jj = j; jj <= i__3; ++jj) {
+		i__4 = j + jb - jj;
+		i__5 = k - 1;
+		sgemv_("No transpose", &i__4, &i__5, &c_b8, &a[jj + a_dim1], 
+			lda, &w[jj + w_dim1], ldw, &c_b9, &a[jj + jj * a_dim1]
+			, &c__1, (ftnlen)12);
+/* L100: */
+	    }
+
+/*           Update the rectangular subdiagonal block */
+
+	    if (j + jb <= *n) {
+		i__3 = *n - j - jb + 1;
+		i__4 = k - 1;
+		sgemm_("No transpose", "Transpose", &i__3, &jb, &i__4, &c_b8, 
+			&a[j + jb + a_dim1], lda, &w[j + w_dim1], ldw, &c_b9, 
+			&a[j + jb + j * a_dim1], lda, (ftnlen)12, (ftnlen)9);
+	    }
+/* L110: */
+	}
+
+/*        Put L21 in standard form by partially undoing the interchanges */
+/*        in columns 1:k-1 */
+
+	j = k - 1;
+L120:
+	jj = j;
+	jp = ipiv[j];
+	if (jp < 0) {
+	    jp = -jp;
+	    --j;
+	}
+	--j;
+	if (jp != jj && j >= 1) {
+	    sswap_(&j, &a[jp + a_dim1], lda, &a[jj + a_dim1], lda);
+	}
+	if (j >= 1) {
+	    goto L120;
+	}
+
+/*        Set KB to the number of columns factorized */
+
+	*kb = k - 1;
+
+    }
+    return 0;
+
+/*     End of SLASYF */
+
+} /* slasyf_ */
+
+/* ../BLAS/SRC/sscal.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int sscal_(integer *n, real *sa, real *sx, integer *incx)
+{
+    /* System generated locals */
+    integer i__1, i__2;
+
+    /* Local variables */
+    static integer i__, m, mp1, nincx;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*     scales a vector by a constant. */
+/*     uses unrolled loops for increment equal to 1. */
+
+/*  Further Details */
+/*  =============== */
+
+/*     jack dongarra, linpack, 3/11/78. */
+/*     modified 3/93 to return if incx .le. 0. */
+/*     modified 12/3/93, array(1) declarations changed to array(*) */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+    /* Parameter adjustments */
+    --sx;
+
+    /* Function Body */
+    if (*n <= 0 || *incx <= 0) {
+	return 0;
+    }
+    if (*incx == 1) {
+	goto L20;
+    }
+
+/*        code for increment not equal to 1 */
+
+    nincx = *n * *incx;
+    i__1 = nincx;
+    i__2 = *incx;
+    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
+	sx[i__] = *sa * sx[i__];
+/* L10: */
+    }
+    return 0;
+
+/*        code for increment equal to 1 */
+
+
+/*        clean-up loop */
+
+L20:
+    m = *n % 5;
+    if (m == 0) {
+	goto L40;
+    }
+    i__2 = m;
+    for (i__ = 1; i__ <= i__2; ++i__) {
+	sx[i__] = *sa * sx[i__];
+/* L30: */
+    }
+    if (*n < 5) {
+	return 0;
+    }
+L40:
+    mp1 = m + 1;
+    i__2 = *n;
+    for (i__ = mp1; i__ <= i__2; i__ += 5) {
+	sx[i__] = *sa * sx[i__];
+	sx[i__ + 1] = *sa * sx[i__ + 1];
+	sx[i__ + 2] = *sa * sx[i__ + 2];
+	sx[i__ + 3] = *sa * sx[i__ + 3];
+	sx[i__ + 4] = *sa * sx[i__ + 4];
+/* L50: */
+    }
+    return 0;
+} /* sscal_ */
+
+/* ../BLAS/SRC/sswap.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int sswap_(integer *n, real *sx, integer *incx, real *sy, 
+	integer *incy)
+{
+    /* System generated locals */
+    integer i__1;
+
+    /* Local variables */
+    static integer i__, m, ix, iy, mp1;
+    static real stemp;
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*     interchanges two vectors. */
+/*     uses unrolled loops for increments equal to 1. */
+
+/*  Further Details */
+/*  =============== */
+
+/*     jack dongarra, linpack, 3/11/78. */
+/*     modified 12/3/93, array(1) declarations changed to array(*) */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+    /* Parameter adjustments */
+    --sy;
+    --sx;
+
+    /* Function Body */
+    if (*n <= 0) {
+	return 0;
+    }
+    if (*incx == 1 && *incy == 1) {
+	goto L20;
+    }
+
+/*       code for unequal increments or equal increments not equal */
+/*         to 1 */
+
+    ix = 1;
+    iy = 1;
+    if (*incx < 0) {
+	ix = (-(*n) + 1) * *incx + 1;
+    }
+    if (*incy < 0) {
+	iy = (-(*n) + 1) * *incy + 1;
+    }
+    i__1 = *n;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	stemp = sx[ix];
+	sx[ix] = sy[iy];
+	sy[iy] = stemp;
+	ix += *incx;
+	iy += *incy;
+/* L10: */
+    }
+    return 0;
+
+/*       code for both increments equal to 1 */
+
+
+/*       clean-up loop */
+
+L20:
+    m = *n % 3;
+    if (m == 0) {
+	goto L40;
+    }
+    i__1 = m;
+    for (i__ = 1; i__ <= i__1; ++i__) {
+	stemp = sx[i__];
+	sx[i__] = sy[i__];
+	sy[i__] = stemp;
+/* L30: */
+    }
+    if (*n < 3) {
+	return 0;
+    }
+L40:
+    mp1 = m + 1;
+    i__1 = *n;
+    for (i__ = mp1; i__ <= i__1; i__ += 3) {
+	stemp = sx[i__];
+	sx[i__] = sy[i__];
+	sy[i__] = stemp;
+	stemp = sx[i__ + 1];
+	sx[i__ + 1] = sy[i__ + 1];
+	sy[i__ + 1] = stemp;
+	stemp = sx[i__ + 2];
+	sx[i__ + 2] = sy[i__ + 2];
+	sy[i__ + 2] = stemp;
+/* L50: */
+    }
+    return 0;
+} /* sswap_ */
+
+/* ../BLAS/SRC/ssyr.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int ssyr_(char *uplo, integer *n, real *alpha, real *x, 
+	integer *incx, real *a, integer *lda, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+
+    /* Local variables */
+    static integer i__, j, ix, jx, kx, info;
+    static real temp;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SSYR   performs the symmetric rank 1 operation */
+
+/*     A := alpha*x*x' + A, */
+
+/*  where alpha is a real scalar, x is an n element vector and A is an */
+/*  n by n symmetric matrix. */
+
+/*  Arguments */
+/*  ========== */
+
+/*  UPLO   - CHARACTER*1. */
+/*           On entry, UPLO specifies whether the upper or lower */
+/*           triangular part of the array A is to be referenced as */
+/*           follows: */
+
+/*              UPLO = 'U' or 'u'   Only the upper triangular part of A */
+/*                                  is to be referenced. */
+
+/*              UPLO = 'L' or 'l'   Only the lower triangular part of A */
+/*                                  is to be referenced. */
+
+/*           Unchanged on exit. */
+
+/*  N      - INTEGER. */
+/*           On entry, N specifies the order of the matrix A. */
+/*           N must be at least zero. */
+/*           Unchanged on exit. */
+
+/*  ALPHA  - REAL            . */
+/*           On entry, ALPHA specifies the scalar alpha. */
+/*           Unchanged on exit. */
+
+/*  X      - REAL             array of dimension at least */
+/*           ( 1 + ( n - 1 )*abs( INCX ) ). */
+/*           Before entry, the incremented array X must contain the n */
+/*           element vector x. */
+/*           Unchanged on exit. */
+
+/*  INCX   - INTEGER. */
+/*           On entry, INCX specifies the increment for the elements of */
+/*           X. INCX must not be zero. */
+/*           Unchanged on exit. */
+
+/*  A      - REAL             array of DIMENSION ( LDA, n ). */
+/*           Before entry with  UPLO = 'U' or 'u', the leading n by n */
+/*           upper triangular part of the array A must contain the upper */
+/*           triangular part of the symmetric matrix and the strictly */
+/*           lower triangular part of A is not referenced. On exit, the */
+/*           upper triangular part of the array A is overwritten by the */
+/*           upper triangular part of the updated matrix. */
+/*           Before entry with UPLO = 'L' or 'l', the leading n by n */
+/*           lower triangular part of the array A must contain the lower */
+/*           triangular part of the symmetric matrix and the strictly */
+/*           upper triangular part of A is not referenced. On exit, the */
+/*           lower triangular part of the array A is overwritten by the */
+/*           lower triangular part of the updated matrix. */
+
+/*  LDA    - INTEGER. */
+/*           On entry, LDA specifies the first dimension of A as declared */
+/*           in the calling (sub) program. LDA must be at least */
+/*           max( 1, n ). */
+/*           Unchanged on exit. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  Level 2 Blas routine. */
+
+/*  -- Written on 22-October-1986. */
+/*     Jack Dongarra, Argonne National Lab. */
+/*     Jeremy Du Croz, Nag Central Office. */
+/*     Sven Hammarling, Nag Central Office. */
+/*     Richard Hanson, Sandia National Labs. */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    --x;
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+
+    /* Function Body */
+    info = 0;
+    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
+	    ftnlen)1, (ftnlen)1)) {
+	info = 1;
+    } else if (*n < 0) {
+	info = 2;
+    } else if (*incx == 0) {
+	info = 5;
+    } else if (*lda < max(1,*n)) {
+	info = 7;
+    }
+    if (info != 0) {
+	return 0;
+    }
+
+/*     Quick return if possible. */
+
+    if (*n == 0 || *alpha == 0.f) {
+	return 0;
+    }
+
+/*     Set the start point in X if the increment is not unity. */
+
+    if (*incx <= 0) {
+	kx = 1 - (*n - 1) * *incx;
+    } else if (*incx != 1) {
+	kx = 1;
+    }
+
+/*     Start the operations. In this version the elements of A are */
+/*     accessed sequentially with one pass through the triangular part */
+/*     of A. */
+
+    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
+
+/*        Form  A  when A is stored in upper triangle. */
+
+	if (*incx == 1) {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[j] != 0.f) {
+		    temp = *alpha * x[j];
+		    i__2 = j;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			a[i__ + j * a_dim1] += x[i__] * temp;
+/* L10: */
+		    }
+		}
+/* L20: */
+	    }
+	} else {
+	    jx = kx;
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[jx] != 0.f) {
+		    temp = *alpha * x[jx];
+		    ix = kx;
+		    i__2 = j;
+		    for (i__ = 1; i__ <= i__2; ++i__) {
+			a[i__ + j * a_dim1] += x[ix] * temp;
+			ix += *incx;
+/* L30: */
+		    }
+		}
+		jx += *incx;
+/* L40: */
+	    }
+	}
+    } else {
+
+/*        Form  A  when A is stored in lower triangle. */
+
+	if (*incx == 1) {
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[j] != 0.f) {
+		    temp = *alpha * x[j];
+		    i__2 = *n;
+		    for (i__ = j; i__ <= i__2; ++i__) {
+			a[i__ + j * a_dim1] += x[i__] * temp;
+/* L50: */
+		    }
+		}
+/* L60: */
+	    }
+	} else {
+	    jx = kx;
+	    i__1 = *n;
+	    for (j = 1; j <= i__1; ++j) {
+		if (x[jx] != 0.f) {
+		    temp = *alpha * x[jx];
+		    ix = jx;
+		    i__2 = *n;
+		    for (i__ = j; i__ <= i__2; ++i__) {
+			a[i__ + j * a_dim1] += x[ix] * temp;
+			ix += *incx;
+/* L70: */
+		    }
+		}
+		jx += *incx;
+/* L80: */
+	    }
+	}
+    }
+
+    return 0;
+
+/*     End of SSYR  . */
+
+} /* ssyr_ */
+
+/* ssysv.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Table of constant values */
+
+static integer c_n1 = -1;
+
+/* Subroutine */ int ssysv_(char *uplo, integer *n, integer *nrhs, real *a, 
+	integer *lda, integer *ipiv, real *b, integer *ldb, real *work, 
+	integer *lwork, integer *info, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, b_dim1, b_offset, i__1;
+
+    /* Local variables */
+    static integer nb;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
+	    integer *, integer *, ftnlen, ftnlen);
+    static integer lwkopt;
+    static logical lquery;
+    extern /* Subroutine */ int ssytrf_(char *, integer *, real *, integer *, 
+	    integer *, real *, integer *, integer *, ftnlen), ssytrs_(char *, 
+	    integer *, integer *, real *, integer *, integer *, real *, 
+	    integer *, integer *, ftnlen);
+
+
+/*  -- LAPACK driver routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SSYSV computes the solution to a real system of linear equations */
+/*     A * X = B, */
+/*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS */
+/*  matrices. */
+
+/*  The diagonal pivoting method is used to factor A as */
+/*     A = U * D * U**T,  if UPLO = 'U', or */
+/*     A = L * D * L**T,  if UPLO = 'L', */
+/*  where U (or L) is a product of permutation and unit upper (lower) */
+/*  triangular matrices, and D is symmetric and block diagonal with */
+/*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then */
+/*  used to solve the system of equations A * X = B. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  UPLO    (input) CHARACTER*1 */
+/*          = 'U':  Upper triangle of A is stored; */
+/*          = 'L':  Lower triangle of A is stored. */
+
+/*  N       (input) INTEGER */
+/*          The number of linear equations, i.e., the order of the */
+/*          matrix A.  N >= 0. */
+
+/*  NRHS    (input) INTEGER */
+/*          The number of right hand sides, i.e., the number of columns */
+/*          of the matrix B.  NRHS >= 0. */
+
+/*  A       (input/output) REAL array, dimension (LDA,N) */
+/*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading */
+/*          N-by-N upper triangular part of A contains the upper */
+/*          triangular part of the matrix A, and the strictly lower */
+/*          triangular part of A is not referenced.  If UPLO = 'L', the */
+/*          leading N-by-N lower triangular part of A contains the lower */
+/*          triangular part of the matrix A, and the strictly upper */
+/*          triangular part of A is not referenced. */
+
+/*          On exit, if INFO = 0, the block diagonal matrix D and the */
+/*          multipliers used to obtain the factor U or L from the */
+/*          factorization A = U*D*U**T or A = L*D*L**T as computed by */
+/*          SSYTRF. */
+
+/*  LDA     (input) INTEGER */
+/*          The leading dimension of the array A.  LDA >= max(1,N). */
+
+/*  IPIV    (output) INTEGER array, dimension (N) */
+/*          Details of the interchanges and the block structure of D, as */
+/*          determined by SSYTRF.  If IPIV(k) > 0, then rows and columns */
+/*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1 */
+/*          diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, */
+/*          then rows and columns k-1 and -IPIV(k) were interchanged and */
+/*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and */
+/*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and */
+/*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2 */
+/*          diagonal block. */
+
+/*  B       (input/output) REAL array, dimension (LDB,NRHS) */
+/*          On entry, the N-by-NRHS right hand side matrix B. */
+/*          On exit, if INFO = 0, the N-by-NRHS solution matrix X. */
+
+/*  LDB     (input) INTEGER */
+/*          The leading dimension of the array B.  LDB >= max(1,N). */
+
+/*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK)) */
+/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. */
+
+/*  LWORK   (input) INTEGER */
+/*          The length of WORK.  LWORK >= 1, and for best performance */
+/*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for */
+/*          SSYTRF. */
+
+/*          If LWORK = -1, then a workspace query is assumed; the routine */
+/*          only calculates the optimal size of the WORK array, returns */
+/*          this value as the first entry of the WORK array, and no error */
+/*          message related to LWORK is issued by XERBLA. */
+
+/*  INFO    (output) INTEGER */
+/*          = 0: successful exit */
+/*          < 0: if INFO = -i, the i-th argument had an illegal value */
+/*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization */
+/*               has been completed, but the block diagonal matrix D is */
+/*               exactly singular, so the solution could not be computed. */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ipiv;
+    b_dim1 = *ldb;
+    b_offset = 1 + b_dim1;
+    b -= b_offset;
+    --work;
+
+    /* Function Body */
+    *info = 0;
+    lquery = *lwork == -1;
+    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
+	    ftnlen)1, (ftnlen)1)) {
+	*info = -1;
+    } else if (*n < 0) {
+	*info = -2;
+    } else if (*nrhs < 0) {
+	*info = -3;
+    } else if (*lda < max(1,*n)) {
+	*info = -5;
+    } else if (*ldb < max(1,*n)) {
+	*info = -8;
+    } else if (*lwork < 1 && ! lquery) {
+	*info = -10;
+    }
+
+    if (*info == 0) {
+	if (*n == 0) {
+	    lwkopt = 1;
+	} else {
+	    nb = ilaenv_(&c__1, "SSYTRF", uplo, n, &c_n1, &c_n1, &c_n1, (
+		    ftnlen)6, (ftnlen)1);
+	    lwkopt = *n * nb;
+	}
+	work[1] = (real) lwkopt;
+    }
+
+    if (*info != 0) {
+	i__1 = -(*info);
+	return 0;
+    } else if (lquery) {
+	return 0;
+    }
+
+/*     Compute the factorization A = U*D*U' or A = L*D*L'. */
+
+    ssytrf_(uplo, n, &a[a_offset], lda, &ipiv[1], &work[1], lwork, info, (
+	    ftnlen)1);
+//    if (*info == 0) {
+
+/*        Solve the system A*X = B, overwriting B with X. */
+
+	ssytrs_(uplo, n, nrhs, &a[a_offset], lda, &ipiv[1], &b[b_offset], ldb,
+		 info, (ftnlen)1);
+
+//    }
+
+    work[1] = (real) lwkopt;
+
+    return 0;
+
+/*     End of SSYSV */
+
+} /* ssysv_ */
+
+/* ssytf2.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Subroutine */ int ssytf2_(char *uplo, integer *n, real *a, integer *lda, 
+	integer *ipiv, integer *info, ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+    real r__1, r__2, r__3;
+
+    /* Builtin functions */
+    double sqrt(doublereal);
+
+    /* Local variables */
+    static integer i__, j, k;
+    static real t, r1, d11, d12, d21, d22;
+    static integer kk, kp;
+    static real wk, wkm1, wkp1;
+    static integer imax, jmax;
+    extern /* Subroutine */ int ssyr_(char *, integer *, real *, real *, 
+	    integer *, real *, integer *, ftnlen);
+    static real alpha;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *);
+    static integer kstep;
+    static logical upper;
+    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
+	    integer *);
+    static real absakk;
+    extern integer isamax_(integer *, real *, integer *);
+    static real colmax;
+    extern logical sisnan_(real *);
+    static real rowmax;
+
+
+/*  -- LAPACK routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SSYTF2 computes the factorization of a real symmetric matrix A using */
+/*  the Bunch-Kaufman diagonal pivoting method: */
+
+/*     A = U*D*U'  or  A = L*D*L' */
+
+/*  where U (or L) is a product of permutation and unit upper (lower) */
+/*  triangular matrices, U' is the transpose of U, and D is symmetric and */
+/*  block diagonal with 1-by-1 and 2-by-2 diagonal blocks. */
+
+/*  This is the unblocked version of the algorithm, calling Level 2 BLAS. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  UPLO    (input) CHARACTER*1 */
+/*          Specifies whether the upper or lower triangular part of the */
+/*          symmetric matrix A is stored: */
+/*          = 'U':  Upper triangular */
+/*          = 'L':  Lower triangular */
+
+/*  N       (input) INTEGER */
+/*          The order of the matrix A.  N >= 0. */
+
+/*  A       (input/output) REAL array, dimension (LDA,N) */
+/*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading */
+/*          n-by-n upper triangular part of A contains the upper */
+/*          triangular part of the matrix A, and the strictly lower */
+/*          triangular part of A is not referenced.  If UPLO = 'L', the */
+/*          leading n-by-n lower triangular part of A contains the lower */
+/*          triangular part of the matrix A, and the strictly upper */
+/*          triangular part of A is not referenced. */
+
+/*          On exit, the block diagonal matrix D and the multipliers used */
+/*          to obtain the factor U or L (see below for further details). */
+
+/*  LDA     (input) INTEGER */
+/*          The leading dimension of the array A.  LDA >= max(1,N). */
+
+/*  IPIV    (output) INTEGER array, dimension (N) */
+/*          Details of the interchanges and the block structure of D. */
+/*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were */
+/*          interchanged and D(k,k) is a 1-by-1 diagonal block. */
+/*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and */
+/*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) */
+/*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) = */
+/*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were */
+/*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. */
+
+/*  INFO    (output) INTEGER */
+/*          = 0: successful exit */
+/*          < 0: if INFO = -k, the k-th argument had an illegal value */
+/*          > 0: if INFO = k, D(k,k) is exactly zero.  The factorization */
+/*               has been completed, but the block diagonal matrix D is */
+/*               exactly singular, and division by zero will occur if it */
+/*               is used to solve a system of equations. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  09-29-06 - patch from */
+/*    Bobby Cheng, MathWorks */
+
+/*    Replace l.204 and l.372 */
+/*         IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN */
+/*    by */
+/*         IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. SISNAN(ABSAKK) ) THEN */
+
+/*  01-01-96 - Based on modifications by */
+/*    J. Lewis, Boeing Computer Services Company */
+/*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA */
+/*  1-96 - Based on modifications by J. Lewis, Boeing Computer Services */
+/*         Company */
+
+/*  If UPLO = 'U', then A = U*D*U', where */
+/*     U = P(n)*U(n)* ... *P(k)U(k)* ..., */
+/*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to */
+/*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 */
+/*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as */
+/*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such */
+/*  that if the diagonal block D(k) is of order s (s = 1 or 2), then */
+
+/*             (   I    v    0   )   k-s */
+/*     U(k) =  (   0    I    0   )   s */
+/*             (   0    0    I   )   n-k */
+/*                k-s   s   n-k */
+
+/*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k). */
+/*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k), */
+/*  and A(k,k), and v overwrites A(1:k-2,k-1:k). */
+
+/*  If UPLO = 'L', then A = L*D*L', where */
+/*     L = P(1)*L(1)* ... *P(k)*L(k)* ..., */
+/*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to */
+/*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 */
+/*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as */
+/*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such */
+/*  that if the diagonal block D(k) is of order s (s = 1 or 2), then */
+
+/*             (   I    0     0   )  k-1 */
+/*     L(k) =  (   0    I     0   )  s */
+/*             (   0    v     I   )  n-k-s+1 */
+/*                k-1   s  n-k-s+1 */
+
+/*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k). */
+/*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k), */
+/*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1). */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ipiv;
+
+    /* Function Body */
+    *info = 0;
+    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+	*info = -1;
+    } else if (*n < 0) {
+	*info = -2;
+    } else if (*lda < max(1,*n)) {
+	*info = -4;
+    }
+    if (*info != 0) {
+	i__1 = -(*info);
+	return 0;
+    }
+
+/*     Initialize ALPHA for use in choosing pivot block size. */
+
+    alpha = (sqrt(17.f) + 1.f) / 8.f;
+
+    if (upper) {
+
+/*        Factorize A as U*D*U' using the upper triangle of A */
+
+/*        K is the main loop index, decreasing from N to 1 in steps of */
+/*        1 or 2 */
+
+	k = *n;
+L10:
+
+/*        If K < 1, exit from loop */
+
+	if (k < 1) {
+	    goto L70;
+	}
+	kstep = 1;
+
+/*        Determine rows and columns to be interchanged and whether */
+/*        a 1-by-1 or 2-by-2 pivot block will be used */
+
+	absakk = (r__1 = a[k + k * a_dim1], dabs(r__1));
+
+/*        IMAX is the row-index of the largest off-diagonal element in */
+/*        column K, and COLMAX is its absolute value */
+
+	if (k > 1) {
+	    i__1 = k - 1;
+	    imax = isamax_(&i__1, &a[k * a_dim1 + 1], &c__1);
+	    colmax = (r__1 = a[imax + k * a_dim1], dabs(r__1));
+	} else {
+	    colmax = 0.f;
+	}
+
+	if (dmax(absakk,colmax) == 0.f || sisnan_(&absakk)) {
+
+/*           Column K is zero or contains a NaN: set INFO and continue */
+
+	    if (*info == 0) {
+		*info = k;
+	    }
+	    kp = k;
+	} else {
+	    if (absakk >= alpha * colmax) {
+
+/*              no interchange, use 1-by-1 pivot block */
+
+		kp = k;
+	    } else {
+
+/*              JMAX is the column-index of the largest off-diagonal */
+/*              element in row IMAX, and ROWMAX is its absolute value */
+
+		i__1 = k - imax;
+		jmax = imax + isamax_(&i__1, &a[imax + (imax + 1) * a_dim1], 
+			lda);
+		rowmax = (r__1 = a[imax + jmax * a_dim1], dabs(r__1));
+		if (imax > 1) {
+		    i__1 = imax - 1;
+		    jmax = isamax_(&i__1, &a[imax * a_dim1 + 1], &c__1);
+/* Computing MAX */
+		    r__2 = rowmax, r__3 = (r__1 = a[jmax + imax * a_dim1], 
+			    dabs(r__1));
+		    rowmax = dmax(r__2,r__3);
+		}
+
+		if (absakk >= alpha * colmax * (colmax / rowmax)) {
+
+/*                 no interchange, use 1-by-1 pivot block */
+
+		    kp = k;
+		} else if ((r__1 = a[imax + imax * a_dim1], dabs(r__1)) >= 
+			alpha * rowmax) {
+
+/*                 interchange rows and columns K and IMAX, use 1-by-1 */
+/*                 pivot block */
+
+		    kp = imax;
+		} else {
+
+/*                 interchange rows and columns K-1 and IMAX, use 2-by-2 */
+/*                 pivot block */
+
+		    kp = imax;
+		    kstep = 2;
+		}
+	    }
+
+	    kk = k - kstep + 1;
+	    if (kp != kk) {
+
+/*              Interchange rows and columns KK and KP in the leading */
+/*              submatrix A(1:k,1:k) */
+
+		i__1 = kp - 1;
+		sswap_(&i__1, &a[kk * a_dim1 + 1], &c__1, &a[kp * a_dim1 + 1],
+			 &c__1);
+		i__1 = kk - kp - 1;
+		sswap_(&i__1, &a[kp + 1 + kk * a_dim1], &c__1, &a[kp + (kp + 
+			1) * a_dim1], lda);
+		t = a[kk + kk * a_dim1];
+		a[kk + kk * a_dim1] = a[kp + kp * a_dim1];
+		a[kp + kp * a_dim1] = t;
+		if (kstep == 2) {
+		    t = a[k - 1 + k * a_dim1];
+		    a[k - 1 + k * a_dim1] = a[kp + k * a_dim1];
+		    a[kp + k * a_dim1] = t;
+		}
+	    }
+
+/*           Update the leading submatrix */
+
+	    if (kstep == 1) {
+
+/*              1-by-1 pivot block D(k): column k now holds */
+
+/*              W(k) = U(k)*D(k) */
+
+/*              where U(k) is the k-th column of U */
+
+/*              Perform a rank-1 update of A(1:k-1,1:k-1) as */
+
+/*              A := A - U(k)*D(k)*U(k)' = A - W(k)*1/D(k)*W(k)' */
+
+		r1 = 1.f / a[k + k * a_dim1];
+		i__1 = k - 1;
+		r__1 = -r1;
+		ssyr_(uplo, &i__1, &r__1, &a[k * a_dim1 + 1], &c__1, &a[
+			a_offset], lda, (ftnlen)1);
+
+/*              Store U(k) in column k */
+
+		i__1 = k - 1;
+		sscal_(&i__1, &r1, &a[k * a_dim1 + 1], &c__1);
+	    } else {
+
+/*              2-by-2 pivot block D(k): columns k and k-1 now hold */
+
+/*              ( W(k-1) W(k) ) = ( U(k-1) U(k) )*D(k) */
+
+/*              where U(k) and U(k-1) are the k-th and (k-1)-th columns */
+/*              of U */
+
+/*              Perform a rank-2 update of A(1:k-2,1:k-2) as */
+
+/*              A := A - ( U(k-1) U(k) )*D(k)*( U(k-1) U(k) )' */
+/*                 = A - ( W(k-1) W(k) )*inv(D(k))*( W(k-1) W(k) )' */
+
+		if (k > 2) {
+
+		    d12 = a[k - 1 + k * a_dim1];
+		    d22 = a[k - 1 + (k - 1) * a_dim1] / d12;
+		    d11 = a[k + k * a_dim1] / d12;
+		    t = 1.f / (d11 * d22 - 1.f);
+		    d12 = t / d12;
+
+		    for (j = k - 2; j >= 1; --j) {
+			wkm1 = d12 * (d11 * a[j + (k - 1) * a_dim1] - a[j + k 
+				* a_dim1]);
+			wk = d12 * (d22 * a[j + k * a_dim1] - a[j + (k - 1) * 
+				a_dim1]);
+			for (i__ = j; i__ >= 1; --i__) {
+			    a[i__ + j * a_dim1] = a[i__ + j * a_dim1] - a[i__ 
+				    + k * a_dim1] * wk - a[i__ + (k - 1) * 
+				    a_dim1] * wkm1;
+/* L20: */
+			}
+			a[j + k * a_dim1] = wk;
+			a[j + (k - 1) * a_dim1] = wkm1;
+/* L30: */
+		    }
+
+		}
+
+	    }
+	}
+
+/*        Store details of the interchanges in IPIV */
+
+	if (kstep == 1) {
+	    ipiv[k] = kp;
+	} else {
+	    ipiv[k] = -kp;
+	    ipiv[k - 1] = -kp;
+	}
+
+/*        Decrease K and return to the start of the main loop */
+
+	k -= kstep;
+	goto L10;
+
+    } else {
+
+/*        Factorize A as L*D*L' using the lower triangle of A */
+
+/*        K is the main loop index, increasing from 1 to N in steps of */
+/*        1 or 2 */
+
+	k = 1;
+L40:
+
+/*        If K > N, exit from loop */
+
+	if (k > *n) {
+	    goto L70;
+	}
+	kstep = 1;
+
+/*        Determine rows and columns to be interchanged and whether */
+/*        a 1-by-1 or 2-by-2 pivot block will be used */
+
+	absakk = (r__1 = a[k + k * a_dim1], dabs(r__1));
+
+/*        IMAX is the row-index of the largest off-diagonal element in */
+/*        column K, and COLMAX is its absolute value */
+
+	if (k < *n) {
+	    i__1 = *n - k;
+	    imax = k + isamax_(&i__1, &a[k + 1 + k * a_dim1], &c__1);
+	    colmax = (r__1 = a[imax + k * a_dim1], dabs(r__1));
+	} else {
+	    colmax = 0.f;
+	}
+
+	if (dmax(absakk,colmax) == 0.f || sisnan_(&absakk)) {
+
+/*           Column K is zero or contains a NaN: set INFO and continue */
+
+	    if (*info == 0) {
+		*info = k;
+	    }
+	    kp = k;
+	} else {
+	    if (absakk >= alpha * colmax) {
+
+/*              no interchange, use 1-by-1 pivot block */
+
+		kp = k;
+	    } else {
+
+/*              JMAX is the column-index of the largest off-diagonal */
+/*              element in row IMAX, and ROWMAX is its absolute value */
+
+		i__1 = imax - k;
+		jmax = k - 1 + isamax_(&i__1, &a[imax + k * a_dim1], lda);
+		rowmax = (r__1 = a[imax + jmax * a_dim1], dabs(r__1));
+		if (imax < *n) {
+		    i__1 = *n - imax;
+		    jmax = imax + isamax_(&i__1, &a[imax + 1 + imax * a_dim1],
+			     &c__1);
+/* Computing MAX */
+		    r__2 = rowmax, r__3 = (r__1 = a[jmax + imax * a_dim1], 
+			    dabs(r__1));
+		    rowmax = dmax(r__2,r__3);
+		}
+
+		if (absakk >= alpha * colmax * (colmax / rowmax)) {
+
+/*                 no interchange, use 1-by-1 pivot block */
+
+		    kp = k;
+		} else if ((r__1 = a[imax + imax * a_dim1], dabs(r__1)) >= 
+			alpha * rowmax) {
+
+/*                 interchange rows and columns K and IMAX, use 1-by-1 */
+/*                 pivot block */
+
+		    kp = imax;
+		} else {
+
+/*                 interchange rows and columns K+1 and IMAX, use 2-by-2 */
+/*                 pivot block */
+
+		    kp = imax;
+		    kstep = 2;
+		}
+	    }
+
+	    kk = k + kstep - 1;
+	    if (kp != kk) {
+
+/*              Interchange rows and columns KK and KP in the trailing */
+/*              submatrix A(k:n,k:n) */
+
+		if (kp < *n) {
+		    i__1 = *n - kp;
+		    sswap_(&i__1, &a[kp + 1 + kk * a_dim1], &c__1, &a[kp + 1 
+			    + kp * a_dim1], &c__1);
+		}
+		i__1 = kp - kk - 1;
+		sswap_(&i__1, &a[kk + 1 + kk * a_dim1], &c__1, &a[kp + (kk + 
+			1) * a_dim1], lda);
+		t = a[kk + kk * a_dim1];
+		a[kk + kk * a_dim1] = a[kp + kp * a_dim1];
+		a[kp + kp * a_dim1] = t;
+		if (kstep == 2) {
+		    t = a[k + 1 + k * a_dim1];
+		    a[k + 1 + k * a_dim1] = a[kp + k * a_dim1];
+		    a[kp + k * a_dim1] = t;
+		}
+	    }
+
+/*           Update the trailing submatrix */
+
+	    if (kstep == 1) {
+
+/*              1-by-1 pivot block D(k): column k now holds */
+
+/*              W(k) = L(k)*D(k) */
+
+/*              where L(k) is the k-th column of L */
+
+		if (k < *n) {
+
+/*                 Perform a rank-1 update of A(k+1:n,k+1:n) as */
+
+/*                 A := A - L(k)*D(k)*L(k)' = A - W(k)*(1/D(k))*W(k)' */
+
+		    d11 = 1.f / a[k + k * a_dim1];
+		    i__1 = *n - k;
+		    r__1 = -d11;
+		    ssyr_(uplo, &i__1, &r__1, &a[k + 1 + k * a_dim1], &c__1, &
+			    a[k + 1 + (k + 1) * a_dim1], lda, (ftnlen)1);
+
+/*                 Store L(k) in column K */
+
+		    i__1 = *n - k;
+		    sscal_(&i__1, &d11, &a[k + 1 + k * a_dim1], &c__1);
+		}
+	    } else {
+
+/*              2-by-2 pivot block D(k) */
+
+		if (k < *n - 1) {
+
+/*                 Perform a rank-2 update of A(k+2:n,k+2:n) as */
+
+/*                 A := A - ( (A(k) A(k+1))*D(k)**(-1) ) * (A(k) A(k+1))' */
+
+/*                 where L(k) and L(k+1) are the k-th and (k+1)-th */
+/*                 columns of L */
+
+		    d21 = a[k + 1 + k * a_dim1];
+		    d11 = a[k + 1 + (k + 1) * a_dim1] / d21;
+		    d22 = a[k + k * a_dim1] / d21;
+		    t = 1.f / (d11 * d22 - 1.f);
+		    d21 = t / d21;
+
+		    i__1 = *n;
+		    for (j = k + 2; j <= i__1; ++j) {
+
+			wk = d21 * (d11 * a[j + k * a_dim1] - a[j + (k + 1) * 
+				a_dim1]);
+			wkp1 = d21 * (d22 * a[j + (k + 1) * a_dim1] - a[j + k 
+				* a_dim1]);
+
+			i__2 = *n;
+			for (i__ = j; i__ <= i__2; ++i__) {
+			    a[i__ + j * a_dim1] = a[i__ + j * a_dim1] - a[i__ 
+				    + k * a_dim1] * wk - a[i__ + (k + 1) * 
+				    a_dim1] * wkp1;
+/* L50: */
+			}
+
+			a[j + k * a_dim1] = wk;
+			a[j + (k + 1) * a_dim1] = wkp1;
+
+/* L60: */
+		    }
+		}
+	    }
+	}
+
+/*        Store details of the interchanges in IPIV */
+
+	if (kstep == 1) {
+	    ipiv[k] = kp;
+	} else {
+	    ipiv[k] = -kp;
+	    ipiv[k + 1] = -kp;
+	}
+
+/*        Increase K and return to the start of the main loop */
+
+	k += kstep;
+	goto L40;
+
+    }
+
+L70:
+
+    return 0;
+
+/*     End of SSYTF2 */
+
+} /* ssytf2_ */
+
+/* ssytrf.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Table of constant values */
+
+static integer c__2 = 2;
+
+/* Subroutine */ int ssytrf_(char *uplo, integer *n, real *a, integer *lda, 
+	integer *ipiv, real *work, integer *lwork, integer *info, ftnlen 
+	uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, i__1, i__2;
+
+    /* Local variables */
+    static integer j, k, kb, nb, iws;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    static integer nbmin, iinfo;
+    static logical upper;
+    extern /* Subroutine */ int ssytf2_(char *, integer *, real *, integer *, 
+	    integer *, integer *, ftnlen);
+    extern integer ilaenv_(integer *, char *, char *, integer *, integer *, 
+	    integer *, integer *, ftnlen, ftnlen);
+    extern /* Subroutine */ int slasyf_(char *, integer *, integer *, integer 
+	    *, real *, integer *, integer *, real *, integer *, integer *, 
+	    ftnlen);
+    static integer ldwork, lwkopt;
+    static logical lquery;
+
+
+/*  -- LAPACK routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SSYTRF computes the factorization of a real symmetric matrix A using */
+/*  the Bunch-Kaufman diagonal pivoting method.  The form of the */
+/*  factorization is */
+
+/*     A = U*D*U**T  or  A = L*D*L**T */
+
+/*  where U (or L) is a product of permutation and unit upper (lower) */
+/*  triangular matrices, and D is symmetric and block diagonal with */
+/*  1-by-1 and 2-by-2 diagonal blocks. */
+
+/*  This is the blocked version of the algorithm, calling Level 3 BLAS. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  UPLO    (input) CHARACTER*1 */
+/*          = 'U':  Upper triangle of A is stored; */
+/*          = 'L':  Lower triangle of A is stored. */
+
+/*  N       (input) INTEGER */
+/*          The order of the matrix A.  N >= 0. */
+
+/*  A       (input/output) REAL array, dimension (LDA,N) */
+/*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading */
+/*          N-by-N upper triangular part of A contains the upper */
+/*          triangular part of the matrix A, and the strictly lower */
+/*          triangular part of A is not referenced.  If UPLO = 'L', the */
+/*          leading N-by-N lower triangular part of A contains the lower */
+/*          triangular part of the matrix A, and the strictly upper */
+/*          triangular part of A is not referenced. */
+
+/*          On exit, the block diagonal matrix D and the multipliers used */
+/*          to obtain the factor U or L (see below for further details). */
+
+/*  LDA     (input) INTEGER */
+/*          The leading dimension of the array A.  LDA >= max(1,N). */
+
+/*  IPIV    (output) INTEGER array, dimension (N) */
+/*          Details of the interchanges and the block structure of D. */
+/*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were */
+/*          interchanged and D(k,k) is a 1-by-1 diagonal block. */
+/*          If UPLO = 'U' and IPIV(k) = IPIV(k-1) < 0, then rows and */
+/*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k) */
+/*          is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) = */
+/*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were */
+/*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block. */
+
+/*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK)) */
+/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. */
+
+/*  LWORK   (input) INTEGER */
+/*          The length of WORK.  LWORK >=1.  For best performance */
+/*          LWORK >= N*NB, where NB is the block size returned by ILAENV. */
+
+/*          If LWORK = -1, then a workspace query is assumed; the routine */
+/*          only calculates the optimal size of the WORK array, returns */
+/*          this value as the first entry of the WORK array, and no error */
+/*          message related to LWORK is issued by XERBLA. */
+
+/*  INFO    (output) INTEGER */
+/*          = 0:  successful exit */
+/*          < 0:  if INFO = -i, the i-th argument had an illegal value */
+/*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization */
+/*                has been completed, but the block diagonal matrix D is */
+/*                exactly singular, and division by zero will occur if it */
+/*                is used to solve a system of equations. */
+
+/*  Further Details */
+/*  =============== */
+
+/*  If UPLO = 'U', then A = U*D*U', where */
+/*     U = P(n)*U(n)* ... *P(k)U(k)* ..., */
+/*  i.e., U is a product of terms P(k)*U(k), where k decreases from n to */
+/*  1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 */
+/*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as */
+/*  defined by IPIV(k), and U(k) is a unit upper triangular matrix, such */
+/*  that if the diagonal block D(k) is of order s (s = 1 or 2), then */
+
+/*             (   I    v    0   )   k-s */
+/*     U(k) =  (   0    I    0   )   s */
+/*             (   0    0    I   )   n-k */
+/*                k-s   s   n-k */
+
+/*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k). */
+/*  If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k), */
+/*  and A(k,k), and v overwrites A(1:k-2,k-1:k). */
+
+/*  If UPLO = 'L', then A = L*D*L', where */
+/*     L = P(1)*L(1)* ... *P(k)*L(k)* ..., */
+/*  i.e., L is a product of terms P(k)*L(k), where k increases from 1 to */
+/*  n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1 */
+/*  and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as */
+/*  defined by IPIV(k), and L(k) is a unit lower triangular matrix, such */
+/*  that if the diagonal block D(k) is of order s (s = 1 or 2), then */
+
+/*             (   I    0     0   )  k-1 */
+/*     L(k) =  (   0    I     0   )  s */
+/*             (   0    v     I   )  n-k-s+1 */
+/*                k-1   s  n-k-s+1 */
+
+/*  If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k). */
+/*  If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k), */
+/*  and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1). */
+
+/*  ===================================================================== */
+
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+/*     Test the input parameters. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ipiv;
+    --work;
+
+    /* Function Body */
+    *info = 0;
+    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    lquery = *lwork == -1;
+    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+	*info = -1;
+    } else if (*n < 0) {
+	*info = -2;
+    } else if (*lda < max(1,*n)) {
+	*info = -4;
+    } else if (*lwork < 1 && ! lquery) {
+	*info = -7;
+    }
+
+    if (*info == 0) {
+
+/*        Determine the block size */
+
+	nb = ilaenv_(&c__1, "SSYTRF", uplo, n, &c_n1, &c_n1, &c_n1, (ftnlen)6,
+		 (ftnlen)1);
+	lwkopt = *n * nb;
+	work[1] = (real) lwkopt;
+    }
+
+    if (*info != 0) {
+	i__1 = -(*info);
+	return 0;
+    } else if (lquery) {
+	return 0;
+    }
+
+    nbmin = 2;
+    ldwork = *n;
+    if (nb > 1 && nb < *n) {
+	iws = ldwork * nb;
+	if (*lwork < iws) {
+/* Computing MAX */
+	    i__1 = *lwork / ldwork;
+	    nb = max(i__1,1);
+/* Computing MAX */
+	    i__1 = 2, i__2 = ilaenv_(&c__2, "SSYTRF", uplo, n, &c_n1, &c_n1, &
+		    c_n1, (ftnlen)6, (ftnlen)1);
+	    nbmin = max(i__1,i__2);
+	}
+    } else {
+	iws = 1;
+    }
+    if (nb < nbmin) {
+	nb = *n;
+    }
+
+    if (upper) {
+
+/*        Factorize A as U*D*U' using the upper triangle of A */
+
+/*        K is the main loop index, decreasing from N to 1 in steps of */
+/*        KB, where KB is the number of columns factorized by SLASYF; */
+/*        KB is either NB or NB-1, or K for the last block */
+
+	k = *n;
+L10:
+
+/*        If K < 1, exit from loop */
+
+	if (k < 1) {
+	    goto L40;
+	}
+
+	if (k > nb) {
+
+/*           Factorize columns k-kb+1:k of A and use blocked code to */
+/*           update columns 1:k-kb */
+
+	    slasyf_(uplo, &k, &nb, &kb, &a[a_offset], lda, &ipiv[1], &work[1],
+		     &ldwork, &iinfo, (ftnlen)1);
+	} else {
+
+/*           Use unblocked code to factorize columns 1:k of A */
+
+	    ssytf2_(uplo, &k, &a[a_offset], lda, &ipiv[1], &iinfo, (ftnlen)1);
+	    kb = k;
+	}
+
+/*        Set INFO on the first occurrence of a zero pivot */
+
+	if (*info == 0 && iinfo > 0) {
+	    *info = iinfo;
+	}
+
+/*        Decrease K and return to the start of the main loop */
+
+	k -= kb;
+	goto L10;
+
+    } else {
+
+/*        Factorize A as L*D*L' using the lower triangle of A */
+
+/*        K is the main loop index, increasing from 1 to N in steps of */
+/*        KB, where KB is the number of columns factorized by SLASYF; */
+/*        KB is either NB or NB-1, or N-K+1 for the last block */
+
+	k = 1;
+L20:
+
+/*        If K > N, exit from loop */
+
+	if (k > *n) {
+	    goto L40;
+	}
+
+	if (k <= *n - nb) {
+
+/*           Factorize columns k:k+kb-1 of A and use blocked code to */
+/*           update columns k+kb:n */
+
+	    i__1 = *n - k + 1;
+	    slasyf_(uplo, &i__1, &nb, &kb, &a[k + k * a_dim1], lda, &ipiv[k], 
+		    &work[1], &ldwork, &iinfo, (ftnlen)1);
+	} else {
+
+/*           Use unblocked code to factorize columns k:n of A */
+
+	    i__1 = *n - k + 1;
+	    ssytf2_(uplo, &i__1, &a[k + k * a_dim1], lda, &ipiv[k], &iinfo, (
+		    ftnlen)1);
+	    kb = *n - k + 1;
+	}
+
+/*        Set INFO on the first occurrence of a zero pivot */
+
+	if (*info == 0 && iinfo > 0) {
+	    *info = iinfo + k - 1;
+	}
+
+/*        Adjust IPIV */
+
+	i__1 = k + kb - 1;
+	for (j = k; j <= i__1; ++j) {
+	    if (ipiv[j] > 0) {
+		ipiv[j] = ipiv[j] + k - 1;
+	    } else {
+		ipiv[j] = ipiv[j] - k + 1;
+	    }
+/* L30: */
+	}
+
+/*        Increase K and return to the start of the main loop */
+
+	k += kb;
+	goto L20;
+
+    }
+
+L40:
+    work[1] = (real) lwkopt;
+    return 0;
+
+/*     End of SSYTRF */
+
+} /* ssytrf_ */
+
+/* ssytrs.f -- translated by f2c (version 20090411).
+   You must link the resulting object file with libf2c:
+	on Microsoft Windows system, link with libf2c.lib;
+	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
+	or, if you install libf2c.a in a standard place, with -lf2c -lm
+	-- in that order, at the end of the command line, as in
+		cc *.o -lf2c -lm
+	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,
+
+		http://www.netlib.org/f2c/libf2c.zip
+*/
+
+/* Table of constant values */
+
+static real c_b7 = -1.f;
+static real c_b19 = 1.f;
+
+/* Subroutine */ int ssytrs_(char *uplo, integer *n, integer *nrhs, real *a, 
+	integer *lda, integer *ipiv, real *b, integer *ldb, integer *info, 
+	ftnlen uplo_len)
+{
+    /* System generated locals */
+    integer a_dim1, a_offset, b_dim1, b_offset, i__1;
+    real r__1;
+
+    /* Local variables */
+    static integer j, k;
+    static real ak, bk;
+    static integer kp;
+    static real akm1, bkm1;
+    extern /* Subroutine */ int sger_(integer *, integer *, real *, real *, 
+	    integer *, real *, integer *, real *, integer *);
+    static real akm1k;
+    extern logical lsame_(char *, char *, ftnlen, ftnlen);
+    static real denom;
+    extern /* Subroutine */ int sscal_(integer *, real *, real *, integer *), 
+	    sgemv_(char *, integer *, integer *, real *, real *, integer *, 
+	    real *, integer *, real *, real *, integer *, ftnlen);
+    static logical upper;
+    extern /* Subroutine */ int sswap_(integer *, real *, integer *, real *, 
+	    integer *);
+
+
+/*  -- LAPACK routine (version 3.2) -- */
+/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
+/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
+/*     November 2006 */
+
+/*     .. Scalar Arguments .. */
+/*     .. */
+/*     .. Array Arguments .. */
+/*     .. */
+
+/*  Purpose */
+/*  ======= */
+
+/*  SSYTRS solves a system of linear equations A*X = B with a real */
+/*  symmetric matrix A using the factorization A = U*D*U**T or */
+/*  A = L*D*L**T computed by SSYTRF. */
+
+/*  Arguments */
+/*  ========= */
+
+/*  UPLO    (input) CHARACTER*1 */
+/*          Specifies whether the details of the factorization are stored */
+/*          as an upper or lower triangular matrix. */
+/*          = 'U':  Upper triangular, form is A = U*D*U**T; */
+/*          = 'L':  Lower triangular, form is A = L*D*L**T. */
+
+/*  N       (input) INTEGER */
+/*          The order of the matrix A.  N >= 0. */
+
+/*  NRHS    (input) INTEGER */
+/*          The number of right hand sides, i.e., the number of columns */
+/*          of the matrix B.  NRHS >= 0. */
+
+/*  A       (input) REAL array, dimension (LDA,N) */
+/*          The block diagonal matrix D and the multipliers used to */
+/*          obtain the factor U or L as computed by SSYTRF. */
+
+/*  LDA     (input) INTEGER */
+/*          The leading dimension of the array A.  LDA >= max(1,N). */
+
+/*  IPIV    (input) INTEGER array, dimension (N) */
+/*          Details of the interchanges and the block structure of D */
+/*          as determined by SSYTRF. */
+
+/*  B       (input/output) REAL array, dimension (LDB,NRHS) */
+/*          On entry, the right hand side matrix B. */
+/*          On exit, the solution matrix X. */
+
+/*  LDB     (input) INTEGER */
+/*          The leading dimension of the array B.  LDB >= max(1,N). */
+
+/*  INFO    (output) INTEGER */
+/*          = 0:  successful exit */
+/*          < 0:  if INFO = -i, the i-th argument had an illegal value */
+
+/*  ===================================================================== */
+
+/*     .. Parameters .. */
+/*     .. */
+/*     .. Local Scalars .. */
+/*     .. */
+/*     .. External Functions .. */
+/*     .. */
+/*     .. External Subroutines .. */
+/*     .. */
+/*     .. Intrinsic Functions .. */
+/*     .. */
+/*     .. Executable Statements .. */
+
+    /* Parameter adjustments */
+    a_dim1 = *lda;
+    a_offset = 1 + a_dim1;
+    a -= a_offset;
+    --ipiv;
+    b_dim1 = *ldb;
+    b_offset = 1 + b_dim1;
+    b -= b_offset;
+
+    /* Function Body */
+    *info = 0;
+    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
+    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
+	*info = -1;
+    } else if (*n < 0) {
+	*info = -2;
+    } else if (*nrhs < 0) {
+	*info = -3;
+    } else if (*lda < max(1,*n)) {
+	*info = -5;
+    } else if (*ldb < max(1,*n)) {
+	*info = -8;
+    }
+    if (*info != 0) {
+	i__1 = -(*info);
+	return 0;
+    }
+
+/*     Quick return if possible */
+
+    if (*n == 0 || *nrhs == 0) {
+	return 0;
+    }
+
+    if (upper) {
+
+/*        Solve A*X = B, where A = U*D*U'. */
+
+/*        First solve U*D*X = B, overwriting B with X. */
+
+/*        K is the main loop index, decreasing from N to 1 in steps of */
+/*        1 or 2, depending on the size of the diagonal blocks. */
+
+	k = *n;
+L10:
+
+/*        If K < 1, exit from loop. */
+
+	if (k < 1) {
+	    goto L30;
+	}
+
+	if (ipiv[k] > 0) {
+
+/*           1 x 1 diagonal block */
+
+/*           Interchange rows K and IPIV(K). */
+
+	    kp = ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+
+/*           Multiply by inv(U(K)), where U(K) is the transformation */
+/*           stored in column K of A. */
+
+	    i__1 = k - 1;
+	    sger_(&i__1, nrhs, &c_b7, &a[k * a_dim1 + 1], &c__1, &b[k + 
+		    b_dim1], ldb, &b[b_dim1 + 1], ldb);
+
+/*           Multiply by the inverse of the diagonal block. */
+
+	    r__1 = 1.f / a[k + k * a_dim1];
+	    sscal_(nrhs, &r__1, &b[k + b_dim1], ldb);
+	    --k;
+	} else {
+
+/*           2 x 2 diagonal block */
+
+/*           Interchange rows K-1 and -IPIV(K). */
+
+	    kp = -ipiv[k];
+	    if (kp != k - 1) {
+		sswap_(nrhs, &b[k - 1 + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+
+/*           Multiply by inv(U(K)), where U(K) is the transformation */
+/*           stored in columns K-1 and K of A. */
+
+	    i__1 = k - 2;
+	    sger_(&i__1, nrhs, &c_b7, &a[k * a_dim1 + 1], &c__1, &b[k + 
+		    b_dim1], ldb, &b[b_dim1 + 1], ldb);
+	    i__1 = k - 2;
+	    sger_(&i__1, nrhs, &c_b7, &a[(k - 1) * a_dim1 + 1], &c__1, &b[k - 
+		    1 + b_dim1], ldb, &b[b_dim1 + 1], ldb);
+
+/*           Multiply by the inverse of the diagonal block. */
+
+	    akm1k = a[k - 1 + k * a_dim1];
+	    akm1 = a[k - 1 + (k - 1) * a_dim1] / akm1k;
+	    ak = a[k + k * a_dim1] / akm1k;
+	    denom = akm1 * ak - 1.f;
+	    i__1 = *nrhs;
+	    for (j = 1; j <= i__1; ++j) {
+		bkm1 = b[k - 1 + j * b_dim1] / akm1k;
+		bk = b[k + j * b_dim1] / akm1k;
+		b[k - 1 + j * b_dim1] = (ak * bkm1 - bk) / denom;
+		b[k + j * b_dim1] = (akm1 * bk - bkm1) / denom;
+/* L20: */
+	    }
+	    k += -2;
+	}
+
+	goto L10;
+L30:
+
+/*        Next solve U'*X = B, overwriting B with X. */
+
+/*        K is the main loop index, increasing from 1 to N in steps of */
+/*        1 or 2, depending on the size of the diagonal blocks. */
+
+	k = 1;
+L40:
+
+/*        If K > N, exit from loop. */
+
+	if (k > *n) {
+	    goto L50;
+	}
+
+	if (ipiv[k] > 0) {
+
+/*           1 x 1 diagonal block */
+
+/*           Multiply by inv(U'(K)), where U(K) is the transformation */
+/*           stored in column K of A. */
+
+	    i__1 = k - 1;
+	    sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[b_offset], ldb, &a[k * 
+		    a_dim1 + 1], &c__1, &c_b19, &b[k + b_dim1], ldb, (ftnlen)
+		    9);
+
+/*           Interchange rows K and IPIV(K). */
+
+	    kp = ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+	    ++k;
+	} else {
+
+/*           2 x 2 diagonal block */
+
+/*           Multiply by inv(U'(K+1)), where U(K+1) is the transformation */
+/*           stored in columns K and K+1 of A. */
+
+	    i__1 = k - 1;
+	    sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[b_offset], ldb, &a[k * 
+		    a_dim1 + 1], &c__1, &c_b19, &b[k + b_dim1], ldb, (ftnlen)
+		    9);
+	    i__1 = k - 1;
+	    sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[b_offset], ldb, &a[(k 
+		    + 1) * a_dim1 + 1], &c__1, &c_b19, &b[k + 1 + b_dim1], 
+		    ldb, (ftnlen)9);
+
+/*           Interchange rows K and -IPIV(K). */
+
+	    kp = -ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+	    k += 2;
+	}
+
+	goto L40;
+L50:
+
+	;
+    } else {
+
+/*        Solve A*X = B, where A = L*D*L'. */
+
+/*        First solve L*D*X = B, overwriting B with X. */
+
+/*        K is the main loop index, increasing from 1 to N in steps of */
+/*        1 or 2, depending on the size of the diagonal blocks. */
+
+	k = 1;
+L60:
+
+/*        If K > N, exit from loop. */
+
+	if (k > *n) {
+	    goto L80;
+	}
+
+	if (ipiv[k] > 0) {
+
+/*           1 x 1 diagonal block */
+
+/*           Interchange rows K and IPIV(K). */
+
+	    kp = ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+
+/*           Multiply by inv(L(K)), where L(K) is the transformation */
+/*           stored in column K of A. */
+
+	    if (k < *n) {
+		i__1 = *n - k;
+		sger_(&i__1, nrhs, &c_b7, &a[k + 1 + k * a_dim1], &c__1, &b[k 
+			+ b_dim1], ldb, &b[k + 1 + b_dim1], ldb);
+	    }
+
+/*           Multiply by the inverse of the diagonal block. */
+
+	    r__1 = 1.f / a[k + k * a_dim1];
+	    sscal_(nrhs, &r__1, &b[k + b_dim1], ldb);
+	    ++k;
+	} else {
+
+/*           2 x 2 diagonal block */
+
+/*           Interchange rows K+1 and -IPIV(K). */
+
+	    kp = -ipiv[k];
+	    if (kp != k + 1) {
+		sswap_(nrhs, &b[k + 1 + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+
+/*           Multiply by inv(L(K)), where L(K) is the transformation */
+/*           stored in columns K and K+1 of A. */
+
+	    if (k < *n - 1) {
+		i__1 = *n - k - 1;
+		sger_(&i__1, nrhs, &c_b7, &a[k + 2 + k * a_dim1], &c__1, &b[k 
+			+ b_dim1], ldb, &b[k + 2 + b_dim1], ldb);
+		i__1 = *n - k - 1;
+		sger_(&i__1, nrhs, &c_b7, &a[k + 2 + (k + 1) * a_dim1], &c__1,
+			 &b[k + 1 + b_dim1], ldb, &b[k + 2 + b_dim1], ldb);
+	    }
+
+/*           Multiply by the inverse of the diagonal block. */
+
+	    akm1k = a[k + 1 + k * a_dim1];
+	    akm1 = a[k + k * a_dim1] / akm1k;
+	    ak = a[k + 1 + (k + 1) * a_dim1] / akm1k;
+	    denom = akm1 * ak - 1.f;
+	    i__1 = *nrhs;
+	    for (j = 1; j <= i__1; ++j) {
+		bkm1 = b[k + j * b_dim1] / akm1k;
+		bk = b[k + 1 + j * b_dim1] / akm1k;
+		b[k + j * b_dim1] = (ak * bkm1 - bk) / denom;
+		b[k + 1 + j * b_dim1] = (akm1 * bk - bkm1) / denom;
+/* L70: */
+	    }
+	    k += 2;
+	}
+
+	goto L60;
+L80:
+
+/*        Next solve L'*X = B, overwriting B with X. */
+
+/*        K is the main loop index, decreasing from N to 1 in steps of */
+/*        1 or 2, depending on the size of the diagonal blocks. */
+
+	k = *n;
+L90:
+
+/*        If K < 1, exit from loop. */
+
+	if (k < 1) {
+	    goto L100;
+	}
+
+	if (ipiv[k] > 0) {
+
+/*           1 x 1 diagonal block */
+
+/*           Multiply by inv(L'(K)), where L(K) is the transformation */
+/*           stored in column K of A. */
+
+	    if (k < *n) {
+		i__1 = *n - k;
+		sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[k + 1 + b_dim1], 
+			ldb, &a[k + 1 + k * a_dim1], &c__1, &c_b19, &b[k + 
+			b_dim1], ldb, (ftnlen)9);
+	    }
+
+/*           Interchange rows K and IPIV(K). */
+
+	    kp = ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+	    --k;
+	} else {
+
+/*           2 x 2 diagonal block */
+
+/*           Multiply by inv(L'(K-1)), where L(K-1) is the transformation */
+/*           stored in columns K-1 and K of A. */
+
+	    if (k < *n) {
+		i__1 = *n - k;
+		sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[k + 1 + b_dim1], 
+			ldb, &a[k + 1 + k * a_dim1], &c__1, &c_b19, &b[k + 
+			b_dim1], ldb, (ftnlen)9);
+		i__1 = *n - k;
+		sgemv_("Transpose", &i__1, nrhs, &c_b7, &b[k + 1 + b_dim1], 
+			ldb, &a[k + 1 + (k - 1) * a_dim1], &c__1, &c_b19, &b[
+			k - 1 + b_dim1], ldb, (ftnlen)9);
+	    }
+
+/*           Interchange rows K and -IPIV(K). */
+
+	    kp = -ipiv[k];
+	    if (kp != k) {
+		sswap_(nrhs, &b[k + b_dim1], ldb, &b[kp + b_dim1], ldb);
+	    }
+	    k += -2;
+	}
+
+	goto L90;
+L100:
+	;
+    }
+
+    return 0;
+
+/*     End of SSYTRS */
+
+} /* ssytrs_ */
+
Index: ode/src/robuststep.cpp
===================================================================
--- ode/src/robuststep.cpp	(revision 0)
+++ ode/src/robuststep.cpp	(revision 0)
@@ -0,0 +1,2202 @@
+/*************************************************************************
+ *                                                                       *
+ * Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.       *
+ * All rights reserved.  Email: russ@q12.org   Web: www.q12.org          *
+ *                                                                       *
+ * This library is free software; you can redistribute it and/or         *
+ * modify it under the terms of EITHER:                                  *
+ *   (1) The GNU Lesser General Public License as published by the Free  *
+ *       Software Foundation; either version 2.1 of the License, or (at  *
+ *       your option) any later version. The text of the GNU Lesser      *
+ *       General Public License is included with this library in the     *
+ *       file LICENSE.TXT.                                               *
+ *   (2) The BSD-style license that is included with this library in     *
+ *       the file LICENSE-BSD.TXT.                                       *
+ *                                                                       *
+ * This library is distributed in the hope that it will be useful,       *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *
+ * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *
+ *                                                                       *
+ *************************************************************************/
+
+#include "step.h"
+#include "collision_kernel.h"
+#include "objects.h"
+#include "joints/joint.h"
+#include "joints/contact.h"
+#include <ode/odeconfig.h>
+#include "config.h"
+#include <ode/odemath.h>
+#include <ode/rotation.h>
+#include <ode/timer.h>
+#include <ode/error.h>
+#include <ode/matrix.h>
+#include "util.h"
+#include "optimize.h"
+#include <iostream>
+#include <vector>
+#include <limits>
+#include <boost/shared_array.hpp>
+
+using boost::shared_array;
+using std::vector;
+
+//****************************************************************************
+// misc defines
+#define DEBUG
+
+// memory allocation system
+#ifdef dUSE_MALLOC_FOR_ALLOCA
+unsigned int dMemoryFlag;
+#define REPORT_OUT_OF_MEMORY fprintf(stderr, "Insufficient memory to complete rigid body simulation.  Results will not be accurate.\n")
+
+#define CHECK(p)                                \
+  if (!p) {                                     \
+    dMemoryFlag = d_MEMORY_OUT_OF_MEMORY;       \
+    return;                                     \
+  }
+
+#define ALLOCA(t,v,s)                           \
+  Auto<t> v(malloc(s));                         \
+  CHECK(v)
+
+#else // use alloca()
+
+#define ALLOCA(t,v,s)                           \
+  Auto<t> v( dALLOCA16(s) );
+
+#endif
+
+void dSetSubMat0(dReal* A, int ac, dReal* B, int br, int bc, int sr, int sc);
+void dSetSubMat1(dReal* A, int ac, dReal* B, int br, int bc, int sr, int sc);
+void printMatrix(dReal* A, int m, int n);
+void dCopy(dReal* target, int tstride, dReal* source, int sstride, int n);
+void dNPMultiply0(dReal *A, const dReal *B, const dReal *C, int p, int q, int r);
+void dNPMultiply1(dReal *A, const dReal *B, const dReal *C, int p, int q, int r);
+size_t dxEstimateStepMemoryRequirements(dxBody* const* body, int nb, dxJoint* const* _joint, int _nj);
+
+/* This template should work almost like std::auto_ptr
+ */
+template<class T>
+struct Auto {
+  T *p;
+  Auto(void * q) :
+    p(reinterpret_cast<T*>(q))
+  { }
+
+  ~Auto()
+  {
+#ifdef dUSE_MALLOC_FOR_ALLOCA
+    free(p);
+#endif
+  }
+
+  operator T*() 
+  {
+    return p;
+  }
+  T& operator[] (int i)
+  {
+    return p[i];
+  }
+private:
+  // intentionally undefined, don't use this
+  template<class U>
+  Auto& operator=(const Auto<U>&) const;
+};
+
+
+
+
+
+struct BodyPair
+{
+  int body1;
+  int body2;
+  BodyPair(int b1, int b2) { body1 = b1; body2 = b2; }
+};
+
+struct COptData
+{
+  int m;                     // number of bilateral constraint equations
+  int ml;                    // number of lower-limit constraint equations
+  int mh;                    // number of upper-limit constraint equations
+  int nc;                    // number of contact constraints
+  int nb;                    // number of rigid bodies
+  dReal* I;                  // nb-stacked 3x3 inertia matrices
+  dReal* invI;               // nb-stacked 3x3 inverse inertia matrices
+  dReal* J;                  // the bilateral constraint Jacobian
+  dReal* j_c;                // the r.h.s. of the equation J*v = j_c
+  dReal* Jl;                 // lower-limit bilateral constraint Jacobian
+  dReal* jl_c;               // the r.h.s. of the equation Jl*v >= jl_c
+  dReal* Jh;                 // upper-limit bilateral constraint Jacobian
+  dReal* jh_c;               // the r.h.s. of the equation Jh*v <= jh_c
+  dReal* N;                  // the normal contact constraint Jacobian
+  dReal* n_c;                // the r.h.s. of the equation N*v >= n_c
+  dReal* T1;                 // first tangent direction constraint Jacobian
+  dReal* T2;                 // second tangent direction constraint Jacobian
+  dReal* hfext;              // external forces on the bodies * stepsize
+  dReal* v;                  // velocities of the bodies
+  dReal kappa;               // sum of contact forces for the frictionless prob
+  dReal* mu;                 // vector of friction coefficients
+  dReal* ohess1;             // objective function Hessian (phase I)
+  dReal* ohess2;             // objective function Hessian (phase II)
+  vector<BodyPair> biPairs;  // pairs of bodies for bilateral constraints
+  vector<BodyPair> uniPairs; // pairs of bodies for contact constraints
+  vector<BodyPair> loPairs;  // pairs of bodies for lo-limit bilat. constraints
+  vector<BodyPair> hiPairs;  // pairs of bodies for hi-limit bilat. constraints
+  dxBody* const* bodies;     // vector of bodies
+
+  // work variables (alloc'd automatically)
+  dReal* cn;                 // contact normal impulses
+  dReal* ct1;                // contact tangential direction 1 impulses
+  dReal* ct2;                // contact tangential direction 2 impulses
+  dReal* cv;                 // bilateral joint constraint impulses
+  dReal* cl;                 // impulses for enforcing lower joint limits
+  dReal* ch;                 // impulses for enforcing upper joint limits
+  dReal* Nv;                 // the vector N*v^{n+1}
+  dReal* Mv;                 // the vector inv(M)*v^{n+1}
+  dReal* Jlv;                // the vector Jl*v^{n+1}
+  dReal* Jhv;                // the vector Jh*v^{n+1}
+  dReal* vnp1;               // the vector v^{n+1}
+  dReal* worknb6;            // nb*6-dimensional work vector
+  dReal* worknb6_2;          // nb*6-dimensional work vector
+  dReal* stack1;             // matrix stack: M^{-1}[N' J' Jl' Jh']
+  dReal* stack2;             // matrix stack: M^{-1}[N' T1' T2' J' Jl' Jh']
+  dReal* NStack;             // N*matrix stack
+
+  COptData(int m, int ml, int mh, int nc, int nb)
+  {
+    // store necessary variables
+    this->m = m;
+    this->ml = ml;
+    this->mh = mh;
+    this->nc = nc;
+    this->nb = nb;
+
+    // create work variables
+    cn = new dReal[nc];
+    ct1 = new dReal[nc];
+    ct2 = new dReal[nc];
+    cv = new dReal[m];
+    cl = new dReal[ml];
+    ch = new dReal[mh];
+    Nv = new dReal[nc];
+    Mv = new dReal[nb*6];
+    vnp1 = new dReal[nb*6];
+    worknb6 = new dReal[nb*6];
+    worknb6_2 = new dReal[nb*6];
+    Jlv = new dReal[ml];
+    Jhv = new dReal[mh];
+    stack1 = new dReal[(nc + m + ml + mh)*nb*6];
+    stack2 = new dReal[(nc*3 + m + ml + mh)*nb*6];
+    NStack = new dReal[nc * (nc*3 + m + ml + mh)];
+  }
+
+  ~COptData()
+  {
+    delete [] cn;
+    delete [] ct1;
+    delete [] ct2;
+    delete [] cv;
+    delete [] cl;
+    delete [] ch;
+    delete [] Nv;
+    delete [] Mv;
+    delete [] Jlv;
+    delete [] Jhv;
+    delete [] vnp1;
+    delete [] worknb6;
+    delete [] worknb6_2;
+    delete [] stack1;
+    delete [] stack2;
+    delete [] NStack;
+  }
+};
+
+// estimates memory requirements for robust step
+size_t dxEstimateRobustStepMemoryRequirements(dxBody* const* body, int nb, dxJoint* const* _joint, int _nj)
+{
+  return dxEstimateStepMemoryRequirements(body, nb, _joint, _nj);
+}
+
+// dReal dot product routine with stride
+dReal dot(const dReal* x, int xstride, const dReal* y, int ystride, int n)
+{
+  dReal sum = (dReal) 0.0;
+  for (int i=0; i< n; i++, x+= xstride, y+= ystride)
+    sum += *x * *y;
+  return sum;
+}
+
+// dReal addition routine
+void dAdd(dReal* target, dReal* op1, dReal* op2, int n)
+{
+  for (int i=0; i< n; i++)
+    *target++ = *op1++ + *op2++;
+}
+
+// dReal subtraction routine
+void dSub(dReal* target, dReal* op1, dReal* op2, int n)
+{
+  for (int i=0; i< n; i++)
+    *target++ = *op1++ - *op2++;
+}
+
+// dReal copying routine
+void dCopy(dReal* target, dReal* source, int n)
+{
+  memcpy(target, source, n*sizeof(dReal));
+}
+
+// determines an orthonormal vector
+static void det_orthonormal_vec(dReal* dir, dReal* v)
+{
+  dReal ones[3] = {1, 1, 1};
+  dReal x = dFabs(dir[0]);
+  dReal y = dFabs(dir[1]);
+  dReal z = dFabs(dir[2]);
+  if (x > y)
+  {
+    if (x > z)
+      ones[0] = 0;
+    else
+      ones[2] = 0;
+  }
+  else
+  {
+    if (y > z)
+      ones[1] = 0;
+    else
+      ones[2] = 0;
+  }
+
+  dCROSS(v, =, dir, ones);
+} 
+
+// verifies that all elements of a vector are finite (for debugging/testing)
+static void verifyFinite(dReal* A, int n)
+{
+  for (int i=0; i< n; i++)
+    dIASSERT(!isnan(A[i]) && !isinf(A[i]));
+}
+
+// multiplies a nr x (nb*6) matrix (N, T1, or T2) by a (nb*6) x nc matrix
+static void multSparseMatrix0(dReal* res, dReal* const M, dReal* const v, int nr, int nc, vector<BodyPair>& pairs)
+{
+  dIASSERT(nr == (int) pairs.size());
+
+  // zero out results vector
+  dSetZero(res, nr*nc);
+
+  for (int i=0, j=0; i< nr; i++, j+= 12)
+  {
+    // check for non-existent second body
+    if (pairs[i].body2 >= 0)
+    {
+      // get the two wrenches
+      const dReal* w1 = M + j;
+      const dReal* w2 = w1 + 6;
+
+      for (int col=0; col < nc; col++)
+      {
+        // set the appropriate source pointers from v
+        const dReal* v1 = v + pairs[i].body1*6*nc + col;
+        const dReal* v2 = v + pairs[i].body2*6*nc + col;
+
+        // compute the two dot products
+        res[i*nc + col] = dot(w1, 1, v1, nc, 6) + dot(w2, 1, v2, nc, 6);
+      }
+    }
+    else
+    {
+      const dReal* w = M + j;
+      for (int col=0; col< nc; col++)
+      {
+        const dReal* vx = v + pairs[i].body1*6*nc + col;
+        res[i*nc + col] = dot(w, 1, vx, nc, 6);
+      }
+    }
+  }
+
+  // verify that all elements are finite
+  #ifdef DEBUG
+  verifyFinite(res, nr*nc);
+  #endif
+}
+
+// multiplies the transpose of a nr x (nb*6) matrix (N, T1, or T2) by a nb*6 x nc-dimensional matrix
+static void multSparseMatrix1(dReal* res, dReal* const M, dReal* const v, int nr, int nb, int nc, vector<BodyPair>& pairs)
+{
+  dIASSERT(nr == (int) pairs.size());
+
+  // zero out results vector
+  dSetZero(res, nc*nb*6);
+
+  for (int i=0, j=0; i< nr; i++, j+= 12)
+  {
+    // check for non-existent second body
+    if (pairs[i].body2 >= 0)
+    {
+      // get the two wrenches
+      const dReal* w1 = M + j;
+      const dReal* w2 = w1 + 6;
+
+      // determine the row the first wrench starts at
+      int res_row_skip = nc;
+      int w1row = pairs[i].body1 * 6;
+      int w2row = pairs[i].body2 * 6;
+
+      for (int col=0; col < nc; col++)
+      {
+        // update the results vector
+        int ridx = w1row*nc+col;
+        int vidx = i*nc+col;
+        res[ridx] += w1[0]*v[vidx]; ridx += nc;
+        res[ridx] += w1[1]*v[vidx]; ridx += nc;
+        res[ridx] += w1[2]*v[vidx]; ridx += nc;
+        res[ridx] += w1[3]*v[vidx]; ridx += nc;
+        res[ridx] += w1[4]*v[vidx]; ridx += nc;
+        res[ridx] += w1[5]*v[vidx]; ridx = w2row*nc+col;
+        res[ridx] += w2[0]*v[vidx]; ridx += nc;
+        res[ridx] += w2[1]*v[vidx]; ridx += nc;
+        res[ridx] += w2[2]*v[vidx]; ridx += nc;
+        res[ridx] += w2[3]*v[vidx]; ridx += nc;
+        res[ridx] += w2[4]*v[vidx]; ridx += nc;
+        res[ridx] += w2[5]*v[vidx]; ridx += nc;
+      }
+    }
+    else
+    {
+      const dReal* w = M + j;
+      int wrow = pairs[i].body1 * 6;
+      for (int col=0; col < nc; col++)
+      {
+        int ridx = wrow*nc+col;
+        int vidx = i*nc+col;
+        res[ridx] += w[0]*v[vidx]; ridx += nc;
+        res[ridx] += w[1]*v[vidx]; ridx += nc;
+        res[ridx] += w[2]*v[vidx]; ridx += nc;
+        res[ridx] += w[3]*v[vidx]; ridx += nc;
+        res[ridx] += w[4]*v[vidx]; ridx += nc;
+        res[ridx] += w[5]*v[vidx]; ridx += nc;
+      }
+    }
+  }
+
+  // verify that all elements are finite
+  #ifdef DEBUG
+  verifyFinite(res, nb*6*nc);
+  #endif
+}
+
+// determines the pairs of bodies, used for contact matrix-vector multiplication
+static void determineBodyPairs(dxJoint* const* joints, int nj, vector<BodyPair>& contact_pairs, vector<BodyPair>& bilateral_pairs, vector<BodyPair>& lo_pairs, vector<BodyPair>& hi_pairs)
+{
+  dReal dummy[6*6], lo[6], hi[6];
+  int findex[6];
+
+  dxJoint::Info1 info;
+  dxJoint::Info2 info2;
+  info2.rowskip = 6;
+  info2.fps = 0.0;
+  info2.erp = 0.0;
+
+  // setup all of info2 structure now, even though we won't really use it... 
+  info2.J1l = dummy;
+  info2.J1a = dummy;
+  info2.J2l = dummy;
+  info2.J2a = dummy;
+  info2.c = dummy;
+  info2.lo = lo;
+  info2.hi = hi;
+  info2.cfm = dummy;
+  info2.findex = findex;
+
+  // clear the vectors of body pairs
+  contact_pairs.clear();
+  bilateral_pairs.clear();
+  lo_pairs.clear();
+  hi_pairs.clear();
+
+  // iterate through all constraints
+  for (int i=0; i< nj; i++)
+  {
+    // get the info for the joint
+    joints[i]->getInfo1(&info);
+
+    // get the two bodies
+    dxBody* body1 = joints[i]->node[0].body;
+    dxBody* body2 = joints[i]->node[1].body;
+
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      if (body1 && body2)
+        contact_pairs.push_back(BodyPair(body1->tag, body2->tag));
+      else
+      {
+        dIASSERT(body1);
+        contact_pairs.push_back(BodyPair(body1->tag, -1));
+      }
+    }
+    else
+    {
+      // get info2 for the joint
+      joints[i]->getInfo2(&info2);
+
+      // add the pair nub times to bilateral constraints
+      for (int j=0; j< info.nub; j++)
+      {
+        if (body1 && body2)
+          bilateral_pairs.push_back(BodyPair(body1->tag, body2->tag));
+        else
+        {
+          dIASSERT(body1);
+          bilateral_pairs.push_back(BodyPair(body1->tag, -1));
+        }
+      }
+
+      // add any lo / hi pairs
+      for (int j=info.nub; j< info.m; j++)
+      {
+        if (lo[j] < dInfinity)
+        {
+          if (body1 && body2)
+            lo_pairs.push_back(BodyPair(body1->tag, body2->tag));
+          else
+          {
+            dIASSERT(body1);
+            lo_pairs.push_back(BodyPair(body1->tag, -1));
+          }
+        }
+        if (hi[j] > dInfinity)
+        {
+          if (body1 && body2)
+            hi_pairs.push_back(BodyPair(body1->tag, body2->tag));
+          else
+          {
+            dIASSERT(body1);
+            hi_pairs.push_back(BodyPair(body1->tag, -1));
+          }
+        }
+      }
+    }
+  }
+}
+
+// sets up a wrench at the given output
+static void setWrench(dReal* out, dReal* p, dReal* x, dReal* dir, bool negate_dir)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  // compute r
+  dReal r[3];
+  r[X] = p[X] - x[X];
+  r[Y] = p[Y] - x[Y];
+  r[Z] = p[Z] - x[Z];
+
+  // compute r x dir
+  dReal rxdir[3];
+  dCROSS(rxdir, =, r, dir);
+
+  // set the wrench
+  if (!negate_dir)
+  {
+    (*out++) = dir[X];
+    (*out++) = dir[Y];
+    (*out++) = dir[Z];
+    (*out++) = rxdir[X];
+    (*out++) = rxdir[Y];
+    (*out++) = rxdir[Z];
+  }
+  else
+  {
+    (*out++) = -dir[X];
+    (*out++) = -dir[Y];
+    (*out++) = -dir[Z];
+    (*out++) = -rxdir[X];
+    (*out++) = -rxdir[Y];
+    (*out++) = -rxdir[Z];
+  }
+}
+
+//****************************************************************************
+// forms the stacked matrix [N' J' Jl' Jh']
+//****************************************************************************
+static void formStack1(dReal* A, dReal* N, dReal* J, dReal* Jl, dReal* Jh, int nb, int nc, int m, int ml, int mh, const vector<BodyPair>& uniPairs, const vector<BodyPair>& biPairs)
+{
+  const int NVARS = nc + m + ml + mh;
+
+  // first, clear A
+  dSetZero(A, nb*6*NVARS);
+
+  // setup current column index of A
+  int col = 0;
+
+  // setup elements from N
+  for (int i=0, j=0; i< nc; i++, col++, j+= 12)
+  {
+    int body1st = uniPairs[i].body1*6;
+    int body2nd = uniPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, N + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, N + j + 6, 1, 6);
+  }
+
+  // setup elements from J
+  for (int i=0, j=0; i< m; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, J + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, J + j + 6, 1, 6);
+  }
+
+  // setup elements from Jl
+  for (int i=0, j=0; i< ml; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, Jl + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, Jl + j + 6, 1, 6);
+  }
+
+  // setup elements from Jh
+  for (int i=0, j=0; i< mh; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, Jh + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, Jh + j + 6, 1, 6);
+  }
+
+}
+
+//****************************************************************************
+// forms the stacked matrix [N' T1' T2' J' Jl' Jh']
+//****************************************************************************
+static void formStack2(dReal* A, dReal* N, dReal* T1, dReal* T2, dReal* J, dReal* Jl, dReal* Jh, int nb, int nc, int m, int ml, int mh, const vector<BodyPair>& uniPairs, const vector<BodyPair>& biPairs)
+{
+  const int NVARS = nc*3 + m + ml + mh;
+
+  // first, clear A
+  dSetZero(A, nb*6*NVARS);
+
+  // setup current column index of A
+  int col = 0;
+
+  // setup elements from N
+  for (int i=0, j=0; i< nc; i++, col++, j+= 12)
+  {
+    int body1st = uniPairs[i].body1*6;
+    int body2nd = uniPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, N + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, N + j + 6, 1, 6);
+  }
+
+  // setup elements from T1
+  for (int i=0, j=0; i< nc; i++, col++, j+= 12)
+  {
+    int body1st = uniPairs[i].body1*6;
+    int body2nd = uniPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, T1 + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, T1 + j + 6, 1, 6);
+  }
+
+  // setup elements from T2
+  for (int i=0, j=0; i< nc; i++, col++, j+= 12)
+  {
+    int body1st = uniPairs[i].body1*6;
+    int body2nd = uniPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, T2 + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, T2 + j + 6, 1, 6);
+  }
+
+  // setup elements from J
+  for (int i=0, j=0; i< m; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, J + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, J + j + 6, 1, 6);
+  }
+
+  // setup elements from Jl
+  for (int i=0, j=0; i< ml; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, Jl + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, Jl + j + 6, 1, 6);
+  }
+
+  // setup elements from Jh
+  for (int i=0, j=0; i< mh; i++, col++, j+= 12)
+  {
+    int body1st = biPairs[i].body1*6;
+    int body2nd = biPairs[i].body2*6;
+    dCopy(A+body1st*NVARS+col, NVARS, Jh + j, 1, 6);
+    if (body2nd >= 0)
+      dCopy(A+body2nd*NVARS+col, NVARS, Jh + j + 6, 1, 6);
+  }
+}
+
+//****************************************************************************
+// sets up the bilateral constraint Jacobians
+//****************************************************************************
+static void getJ_c(dxWorld* world, dxJoint* const* joints, int nj, dReal stepsize1, int& m, shared_array<dReal>& J, shared_array<dReal>& j_c, int& ml, shared_array<dReal>& Jl, shared_array<dReal>& jl_c, int& mh, shared_array<dReal>& Jh, shared_array<dReal>& jh_c)
+{
+  // set all m's to zero
+  m = ml = mh = 0;
+
+  // prepare the info structures
+  dxJoint::Info1 info1;
+  dxJoint::Info2 info2;
+  info2.rowskip = 6;
+  info2.fps = stepsize1;
+  info2.erp = world->global_erp;
+
+  // I did this a bit foolishly: because Jacobians for both bodies are all on
+  // the same line, so copying is necessary...
+  dReal J1[6*6], J2[6*6], lo[6], hi[6], c[6];
+
+  // setup all of info2 structure now, even though we won't really use it 
+  // all until later
+  info2.J1l = J1;
+  info2.J1a = J1+3;
+  info2.J2l = J2;
+  info2.J2a = J2+3;
+  info2.c = c;
+  info2.lo = lo;
+  info2.hi = hi;
+
+  // use dummy variables for some parts of info2 structure 
+  dReal dummy[6];
+  int findex[6];
+  info2.cfm = dummy;
+  info2.findex = findex;
+
+  // first, determine m, ml, and mh
+  for (int i=0, j=0; i< nj; i++)
+  {
+    // skip contact constraints
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      joints[i]->tag = -1;
+      continue;
+    }
+
+    // get the joint information
+    joints[i]->getInfo1(&info1);
+    joints[i]->getInfo2(&info2);    
+
+    // tag the joint
+    joints[i]->tag = (info1.m > 0) ? j++ : -1;
+
+    // increase m by the number of unbounded constraints
+    m += info1.nub;
+
+    // only update ml/mh if info1.nub != info1.m
+    if (info1.nub < info1.m)
+    {
+      for (int k=info1.nub; k< info1.m; k++)
+      {
+        if (info2.lo[k] > -dInfinity)
+          ml++;
+        if (info2.hi[k] < dInfinity)
+          mh++;
+      }
+    }
+  }
+
+  // allocate memory for the Jacobians and rhs's
+  J = shared_array<dReal>(new dReal[m*12]);
+  j_c = shared_array<dReal>(new dReal[m]);
+  Jl = shared_array<dReal>(new dReal[ml*12]);
+  jl_c = shared_array<dReal>(new dReal[ml]);
+  Jh = shared_array<dReal>(new dReal[mh*12]);
+  jh_c = shared_array<dReal>(new dReal[ml]);
+
+  // zero out the Jacobians and rhs's
+  dSetZero(J.get(),m*12);
+  dSetZero(j_c.get(),m);
+  dSetZero(Jl.get(),ml*12);
+  dSetZero(jl_c.get(),ml);
+  dSetZero(Jh.get(),mh*12);
+  dSetZero(jh_c.get(),mh);
+  
+  // now, setup the Jacobians and rhs's
+  for (int i=0, jj=0, jl=0, jh=0; i<nj; i++) 
+  {
+    // skip non-tagged joints
+    if (joints[i]->tag == -1)
+      continue;
+
+    // determine how many constraint equations and get the Jacobians
+    joints[i]->getInfo1(&info1);
+    joints[i]->getInfo2(&info2);
+
+    // copy the standard Jacobian and rhs 
+    dSetSubMat0(J.get(), 12, J1, info1.nub, 6, jj, 0);
+    dSetSubMat0(J.get(), 12, J2, info1.nub, 6, jj, 6);
+    dCopy(j_c.get()+jj, c, info1.nub);
+    jj += info1.nub;
+
+    // copy to the limit Jacobians
+    if (info1.nub < info1.m)
+    {
+      for (int k=info1.nub; k< info1.m; k++)
+      {
+        if (info2.lo[k] > -dInfinity)
+        {
+          dSetSubMat0(Jl.get(), 12, J1+k*6, 1, 6, jl, 0);
+          dSetSubMat0(Jl.get(), 12, J2+k*6, 1, 6, jl, 6);
+          jl_c[jl] = c[k];
+          jl++;
+        } 
+        if (info2.hi[k] < dInfinity)
+        {
+          dSetSubMat0(Jh.get(), 12, J1+k*6, 1, 6, jh, 0);
+          dSetSubMat0(Jh.get(), 12, J2+k*6, 1, 6, jh, 6);
+          jh_c[jh] = c[k];
+          jh++;
+        }
+      }
+    }
+  }
+}
+
+//****************************************************************************
+// calculates the relative velocity vector (for testing/debugging purposes)
+//****************************************************************************
+static void determineRvel(dxJoint* const* joints, int nj)
+{
+  for (int i=0, j=0, k=0; i< nj; i++)
+  {
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      // cast it as a contact joint
+      dxJointContact* joint = (dxJointContact*) joints[i];
+
+      // get the contact info
+      dContact contact = joint->contact;
+
+      // get the two bodies
+      dxBody* body1 = joints[i]->node[0].body;
+      dxBody* body2 = joints[i]->node[1].body;
+
+      // get the normal
+      dReal n[3] = { contact.geom.normal[0], contact.geom.normal[1], contact.geom.normal[2] };
+
+      // calculate the normal velocity for body 1
+      dReal* pos1 = body1->posr.pos;
+      dReal r[3];
+      r[0] = contact.geom.pos[0] - pos1[0];
+      r[1] = contact.geom.pos[1] - pos1[1];
+      r[2] = contact.geom.pos[2] - pos1[2];
+      dReal wxr[3];
+      dCROSS(wxr, =, body1->avel, r);
+      wxr[0] += body1->lvel[0];
+      wxr[1] += body1->lvel[1];
+      wxr[2] += body1->lvel[2];
+      dReal rvel = n[0]*wxr[0] + n[1]*wxr[1] + n[2]*wxr[2]; 
+
+      // calculate the normal velocity for body 2
+      if (body2)
+      {
+        dReal* pos2 = body2->posr.pos;
+        r[0] = contact.geom.pos[0] - pos2[0];
+        r[1] = contact.geom.pos[1] - pos2[1];
+        r[2] = contact.geom.pos[2] - pos2[2];
+        dCROSS(wxr, =, body2->avel, r);
+        wxr[0] += body2->lvel[0];
+        wxr[1] += body2->lvel[1];
+        wxr[2] += body2->lvel[2];
+        rvel -= n[0]*wxr[0] + n[1]*wxr[1] + n[2]*wxr[2]; 
+      }
+
+      std::cout << "relative normal vel for contact " << i << ": " << rvel << std::endl;
+    }
+  }
+}
+
+//****************************************************************************
+// sets up the "N" matrix (matrix of normal directions)
+//****************************************************************************
+static void getN_c(dxWorld* world, dxJoint* const* joints, int nj, dReal stepsize1, dReal* N, dReal* c)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  // space for dummy storage -- we don't use the contact Jacobian, lo, or hi
+  dReal dummy[6*6];
+  int findex[6];
+
+  // prepare the info structure
+  dxJoint::Info2 Jinfo;
+  Jinfo.rowskip = 6;
+  Jinfo.fps = stepsize1;
+  Jinfo.erp = world->global_erp;
+  Jinfo.J1l = dummy;
+  Jinfo.J1a = dummy;
+  Jinfo.J2l = dummy;
+  Jinfo.J2a = dummy;
+  Jinfo.lo = dummy;
+  Jinfo.hi = dummy;
+  Jinfo.cfm = dummy;
+  Jinfo.findex = findex;
+
+  for (int i=0, j=0, k=0; i< nj; i++)
+  {
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      // cast it as a contact joint
+      dxJointContact* joint = (dxJointContact*) joints[i];
+
+      // get the contact info
+      dContact contact = joint->contact;
+
+      // determine the normal
+      dReal normal[3];
+      if (joint->flags & dJOINT_REVERSE)
+      {
+        normal[0] = -contact.geom.normal[0];
+        normal[1] = -contact.geom.normal[1];
+        normal[2] = -contact.geom.normal[2];
+      }
+      else
+      {
+        normal[0] = contact.geom.normal[0];
+        normal[1] = contact.geom.normal[1];
+        normal[2] = contact.geom.normal[2];
+      }
+
+      // get c 
+      Jinfo.c = c + k++;
+      joints[i]->getInfo2(&Jinfo);
+
+      // get the two bodies
+      dxBody* body1 = joints[i]->node[0].body;
+      dxBody* body2 = joints[i]->node[1].body;
+
+      // setup the wrench for the first body
+      dReal* pos1 = body1->posr.pos;
+      setWrench(N+j, contact.geom.pos, pos1, normal, false);
+      j+= 6;
+
+      // setup the wrench for the second body (if there is one)
+      if (body2)
+      {
+        dReal* pos2 = body2->posr.pos;
+        setWrench(N+j, contact.geom.pos, pos2, normal, true);
+      }
+      j+= 6;
+    }
+  }
+}
+
+//****************************************************************************
+// sets up the "T1" matrix (matrix of first tangential directions)
+//****************************************************************************
+static void getT1(dxJoint* const* joints, int nj, dReal* T1)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  for (int i=0, j=0; i< nj; i++)
+  {
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      // cast it as a contact joint
+      dxJointContact* joint = (dxJointContact*) joints[i];
+
+      // get the contact info
+      dContact contact = joint->contact;
+
+      // determine the first friction direction
+      det_orthonormal_vec(contact.geom.normal, contact.fdir1);
+
+      // get the two bodies
+      dxBody* body1 = joints[i]->node[0].body;
+      dxBody* body2 = joints[i]->node[1].body;
+
+      // setup the wrench for the first body
+      dReal* pos1 = body1->posr.pos;
+      setWrench(T1+j, contact.geom.pos, pos1, contact.fdir1, false);
+      for (int k=0; k< 6; k++)
+        dIASSERT(!isnan(T1[j+k]));
+      j+= 6;
+
+      // setup the wrench for the second body (if there is one)
+      if (body2)
+      {
+        dReal* pos2 = body2->posr.pos;
+        setWrench(T1+j, contact.geom.pos, pos2, contact.fdir1, true);
+      }
+      j+= 6;
+    }
+  }
+}
+
+//****************************************************************************
+// sets up the "T2" matrix (matrix of second tangential directions)
+//****************************************************************************
+static void getT2(dxJoint* const* joints, int nj, dReal* T2)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  for (int i=0, j=0; i< nj; i++)
+  {
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      // cast it as a contact joint
+      dxJointContact* joint = (dxJointContact*) joints[i];
+
+      // get the contact info
+      dContact contact = joint->contact;
+
+      // determine the first friction direction (unsure why we must do this 2x)
+      det_orthonormal_vec(contact.geom.normal, contact.fdir1);
+
+      // compute the second tangential direction
+      dReal t2[3];
+      dCROSS(t2, =, contact.geom.normal, contact.fdir1);
+
+      // get the two bodies
+      dxBody* body1 = joints[i]->node[0].body;
+      dxBody* body2 = joints[i]->node[1].body;
+
+      // setup the wrench for the first body
+      dReal* pos1 = body1->posr.pos;
+      setWrench(T2+j, contact.geom.pos, pos1, t2, false);
+      j+= 6;
+
+      // setup the wrench for the second body (if there is one)
+      if (body2)
+      {
+        dReal* pos2 = body2->posr.pos;
+        setWrench(T2+j, contact.geom.pos, pos2, t2, true);
+      }
+      j+= 6;
+    }
+  }
+}
+
+//****************************************************************************
+// sets up the vector of friction coefficients
+//****************************************************************************
+static void getMu(dxJoint* const* joints, int nj, dReal* mu)
+{
+  for (int i=0, j=0; i< nj; i++)
+  {
+    if (joints[i]->type() == dJointTypeContact)
+    {
+      // cast it as a contact joint
+      dxJointContact* joint = (dxJointContact*) joints[i];
+
+      // get the contact info
+      dContact contact = joint->contact;
+
+      // get mu
+      mu[j++] = (contact.surface.mu < dInfinity) ? contact.surface.mu : 1000000;
+    }
+  }
+}
+
+//****************************************************************************
+// sets up the vector of velocities
+//****************************************************************************
+static void getVelocities(dxBody* const* bodies, int nb, dReal* v)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  for (int i=0, j=0; i< nb; i++)
+  {
+    v[j++] = bodies[i]->lvel[X];
+    v[j++] = bodies[i]->lvel[Y];
+    v[j++] = bodies[i]->lvel[Z];
+    v[j++] = bodies[i]->avel[X];
+    v[j++] = bodies[i]->avel[Y];
+    v[j++] = bodies[i]->avel[Z];
+  }
+}
+
+//****************************************************************************
+// gets vector of external forces on the bodies
+//****************************************************************************
+static void getFExt(dxBody* const* bodies, int nb, dReal* f)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  for (int i=0, j=0; i< nb; i++)
+  {
+    f[j++] = bodies[i]->facc[X];
+    f[j++] = bodies[i]->facc[Y];
+    f[j++] = bodies[i]->facc[Z];
+    f[j++] = bodies[i]->tacc[X];
+    f[j++] = bodies[i]->tacc[Y];
+    f[j++] = bodies[i]->tacc[Z];
+  }
+}
+
+//****************************************************************************
+// sets the velocities of the bodies from a vector
+//****************************************************************************
+static void setVelocities(dReal* v, dxBody* const* bodies, int nb)
+{
+  const int X = 0, Y = 1, Z = 2;
+
+  for (int i=0, j=0; i< nb; i++)
+  {
+    bodies[i]->lvel[X] = v[j++];
+    bodies[i]->lvel[Y] = v[j++];
+    bodies[i]->lvel[Z] = v[j++];
+    bodies[i]->avel[X] = v[j++];
+    bodies[i]->avel[Y] = v[j++];
+    bodies[i]->avel[Z] = v[j++];
+  }
+}
+
+//****************************************************************************
+// carries out forward/inverse generalized mass matrix multiplication
+//****************************************************************************
+// invI: a stack of nb 3x3 inverse inertia matrices
+// v: a nb*6 x vcol dimensional matrix
+static void multGMass0(dReal* result, dReal* J, int nb, dxBody * const *body, dReal* v, int vcol, bool inverse)
+{
+  // clear the result vector
+  dSetZero(result, nb*6*vcol);
+  dReal tmp1[3];
+
+  int rowskip = vcol;
+  for (int i=0, j=0, k=0; i< nb; i++, j+= 6, k+= 9)
+  {
+    dReal scalar = (inverse) ? body[i]->invMass : body[i]->mass.mass;
+    for (int col=0; col < vcol; col++)
+    {
+      int idx = j*vcol + col;
+      result[idx] = scalar*v[idx];
+      idx += rowskip;
+      result[idx] = scalar*v[idx];
+      idx += rowskip;
+      result[idx] = scalar*v[idx];
+      idx += rowskip;
+      dReal tmp2[3] = {v[idx], v[idx+rowskip], v[idx+rowskip+rowskip]};
+      dNPMultiply0(tmp1, J+k, tmp2, 3, 3, 1);
+      result[idx] = tmp1[0];
+      idx += rowskip;
+      result[idx] = tmp1[1];
+      idx += rowskip;
+      result[idx] = tmp1[2];
+      idx += rowskip;
+    }
+  }
+
+  // verify that all elements are finite
+  #ifdef DEBUG
+  verifyFinite(result, nb*6*vcol);
+  #endif
+}
+
+// forms the matrix X*inv(M)*X' used in Hessian calculation
+static void formXiMXT(shared_array<dReal>& XMXT, dReal* X, int nb, int n, dReal* iJ, dxBody* const* body, vector<BodyPair>& pairs)
+{
+  // setup dense X' (6nb x n)
+  shared_array<dReal> XT(new dReal[n * nb*6]);
+  dSetZero(XT.get(), n*nb*6);
+  for (int i=0, j=0; i< n; i++, j+= 12)
+  {
+    int body1row = 6 * pairs[i].body1;
+    int body2row = 6 * pairs[i].body2;
+    XT[body1row*n + i] = X[j];
+    XT[(body1row+1)*n + i] = X[j+1];
+    XT[(body1row+2)*n + i] = X[j+2];
+    XT[(body1row+3)*n + i] = X[j+3];
+    XT[(body1row+4)*n + i] = X[j+4];
+    XT[(body1row+5)*n + i] = X[j+5];
+    if (body2row >= 0)
+    {
+      XT[body2row*n + i] = X[j+6];
+      XT[(body2row+1)*n + i] = X[j+7];
+      XT[(body2row+2)*n + i] = X[j+8];
+      XT[(body2row+3)*n + i] = X[j+9];
+      XT[(body2row+4)*n + i] = X[j+10];
+      XT[(body2row+5)*n + i] = X[j+11];
+    }
+  }
+
+  // multiply iM * X'
+  shared_array<dReal> iMXT(new dReal[6*nb*n]);
+  multGMass0(iMXT.get(), iJ, nb, body, XT.get(), n, true);
+
+  // multiply X * result
+  XMXT = shared_array<dReal>(new dReal[n*n]);
+  multSparseMatrix0(XMXT.get(), X, iMXT.get(), n, n, pairs);
+}
+
+//****************************************************************************
+// convex optimization objective / constraint functions (phase I) 
+//****************************************************************************
+static void copt_fx1(dReal* x, int n, dReal* f, int m, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cn, cv, cl, ch
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* cl = cd.cl;
+  dReal* ch = cd.ch;
+  dCopy(cn, x, cd.nc);
+  dCopy(cv, x+cd.nc, cd.m); 
+  dCopy(cl, x+cd.nc+cd.m, cd.ml);
+  dCopy(ch, x+cd.nc+cd.m+cd.ml, cd.mh);
+
+  // calculate:
+  // v = M^{-1}*(N'*cn + J'*cv + Jl'*cl + Jh'*ch + hk) + v^n
+  dReal* vnp1 = cd.vnp1;
+  dSetZero(cd.worknb6_2, cd.nb*6);
+  multSparseMatrix1(cd.worknb6_2, cd.N, cn, cd.nc, cd.nb, 1, cd.uniPairs);
+  multSparseMatrix1(cd.worknb6, cd.J, cv, cd.m, cd.nb, 1, cd.biPairs); 
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.Jl, cl, cd.ml, cd.nb, 1, cd.biPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.Jh, ch, cd.mh, cd.nb, 1, cd.biPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.hfext, cd.nb*6);
+  multGMass0(vnp1, cd.invI, cd.nb, cd.bodies, cd.worknb6_2, 1, true);
+  dAdd(vnp1, vnp1, cd.v, cd.nb*6);
+
+  // multiply N*v^{n+1}
+  dReal* Nv = cd.Nv;
+  multSparseMatrix0(Nv, cd.N, vnp1, cd.nc, 1, cd.uniPairs); 
+
+  // multiply Jl*v^{n+1}
+  dReal* Jlv = cd.Jlv;
+  multSparseMatrix0(Jlv, cd.Jl, vnp1, cd.ml, 1, cd.biPairs);
+
+  // multiply Jh*v^{n+1}
+  dReal* Jhv = cd.Jhv;
+  multSparseMatrix0(Jhv, cd.Jh, vnp1, cd.mh, 1, cd.biPairs);
+
+  // evaluate objective function: kinetic energy [index 0]
+  int fidx = 0;
+  dReal* Mv = cd.Mv;
+  multGMass0(Mv, cd.I, cd.nb, cd.bodies, vnp1, 1, false);
+  f[fidx++] = dDot(Mv, vnp1, cd.nb*6) * (dReal) 0.5; 
+dIASSERT(!isnan(f[0]));
+
+  // evaluate non-negativity constraints on cn [indices 1..nc]
+  for (int i=0; i< cd.nc; i++)
+    f[fidx++] = -cn[i] - S_BUFFER;
+
+  // evaluate non-interpenetration constraints [indices nc+1..2*nc]
+  for (int i=0; i< cd.nc; i++)
+    f[fidx++] = cd.n_c[i] - Nv[i] - S_BUFFER;
+
+  // evaluate lower joint limit constraints [indices 2*nc+1..2*nc+ml)
+  for (int i=0; i< cd.ml; i++)
+    f[fidx++] = cd.jl_c[i] - Jlv[i] - S_BUFFER;
+
+  // evaluate upper joint limit constraints [indices 2*nc+ml+1..2*nc+ml+mh]
+  for (int i=0; i< cd.mh; i++)
+    f[fidx++] = cd.jh_c[i] - Jhv[i] - S_BUFFER;  
+}
+
+//****************************************************************************
+// convex optimization objective / constraint functions (phase II) 
+//****************************************************************************
+static void copt_fx2(dReal* x, int n, dReal* f, int m, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cn, ct1, ct2, cv, cl, ch
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* cl = cd.cl;
+  dReal* ch = cd.ch;
+  dReal* ct1 = cd.ct1;
+  dReal* ct2 = cd.ct2;
+  dCopy(cn, x, cd.nc);
+  dCopy(ct1, x+cd.nc, cd.nc);
+  dCopy(ct2, x+cd.nc*2, cd.nc);
+  dCopy(cv, x+cd.nc*3, cd.m); 
+  dCopy(cl, x+cd.nc*3+cd.m, cd.ml);
+  dCopy(ch, x+cd.nc*3+cd.m+cd.ml, cd.mh);
+
+  // calculate:
+  // v = M^{-1}*(N'*cn + T1'*ct1+ T2'*ct2 + J'*cv + Jl'*cl + Jh'*ch + hk) + v^n
+  dReal* vnp1 = cd.vnp1;
+  dSetZero(cd.worknb6_2, cd.nb*6);
+  multSparseMatrix1(cd.worknb6_2, cd.N, cn, cd.nc, cd.nb, 1, cd.uniPairs);
+  multSparseMatrix1(cd.worknb6, cd.T1, ct1, cd.nc, cd.nb, 1, cd.uniPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.T2, ct2, cd.nc, cd.nb, 1, cd.uniPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.J, cv, cd.m, cd.nb, 1, cd.biPairs); 
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.Jl, cl, cd.ml, cd.nb, 1, cd.biPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  multSparseMatrix1(cd.worknb6, cd.Jh, ch, cd.mh, cd.nb, 1, cd.biPairs);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+  dAdd(cd.worknb6_2, cd.worknb6_2, cd.hfext, cd.nb*6);
+  multGMass0(vnp1, cd.invI, cd.nb, cd.bodies, cd.worknb6_2, 1, true);
+  dAdd(vnp1, vnp1, cd.v, cd.nb*6);
+
+  // multiply N*v^{n+1}
+  dReal* Nv = cd.Nv;
+  multSparseMatrix0(Nv, cd.N, vnp1, cd.nc, 1, cd.uniPairs); 
+
+  // multiply Jl*v^{n+1}
+  dReal* Jlv = cd.Jlv;
+  multSparseMatrix0(Jlv, cd.Jl, vnp1, cd.ml, 1, cd.biPairs);
+
+  // multiply Jh*v^{n+1}
+  dReal* Jhv = cd.Jhv;
+  multSparseMatrix0(Jhv, cd.Jh, vnp1, cd.mh, 1, cd.biPairs);
+
+  // evaluate objective function: kinetic energy [index 0]
+  int fidx = 0;
+  dReal* Mv = cd.Mv;
+  multGMass0(Mv, cd.I, cd.nb, cd.bodies, vnp1, 1, false);
+  f[fidx++] = dDot(Mv, vnp1, cd.nb*6) * (dReal) 0.5; 
+dIASSERT(!isnan(f[0]));
+
+  // evaluate non-negativity constraints on cn [indices 1..nc]
+  for (int i=0; i< cd.nc; i++)
+    f[fidx++] = -cn[i] - S_BUFFER;
+
+  // evaluate non-interpenetration constraints [indices nc+1..2*nc]
+  for (int i=0; i< cd.nc; i++)
+    f[fidx++] = cd.n_c[i] - Nv[i] - S_BUFFER;
+
+  // evaluate lower joint limit constraints [indices 2*nc+1..2*nc+ml)
+  for (int i=0; i< cd.ml; i++)
+    f[fidx++] = cd.jl_c[i] - Jlv[i] - S_BUFFER;
+
+  // evaluate upper joint limit constraints [indices 2*nc+ml+1..2*nc+ml+mh]
+  for (int i=0; i< cd.mh; i++)
+    f[fidx++] = cd.jh_c[i] - Jhv[i] - S_BUFFER;  
+ 
+  // evaluate normal impulse constraint [index 2*nc+ml+mh+1]
+  f[fidx] = -cd.kappa - 1e-1;
+  for (int i=0; i< cd.nc; i++)
+    f[fidx] += cn[i];
+f[fidx] = -1000000;
+  fidx++;
+
+  // evaluate Coulomb friction constraints [indices 2*nc+ml+mh+2..3*nc+ml+mh+1]
+  for (int i=0; i< cd.nc; i++)
+//    f[fidx++] = (dReal) 0.5 * (ct1[i]*ct1[i] + ct2[i]*ct2[i] - cd.mu[i]*cd.mu[i]*cn[i]*cn[i]) - S_BUFFER;
+f[fidx++] = -1000000;
+}
+
+//***************************************************************************
+// numerical gradient functions for testing/debugging purposes
+//****************************************************************************
+static void copt_ngrad1(dReal* x, int n, int idx, dReal* g, void* data)
+{
+  COptData& cd = *((COptData*) data);
+
+  // setup for numerical gradient
+  const dReal H = (dReal) 1e-6;
+  const dReal iH2 = (dReal) 0.5/H;
+  shared_array<dReal> xx(new dReal[n]);
+  dCopy(xx.get(), x, n);
+
+  // determine how many constraints there are
+  const unsigned M = cd.nc*2 + cd.m + cd.ml + cd.mh;
+
+  // setup temporary arrays
+  shared_array<dReal> v1(new dReal[M+1]);
+  shared_array<dReal> v2(new dReal[M+1]);
+
+  for (int i=0; i< n; i++)
+  {
+    xx[i] += H;
+    copt_fx1(xx.get(), n, v1.get(), M, data);
+    xx[i] -= H*2;
+    copt_fx1(xx.get(), n, v2.get(), M, data);
+    xx[i] += H;
+    g[i] = (v1[idx] - v2[idx])*iH2;
+  }
+}
+static void copt_ngrad2(dReal* x, int n, int idx, dReal* g, void* data)
+{
+  COptData& cd = *((COptData*) data);
+
+  // setup for numerical gradient
+  const dReal H = (dReal) 1e-6;
+  const dReal iH2 = (dReal) 0.5/H;
+  shared_array<dReal> xx(new dReal[n]);
+  dCopy(xx.get(), x, n);
+
+  // determine how many constraints there are
+  const unsigned M = cd.nc*3 + cd.m + cd.ml + cd.mh + 1;
+
+  // setup temporary arrays
+  shared_array<dReal> v1(new dReal[M+1]);
+  shared_array<dReal> v2(new dReal[M+1]);
+
+  for (int i=0; i< n; i++)
+  {
+    xx[i] += H;
+    copt_fx2(xx.get(), n, v1.get(), M, data);
+    xx[i] -= H*2;
+    copt_fx2(xx.get(), n, v2.get(), M, data);
+    xx[i] += H;
+    g[i] = (v1[idx] - v2[idx])*iH2;
+  }
+}
+
+
+//****************************************************************************
+// convex optimization gradient functions 
+//****************************************************************************
+static void copt_grad1(dReal* x, int n, int idx, dReal* g, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cv, cn, cl, ch 
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* cl = cd.cl;
+  dReal* ch = cd.ch;
+  dCopy(cn, x, cd.nc);
+  dCopy(cv, x+cd.nc, cd.m); 
+  dCopy(cl, x+cd.nc+cd.m, cd.ml);
+  dCopy(ch, x+cd.nc+cd.m+cd.ml, cd.mh);
+
+  // evaluate objective function: kinetic energy
+  // given: * is inverse
+  // f0 = (cn'NM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + cn'Nv +
+  //       ct1'T1M*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + ct1'T1v +
+  //       ct2'T2M*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + ct2'T2v +
+  //       cv'JM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + cv'Jvv +
+  //       cl'JlM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + cl'Jlv +
+  //       ch'JhM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + ch'Jhv +
+  //       hfext'M*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + hfext'v +
+  //       v'(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + v'v)*0.5
+  // gf0/cn =  NM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + Nv
+  // gf0/cv =  JM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + Jv
+  // gf0/cl =  JlM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + Jlv
+  // gf0/ch =  JhM*(N'cn + J'cv + Jl'cl + Jh'ch + hfext) + Jhv
+
+  if (idx == 0)
+  {
+    // calculate v^{n+1}
+    dReal* vnp1 = cd.vnp1;
+    dSetZero(cd.worknb6_2, cd.nb*6);
+    multSparseMatrix1(cd.worknb6_2, cd.N, cn, cd.nc, cd.nb, 1, cd.uniPairs);
+    multSparseMatrix1(cd.worknb6, cd.J, cv, cd.m, cd.nb, 1, cd.biPairs); 
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.Jl, cl, cd.ml, cd.nb, 1, cd.biPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.Jh, ch, cd.mh, cd.nb, 1, cd.biPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.hfext, cd.nb*6);
+    multGMass0(vnp1, cd.invI, cd.nb, cd.bodies, cd.worknb6_2, 1, true);
+    dAdd(vnp1, vnp1, cd.v, cd.nb*6);
+
+    // calculate gradients
+    dSetZero(g, n);
+    multSparseMatrix0(g, cd.N, vnp1, cd.nc, 1, cd.uniPairs);
+    multSparseMatrix0(g + cd.nc, cd.J, vnp1, cd.m, 1, cd.biPairs);
+    multSparseMatrix0(g + cd.nc+cd.m, cd.Jl, vnp1, cd.ml, 1, cd.biPairs);
+    multSparseMatrix0(g + cd.nc+cd.m+cd.ml, cd.Jh, vnp1, cd.mh, 1, cd.biPairs); 
+  }
+  // gradients for non-negativity constraints
+  else if (idx <= cd.nc)
+  {
+    dSetZero(g, n);
+    g[idx-1] = (dReal) -1.0;
+  }
+  // gradients for non-interpenetration constraints
+  // fi = N(M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + v) >= c
+  // gfi/cn = NM*N'
+  // gfi/ct1 = NM*T1'
+  // gfi/ct2 = NM*T2'
+  // gfi/cv = NM*J'
+  // gfi/cl = NM*Jl'
+  // gfi/ch = NM*Jh'
+  else
+  {
+    // get the index of the non-interpenetration constraint
+    int npidx = idx - cd.nc - 1;
+
+    // multiply N by the stack
+    multSparseMatrix0(cd.NStack, cd.N, cd.stack1, cd.nc, n, cd.uniPairs);
+    for (int i=0; i< n; i++)
+      g[i] = -cd.NStack[npidx*n + i];
+  }
+}
+
+static void copt_grad2(dReal* x, int n, int idx, dReal* g, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cv, cn, ct1, ct2
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* ct1 = cd.ct1;
+  dReal* ct2 = cd.ct2;
+  dReal* cl = cd.cl;
+  dReal* ch = cd.ch;
+  dCopy(cn, x, cd.nc);
+  dCopy(ct1, x+cd.nc, cd.nc);
+  dCopy(ct2, x+cd.nc*2, cd.nc);
+  dCopy(cv, x+cd.nc*3, cd.m); 
+  dCopy(cl, x+cd.nc*3+cd.m, cd.ml);
+  dCopy(ch, x+cd.nc*3+cd.m+cd.ml, cd.mh);
+
+  // evaluate objective function: kinetic energy
+  // given: * is inverse
+  // f0 = (cn'NM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + 
+  //       cn'Nv +
+  //       ct1'T1M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       ct1'T1v +
+  //       ct2'T2M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       ct2'T2v +
+  //       cv'JM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       cv'Jvv +
+  //       cl'JlM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       cl'Jlv +
+  //       ch'JhM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       ch'Jhv +
+  //       hfext'M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) +
+  //       hfext'v +
+  //       v'(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + v'v)*0.5
+  // gf0/cn =  NM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + Nv
+  // gf0/ct1 = T1M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + T1v
+  // gf0/ct2 = T2M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + T2v
+  // gf0/cv =  JM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + Jv
+  // gf0/cl =  JlM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + Jlv
+  // gf0/ch =  JhM*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + Jhv
+
+  if (idx == 0)
+  {
+    // calculate v^{n+1}
+    dReal* vnp1 = cd.vnp1;
+    dSetZero(cd.worknb6_2, cd.nb*6);
+    multSparseMatrix1(cd.worknb6_2, cd.N, cn, cd.nc, cd.nb, 1, cd.uniPairs);
+    multSparseMatrix1(cd.worknb6, cd.T1, ct1, cd.nc, cd.nb, 1, cd.uniPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.T2, ct2, cd.nc, cd.nb, 1, cd.uniPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.J, cv, cd.m, cd.nb, 1, cd.biPairs); 
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.Jl, cl, cd.ml, cd.nb, 1, cd.biPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    multSparseMatrix1(cd.worknb6, cd.Jh, ch, cd.mh, cd.nb, 1, cd.biPairs);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.worknb6, cd.nb*6);
+    dAdd(cd.worknb6_2, cd.worknb6_2, cd.hfext, cd.nb*6);
+    multGMass0(vnp1, cd.invI, cd.nb, cd.bodies, cd.worknb6_2, 1, true);
+    dAdd(vnp1, vnp1, cd.v, cd.nb*6);
+
+    // calculate gradients
+    dSetZero(g, n);
+    multSparseMatrix0(g, cd.N, vnp1, cd.nc, 1, cd.uniPairs);
+    multSparseMatrix0(g + cd.nc, cd.T1, vnp1, cd.nc, 1, cd.uniPairs);
+    multSparseMatrix0(g + cd.nc*2, cd.T2, vnp1, cd.nc, 1, cd.uniPairs);
+    multSparseMatrix0(g + cd.nc*3, cd.J, vnp1, cd.m, 1, cd.biPairs);
+    multSparseMatrix0(g + cd.nc*3+cd.m, cd.Jl, vnp1, cd.ml, 1, cd.biPairs);
+    multSparseMatrix0(g + cd.nc*3+cd.m+cd.ml, cd.Jh, vnp1, cd.mh, 1, cd.biPairs); 
+  }
+  // gradients for non-negativity constraints
+  else if (idx <= cd.nc)
+  {
+    dSetZero(g, n);
+    g[idx-1] = (dReal) -1.0;
+  }
+  // gradients for non-interpenetration constraints
+  // fi = N(M*(N'cn + T1'ct1 + T2'ct2 + J'cv + Jl'cl + Jh'ch + hfext) + v) >= c
+  // gfi/cn = NM*N'
+  // gfi/ct1 = NM*T1'
+  // gfi/ct2 = NM*T2'
+  // gfi/cv = NM*J'
+  // gfi/cl = NM*Jl'
+  // gfi/ch = NM*Jh'
+  else if (idx <= cd.nc*2)
+  {
+    // get the non-interpenetration index
+    int npidx = idx - cd.nc - 1;
+
+    // multiply N by the stack
+    multSparseMatrix0(cd.NStack, cd.N, cd.stack2, cd.nc, n, cd.uniPairs);
+    for (int i=0; i< n; i++)
+      g[i] = -cd.NStack[npidx*n + i];
+  }
+  // gradients on normal impulse constraint
+  else if (idx <= cd.nc*2+1)
+  {
+    dSetZero(g, n);
+    for (int i=0; i< cd.nc; i++)
+      g[i] = (dReal) 1.0;
+  }
+  // Coulomb friction constraints
+  else
+  {
+    dSetZero(g, n);
+    int i = idx - cd.nc*2 - cd.m*2 - 2;
+    g[i] = -cd.mu[i]*cd.mu[i]*cn[i];
+    g[i+cd.nc] = ct1[i];
+    g[i+cd.nc*2] = ct2[i];
+  }
+}
+
+//****************************************************************************
+// numerical Hessian functions for testing/debugging purposes
+//****************************************************************************
+static bool copt_nhess1(dReal* x, int n, int idx, dReal* H, void* data)
+{
+  COptData& cd = *((COptData*) data);
+
+  // setup for numerical Hessian
+  const dReal h = (dReal) 1e-6;
+  const dReal ih2 = (dReal) 0.5/h;
+  shared_array<dReal> xx(new dReal[n]);
+  dCopy(xx.get(), x, n);
+
+  // setup temporary arrays
+  shared_array<dReal> v1(new dReal[n]), v2(new dReal[n]);
+
+  // do numerical Hessian
+  for (int i=0; i< n; i++)
+  {
+    xx[i] += h;
+    copt_ngrad1(xx.get(), n, idx, v1.get(), data);
+    xx[i] -= h*2;
+    copt_ngrad1(xx.get(), n, idx, v2.get(), data);
+    xx[i] += h;
+
+    // set the i'th column of the Hessian
+    for (int j=0; j< n; j++)
+      H[j*n+i] = (v1[j] - v2[j])*ih2;
+  }
+
+  // average values of the Hessian
+  for (int i=0; i< n; i++)
+    for (int j=i+1; j< n; j++)
+      H[j*n+i] = H[i*n+j] = (dReal) 0.5 * (H[j*n+i] + H[i*n+j]);
+
+  return true;
+}
+
+static bool copt_nhess2(dReal* x, int n, int idx, dReal* H, void* data)
+{
+  COptData& cd = *((COptData*) data);
+
+  // setup for numerical Hessian
+  const dReal h = (dReal) 1e-6;
+  const dReal ih2 = (dReal) 0.5/h;
+  shared_array<dReal> xx(new dReal[n]);
+  dCopy(xx.get(), x, n);
+
+  // setup temporary arrays
+  shared_array<dReal> v1(new dReal[n]), v2(new dReal[n]);
+
+  // do numerical Hessian
+  for (int i=0; i< n; i++)
+  {
+    xx[i] += h;
+    copt_ngrad2(xx.get(), n, idx, v1.get(), data);
+    xx[i] -= h*2;
+    copt_ngrad2(xx.get(), n, idx, v2.get(), data);
+    xx[i] += h;
+
+    // set the i'th column of the Hessian
+    for (int j=0; j< n; j++)
+      H[j*n+i] = (v1[j] - v2[j])*ih2;
+  }
+
+  // average values of the Hessians
+  for (int i=0; i< n; i++)
+    for (int j=i+1; j< n; j++)
+      H[j*n+i] = H[i*n+j] = (dReal) 0.5 * (H[j*n+i] + H[i*n+j]);
+
+  return true;
+}
+
+//****************************************************************************
+// convex optimization Hessian functions 
+//****************************************************************************
+static bool copt_hess1(dReal* x, int n, int idx, dReal* H, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cv, cn, ct1, ct2
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* ct1 = cd.ct1;
+  dReal* ct2 = cd.ct2;
+  dCopy(cn, x, cd.nc);
+  dCopy(ct1, x+cd.nc, cd.nc);
+  dCopy(ct2, x+cd.nc*2, cd.nc);
+  dCopy(cv, x+cd.nc*3, cd.m); 
+
+  // Hessian is unchanging for objective function 
+  if (idx == 0)
+  {
+    dCopy(H, cd.ohess1, n*n);
+    return true;
+  }
+  // Hessians for non-negativity constraints
+  // Hessians for non-interpenetration constraints  
+  // Hessians for inequality constraints on cv
+  // Hessians on normal impulse constraint
+  else
+    return false;
+}
+
+static bool copt_hess2(dReal* x, int n, int idx, dReal* H, void* data)
+{
+  COptData& cd = *((COptData*) data);
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // determine cv, cn, ct1, ct2
+  dReal* cn = cd.cn;
+  dReal* cv = cd.cv;
+  dReal* ct1 = cd.ct1;
+  dReal* ct2 = cd.ct2;
+  dCopy(cn, x, cd.nc);
+  dCopy(ct1, x+cd.nc, cd.nc);
+  dCopy(ct2, x+cd.nc*2, cd.nc);
+  dCopy(cv, x+cd.nc*3, cd.m); 
+
+  // evaluate objective function: kinetic energy
+  if (idx == 0)
+  {
+    dCopy(H, cd.ohess2, n*n);
+    return true;
+  }
+  // Hessians for non-negativity constraints
+  // Hessians for non-interpenetration constraints  
+  // Hessians for inequality constraints on cv
+  // Hessians on normal impulse constraint
+  else if (idx <= cd.nc*2+1)
+  {
+    return false;
+  }
+  // Hessians for Coulomb friction constraints
+  else
+  {
+    dSetZero(H, n*n);
+    int i = idx - cd.nc*2 - cd.m*2 - 2;
+    H[i*n + i] = -cd.mu[i]*cd.mu[i];
+    int j = i+cd.nc;
+    int k = i+cd.nc*2;
+    H[j*n + j] = (dReal) 1.0;
+    H[k*n + k] = (dReal) 1.0;
+    return true;
+  }
+}
+
+//****************************************************************************
+// a convex optimization version of dxInternalStepIsland
+//****************************************************************************
+void dxRobustStepIsland(dxWorldProcessContext* context, dxWorld *world, 
+                        dxBody * const *body, int nb,
+                        dxJoint * const *joint, int nj, dReal stepsize)
+{
+  const dReal EPS = world->rs.eps;
+  const dReal EPS_FEAS = world->rs.eps_feas;
+  const int MAX_ITERATIONS = world->rs.max_iterations;
+
+  // get inverse of stepsize
+  dReal stepsize1 = dRecip(stepsize);
+
+  // determine number of contact constraints
+  int nc = 0;
+  for (int i=0; i< nj; i++)
+    if (joint[i]->type() == dJointTypeContact)
+      nc++; 
+
+  // if there are no contact constraints, do the original island stepper
+  if (nc == 0)
+  {
+    dInternalStepIsland(context, world, body, nb, joint, nj, stepsize);
+    return;
+  }
+
+  // number all bodies in the body list - set their tag values
+  for (int i=0; i<nb; i++) 
+    body[i]->tag = i;
+
+  // for all bodies, compute the inertia tensor and its inverse in the global
+  // frame, and compute the rotational force and add it to the torque
+  // accumulator. invI are vertically stacked 3x4 matrices, one per body.
+  shared_array<dReal> fwdJ(new dReal[3*3*nb]);
+  ALLOCA(dReal,invI,3*nb*4*sizeof(dReal));
+  for (int i=0; i<nb; i++) 
+  {
+    dReal tmp[12];
+
+    // compute inverse inertia tensor in global frame
+    dMULTIPLY2_333 (tmp,body[i]->invI,body[i]->posr.R);
+    dMULTIPLY0_333 (invI+i*12,body[i]->posr.R,tmp);
+
+    if (body[i]->flags & dxBodyGyroscopic) 
+    {
+        dMatrix3 I;
+
+        // compute inertia tensor in global frame
+        dMULTIPLY2_333 (tmp,body[i]->mass.I,body[i]->posr.R);
+        dMULTIPLY0_333 (I,body[i]->posr.R,tmp);
+
+        // copy inertia tensor
+        fwdJ[i*9] = I[0];
+        fwdJ[i*9+1] = I[1];
+        fwdJ[i*9+2] = I[2];
+        fwdJ[i*9+3] = I[4];
+        fwdJ[i*9+4] = I[5];
+        fwdJ[i*9+5] = I[6];
+        fwdJ[i*9+6] = I[8];
+        fwdJ[i*9+7] = I[9];
+        fwdJ[i*9+8] = I[10];
+
+        // compute rotational force
+        dMULTIPLY0_331 (tmp,I,body[i]->avel);
+        dCROSS (body[i]->tacc,-=,body[i]->avel,tmp);
+    }
+  }
+
+  // copy inverse inertia tensors to 3x3 matrices; this is unnecessary,
+  // but I don't want to tease apart the 4x3 matrix code...
+  shared_array<dReal> invJ(new dReal[9*nb]);
+  for (int i=0; i< nb; i++)
+  {
+    invJ[i*9+0] = invI[i*12+0];
+    invJ[i*9+1] = invI[i*12+1];
+    invJ[i*9+2] = invI[i*12+2];
+    invJ[i*9+3] = invI[i*12+4];
+    invJ[i*9+4] = invI[i*12+5];
+    invJ[i*9+5] = invI[i*12+6];
+    invJ[i*9+6] = invI[i*12+8];
+    invJ[i*9+7] = invI[i*12+9];
+    invJ[i*9+8] = invI[i*12+10];
+  }
+
+  // add the gravity force to all bodies
+  for (int i=0; i<nb; i++) {
+    if ((body[i]->flags & dxBodyNoGravity)==0) 
+    {
+      body[i]->facc[0] += body[i]->mass.mass * world->gravity[0];
+      body[i]->facc[1] += body[i]->mass.mass * world->gravity[1];
+      body[i]->facc[2] += body[i]->mass.mass * world->gravity[2];
+    }
+  }
+
+  // setup vectors and matrices
+  shared_array<dReal> mu(new dReal[nc]);
+  shared_array<dReal> N(new dReal[nc*6*2]);
+  shared_array<dReal> n_c(new dReal[nc]);
+  shared_array<dReal> T1(new dReal[nc*6*2]);
+  shared_array<dReal> T2(new dReal[nc*6*2]);
+  shared_array<dReal> fext(new dReal[nb*6]);
+  shared_array<dReal> v(new dReal[nb*6]);
+
+  // determine the body pairs for unilateral and bilateral constraints
+  vector<BodyPair> uniPairs, biPairs, loPairs, hiPairs;
+  determineBodyPairs(joint, nj, uniPairs, biPairs, loPairs, hiPairs);
+
+  // determine joint constraint Jacobian
+  int m, ml, mh;
+  shared_array<dReal> J, Jl, Jh, j_c, jl_c, jh_c;
+  getJ_c(world, joint, nj, stepsize1, m, J, j_c, ml, Jl, jl_c, mh, Jh, jh_c);
+
+  // setup vector of friction coefficients
+  getMu(joint, nc, mu.get());
+
+  // determine generalized normals
+  getN_c(world, joint, nj, stepsize1, N.get(), n_c.get());
+
+  // determine generalized tangential directions
+  getT1(joint, nj, T1.get());
+  getT2(joint, nj, T2.get());
+
+  // determine generalized external forces and scale them by the step size
+  getFExt(body, nb, fext.get());
+  for (int i=0; i< nb*6; i++)
+    fext[i] *= stepsize;
+
+  // setup generalized velocities
+  getVelocities(body, nb, v.get());
+
+  // setup the convex optimization problem (w/o friction)
+  COptData copt(m, ml, mh, nc, nb);
+  copt.I = fwdJ.get();
+  copt.invI = invJ.get();
+  copt.J = J.get();
+  copt.j_c = j_c.get();
+  copt.Jl = Jl.get();
+  copt.jl_c = jl_c.get();
+  copt.Jh = Jh.get();
+  copt.jh_c = jh_c.get();
+  copt.N = N.get();
+  copt.n_c = n_c.get();
+  copt.T1 = T1.get();
+  copt.T2 = T2.get();
+  copt.hfext = fext.get();
+  copt.v = v.get();
+  copt.kappa = 0;
+  copt.mu = mu.get();
+  copt.biPairs = biPairs;
+  copt.uniPairs = uniPairs;
+  copt.bodies = body;
+
+  // setup the convex optimization parameters
+  CvxOptParams cparams;
+  cparams.max_iterations = std::numeric_limits<int>::max();
+  cparams.eps = EPS;
+  cparams.data = (void*) &copt;
+  cparams.fx = copt_fx1;
+  cparams.grad = copt_grad1;
+  cparams.hess = copt_hess1; 
+
+  // setup the n+m+ml+mh and 3n+m+ml+mh - dimensional vectors of impulses to 
+  // solve for
+  int nvar1 = nc + m + ml + mh;
+  int nvar2 = 3*nc + m + ml + mh;
+  shared_array<dReal> x1(new dReal[nvar1]);
+  shared_array<dReal> x2(new dReal[nvar2]);
+  dSetZero(x1.get(), nvar1);
+  dSetZero(x2.get(), nvar2);
+
+  // setup # of inequality constraints
+  cparams.m = 2*nc + ml + mh;
+
+  // ****************************************************************
+  // form the A matrix and b vector for the joint constraints
+  // ****************************************************************
+  shared_array<dReal> A1(new dReal[m*nvar1]);
+  shared_array<dReal> b(new dReal[m]);
+  shared_array<dReal> workm(new dReal[m]);
+  shared_array<dReal> worknb6(new dReal[nb*6]);
+  shared_array<dReal> worknb6n(new dReal[nb*6*nvar2]);
+  shared_array<dReal> worknb6n2(new dReal[nb*6*nvar2]);
+  // set b = j_c - J(v + M^{-1}hfext)
+  dCopy(b.get(), j_c.get(), m);
+  multGMass0(worknb6.get(), invJ.get(), nb, body, fext.get(), 1, true); 
+  dAdd(worknb6.get(), worknb6.get(), v.get(), nb*6);
+  multSparseMatrix0(workm.get(), J.get(), worknb6.get(), m, 1, biPairs);
+  dSub(b.get(), b.get(), workm.get(), m);
+  // set A = J*M^{-1}*[N' J' Jl' Jh']
+  formStack1(worknb6n.get(), N.get(), J.get(), Jl.get(), Jh.get(), nb, nc, m, ml, mh, uniPairs, biPairs);
+  multGMass0(copt.stack1, invJ.get(), nb, body, worknb6n.get(), nvar1, true);
+  multSparseMatrix0(A1.get(), J.get(), copt.stack1, m, nvar1, biPairs); 
+  cparams.A = A1.get();
+  cparams.b = b.get();
+  cparams.nu_len = 2*m;
+
+  #ifdef DEBUG
+  std::cout << "******** robust stepper **********" << std::endl;
+  std::cout << "  -- N: " << std::endl;
+  printMatrix(N.get(), nc, 12);
+  std::cout << "-- about to find initial feasible point" << std::endl;
+  #endif
+
+  // determine Hessian of objective function for phase I and phase II
+  // -- df0^2/dcncn = NM*N'
+  // -- df0^2/dct1ct1 = T1M*T1'
+  // -- df0^2/dct2ct2 = T2M*T2'
+  // -- df0^2/dcvcv = JM*J'
+  // -- df0^2/dclcl = JlM*Jl'
+  // -- df0^2/dchch = JhM*Jh'
+  shared_array<dReal> NMN, T1MT1, T2MT2, JMJ, JlMJl, JhMJh;
+  shared_array<dReal> hess1(new dReal[nvar1*nvar1]);
+  shared_array<dReal> hess2(new dReal[nvar2*nvar2]);
+  dSetZero(hess1.get(), nvar1*nvar1);
+  dSetZero(hess2.get(), nvar2*nvar2);
+  formXiMXT(NMN, N.get(), nb, nc, invJ.get(), body, uniPairs);
+  formXiMXT(T1MT1, T1.get(), nb, nc, invJ.get(), body, uniPairs);
+  formXiMXT(T2MT2, T2.get(), nb, nc, invJ.get(), body, uniPairs);
+  formXiMXT(JMJ, J.get(), nb, m, invJ.get(), body, biPairs);
+  formXiMXT(JlMJl, Jl.get(), nb, ml, invJ.get(), body, loPairs);
+  formXiMXT(JhMJh, Jh.get(), nb, mh, invJ.get(), body, hiPairs);
+  dSetSubMat0(hess1.get(), nvar1, NMN.get(), nc, nc, 0, 0);
+  dSetSubMat0(hess1.get(), nvar1, JMJ.get(), m, m, nc, nc);
+  dSetSubMat0(hess1.get(), nvar1, JlMJl.get(), ml, ml, nc+m, nc+m);
+  dSetSubMat0(hess1.get(), nvar1, JhMJh.get(), mh, mh, nc+m+ml, nc+m+ml);
+  dSetSubMat0(hess2.get(), nvar2, NMN.get(), nc, nc, 0, 0);
+  dSetSubMat0(hess2.get(), nvar2, T1MT1.get(), nc, nc, nc, nc);
+  dSetSubMat0(hess2.get(), nvar2, T2MT2.get(), nc, nc, nc*2, nc*2);
+  dSetSubMat0(hess2.get(), nvar2, JMJ.get(), m, m, nc*3, nc*3);
+  dSetSubMat0(hess2.get(), nvar2, JlMJl.get(), ml, ml, nc*3+m, nc*3+m);
+  dSetSubMat0(hess2.get(), nvar2, JhMJh.get(), mh, mh, nc*3+m+ml, nc*3+m+ml);
+  copt.ohess1 = hess1.get();
+  copt.ohess2 = hess2.get();
+
+  // find an initial feasible point -- we constrain frictional impulses to be
+  // zero
+  if (!dMakeFeasibleConvex(cparams, EPS_FEAS, x1.get(), nvar1))
+  {
+    std::cout << "unable to find initial feasible point!" << std::endl;
+    return;
+  }
+
+  #ifdef DEBUG
+  std::cout << "  -- required " << cparams.iterations << " iterations" << std::endl;
+  std::cout << "-- about to solve convex optimization problem w/o friction" << std::endl;
+  #endif
+
+  // solve the convex optimization problem (w/o friction) -- don't check that
+  // we were successful; we will still have some sort of solution on failure
+  dOptimizeConvexPrimalDual(cparams, EPS_FEAS, x1.get(), nvar1);
+
+  // reset number of inequality constraints 
+  cparams.m = 3*nc+ml+mh+1;
+
+  // setup kappa
+  copt.kappa = (dReal) 0.0;
+  for (int i=0; i< nc; i++)
+    copt.kappa += x1[i];
+
+  // setup x2 from x
+  memcpy(x2.get(), x1.get(), nc*sizeof(dReal));
+  dSetZero(x2.get()+nc, nc*2);
+  memcpy(x2.get()+nc*3, x1.get()+nc, (m+ml+mh)*sizeof(dReal));
+
+  // setup A2 = J*M^{-1}*[N' T1' T2' J' Jl' Jh']
+  shared_array<dReal> A2(new dReal[m*nvar2]);
+  formStack2(worknb6n.get(), N.get(), T1.get(), T2.get(), J.get(), Jl.get(), Jh.get(), nb, nc, m, ml, mh, uniPairs, biPairs);
+  multGMass0(copt.stack2, invJ.get(), nb, body, worknb6n.get(), nvar2, true);
+  multSparseMatrix0(A2.get(), J.get(), copt.stack2, m, nvar2, biPairs); 
+  cparams.A = A2.get();
+
+  // resolve the convex optimization problem with friction; again, not 
+  // necessary to check that we are successful
+  #ifdef DEBUG
+  std::cout << "  -- required " << cparams.iterations << " iterations" << std::endl;
+  std::cout << "    solution: ";
+  printMatrix(x1.get(), 1, nc+m+ml+mh);
+  std::cout << "-- about to solve convex optimization problem w/ friction" << std::endl;
+  #endif
+  cparams.fx = copt_fx2;
+  cparams.grad = copt_grad2;
+  cparams.hess = copt_hess2; 
+  cparams.max_iterations = MAX_ITERATIONS;
+  dOptimizeConvexPrimalDual(cparams, EPS_FEAS, x2.get(), nvar2);
+
+  // determine cn, ct1, ct2, cv, cl, ch
+  dReal* cn = copt.cn;
+  dReal* cv = copt.cv;
+  dReal* cl = copt.cl;
+  dReal* ch = copt.ch;
+  dReal* ct1 = copt.ct1;
+  dReal* ct2 = copt.ct2;
+  dCopy(cn, x2.get(), nc);
+  dCopy(ct1, x2.get()+nc, nc);
+  dCopy(ct2, x2.get()+nc*2, nc);
+  dCopy(cv, x2.get()+nc*3, m); 
+  dCopy(cl, x2.get()+nc*3+m, ml);
+  dCopy(ch, x2.get()+nc*3+m+ml, mh);
+
+  // compute new velocities
+  dReal* vnp1 = copt.vnp1;
+  dSetZero(copt.worknb6_2, nb*6);
+  multSparseMatrix1(copt.worknb6_2, N.get(), cn, nc, nb, 1, uniPairs);
+  multSparseMatrix1(copt.worknb6, T1.get(), ct1, nc, nb, 1, uniPairs);
+  dAdd(copt.worknb6_2, copt.worknb6_2, copt.worknb6, nb*6);
+  multSparseMatrix1(copt.worknb6, T2.get(), ct2, nc, nb, 1, uniPairs);
+  dAdd(copt.worknb6_2, copt.worknb6_2, copt.worknb6, nb*6);
+  multSparseMatrix1(copt.worknb6, J.get(), cv, m, nb, 1, biPairs); 
+  dAdd(copt.worknb6_2, copt.worknb6_2, copt.worknb6, nb*6);
+  multSparseMatrix1(copt.worknb6, Jl.get(), cl, ml, nb, 1, biPairs);
+  dAdd(copt.worknb6_2, copt.worknb6_2, copt.worknb6, nb*6);
+  multSparseMatrix1(copt.worknb6, Jh.get(), ch, mh, nb, 1, biPairs);
+  dAdd(copt.worknb6_2, copt.worknb6_2, copt.worknb6, nb*6);
+  dAdd(copt.worknb6_2, copt.worknb6_2, fext.get(), nb*6);
+  multGMass0(vnp1, invJ.get(), nb, body, copt.worknb6_2, 1, true);
+  dAdd(vnp1, vnp1, v.get(), nb*6);
+
+  #ifdef DEBUG
+  std::cout << "  -- required " << cparams.iterations << " iterations" << std::endl;
+  // add in inv(M)*h*fext to v
+  multGMass0(copt.worknb6_2, invJ.get(), nb, body, fext.get(), 1, true);
+  dAdd(v.get(), v.get(), copt.worknb6_2, nb*6);
+  // compute energy before and after
+  dReal* Mv = copt.Mv;
+  multGMass0(Mv, fwdJ.get(), nb, body, v.get(), 1, false);
+  dReal oke = dDot(Mv, v.get(), nb*6) * (dReal) 0.5; 
+  multGMass0(Mv, fwdJ.get(), nb, body, vnp1, 1, false);
+  dReal nke = dDot(Mv, vnp1, nb*6) * (dReal) 0.5; 
+  std::cout << "old kinetic energy: " << oke << std::endl;
+  std::cout << "new kinetic energy: " << nke << std::endl;
+  if (nke > oke)
+    std::cout << " *** ENERGY INCREASE ***" << std::endl;
+  #endif
+
+  // update body velocities
+  setVelocities(vnp1, body, nb);
+
+  #ifdef DEBUG
+  std::cout << "new velocity vector: ";
+  printMatrix(vnp1, 1, nb*6);
+  dReal* Nv = copt.Nv;
+  multSparseMatrix0(Nv, copt.N, vnp1, nc, 1, uniPairs);  
+  std::cout << "N*v: ";
+  printMatrix(Nv, 1, nc);
+  #endif
+
+  // TODO: determine impulses on bodies due to unilateral / bilateral constraints
+  for (int i=0; i< nj; i++)
+  {
+    // see whether joint feedback is requested
+    dJointFeedback *fb = joint[i]->feedback;
+    if (fb)
+    {
+    }
+  }
+
+  // step bodies forward using new velocities
+  for (int i=0; i<nb; i++) 
+    dxStepBody (body[i],stepsize);
+
+  // zero all force accumulators
+  for (int i=0; i<nb; i++) 
+  {
+    body[i]->facc[0] = 0;
+    body[i]->facc[1] = 0;
+    body[i]->facc[2] = 0;
+    body[i]->facc[3] = 0;
+    body[i]->tacc[0] = 0;
+    body[i]->tacc[1] = 0;
+    body[i]->tacc[2] = 0;
+    body[i]->tacc[3] = 0;
+  }
+
+/*
+
+  // this will be set to the force due to the constraints
+  ALLOCA(dReal,cforce,nb*8*sizeof(dReal));
+  dSetZero (cforce,nb*8);
+
+  // if there are constraints, compute cforce
+  if (m > 0) {
+    // create a constraint equation right hand side vector `c', a constraint
+    // force mixing vector `cfm', and LCP low and high bound vectors, and an
+    // 'findex' vector.
+
+    // compute the constraint force `cforce'
+#   ifdef TIMING
+    dTimerNow ("compute constraint force");
+#   endif
+    // compute cforce = J'*lambda
+    for (i=0; i<nj; i++) {
+      dReal *JJ = J + 2*8*ofs[i];
+      dxBody* b1 = joint[i]->node[0].body;
+      dxBody* b2 = joint[i]->node[1].body;
+      dJointFeedback *fb = joint[i]->feedback;
+
+      if (fb) {
+        // the user has requested feedback on the amount of force that this
+        // joint is applying to the bodies. we use a slightly slower
+        // computation that splits out the force components and puts them
+        // in the feedback structure.
+        dReal data[8];
+
+        Multiply1_8q1 (data, JJ, lambda+ofs[i], info[i].m);
+        dReal *cf1 = cforce + 8*b1->tag;
+        cf1[0] += (fb->f1[0] = data[0]);
+        cf1[1] += (fb->f1[1] = data[1]);
+        cf1[2] += (fb->f1[2] = data[2]);
+        cf1[4] += (fb->t1[0] = data[4]);
+        cf1[5] += (fb->t1[1] = data[5]);
+        cf1[6] += (fb->t1[2] = data[6]);
+        if (b2){
+          Multiply1_8q1 (data, JJ + 8*info[i].m, lambda+ofs[i], info[i].m);
+          dReal *cf2 = cforce + 8*b2->tag;
+          cf2[0] += (fb->f2[0] = data[0]);
+          cf2[1] += (fb->f2[1] = data[1]);
+          cf2[2] += (fb->f2[2] = data[2]);
+          cf2[4] += (fb->t2[0] = data[4]);
+          cf2[5] += (fb->t2[1] = data[5]);
+          cf2[6] += (fb->t2[2] = data[6]);
+	}
+      }
+      else {
+	// no feedback is required, let's compute cforce the faster way
+	MultiplyAdd1_8q1 (cforce + 8*b1->tag,JJ, lambda+ofs[i], info[i].m);
+	if (b2) {
+	  MultiplyAdd1_8q1 (cforce + 8*b2->tag,
+			    JJ + 8*info[i].m, lambda+ofs[i], info[i].m);
+	}
+      }
+    }
+  }
+
+  // add fe to cforce
+  for (i=0; i<nb; i++) {
+    for (j=0; j<3; j++) cforce[i*8+j] += body[i]->facc[j];
+    for (j=0; j<3; j++) cforce[i*8+4+j] += body[i]->tacc[j];
+  }
+  // multiply cforce by stepsize
+  for (i=0; i < nb*8; i++) cforce[i] *= stepsize;
+  // add invM * cforce to the body velocity
+  for (i=0; i<nb; i++) {
+    dReal body_invMass = body[i]->invMass;
+    dReal *body_invI = invI + i*12;
+    for (j=0; j<3; j++) body[i]->lvel[j] += body_invMass * cforce[i*8+j];
+    dMULTIPLYADD0_331 (body[i]->avel,body_invI,cforce+i*8+4);
+  }
+
+  }
+*/
+}
+
+//****************************************************************************
+
+void dRobustStepIsland(dxWorldProcessContext* context, dxWorld *world, dxBody * const *body, int nb,
+			  dxJoint * const *joint, int nj, dReal stepsize)
+{
+
+#ifdef dUSE_MALLOC_FOR_ALLOCA
+  dMemoryFlag = d_MEMORY_OK;
+#endif
+
+  dxRobustStepIsland(context, world,body,nb,joint,nj,stepsize);
+
+#ifdef dUSE_MALLOC_FOR_ALLOCA
+    if (dMemoryFlag == d_MEMORY_OUT_OF_MEMORY) {
+      REPORT_OUT_OF_MEMORY;
+      return;
+    }
+#endif
+}
+
+void TEST()
+{
+  dReal sparse[12*2] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
+                         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 };
+  dReal full[24*2] = { 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 6, 7, 8, 9, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 };
+  dReal v[48] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 };
+  dReal v2[4] = {10, 20, 30, 40};
+  vector<BodyPair> pairs;
+  pairs.push_back(BodyPair(0, 2));
+  pairs.push_back(BodyPair(2, 3));
+  dReal result[24];
+  multSparseMatrix0(result, sparse, v, 2, 2, pairs);
+  std::cout << "result: ";
+  printMatrix(result, 2, 2);
+  dNPMultiply0(result, full, v, 2, 24, 2); 
+  std::cout << "result: ";
+  printMatrix(result, 2, 2);
+  multSparseMatrix1(result, sparse, v2, 2, 4, 2, pairs);
+  std::cout << "result: ";
+  printMatrix(result, 2, 24);
+  dNPMultiply1(result, full, v2, 24, 2, 2);
+  printMatrix(result, 2, 24);
+
+}
+
Index: ode/src/odemath.cpp
===================================================================
--- ode/src/odemath.cpp	(revision 1730)
+++ ode/src/odemath.cpp	(working copy)
@@ -119,7 +119,9 @@
 int _dSafeNormalize4 (dVector4 a)
 {
   dAASSERT (a);
+
   dReal l = dCalcVectorDot3(a,a)+a[3]*a[3];
+
   if (l > 0) {
     l = dRecipSqrt(l);
     a[0] *= l;
Index: ode/src/robuststep.h
===================================================================
--- ode/src/robuststep.h	(revision 0)
+++ ode/src/robuststep.h	(revision 0)
@@ -0,0 +1,37 @@
+/*************************************************************************
+ *                                                                       *
+ * Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.       *
+ * All rights reserved.  Email: russ@q12.org   Web: www.q12.org          *
+ *                                                                       *
+ * This library is free software; you can redistribute it and/or         *
+ * modify it under the terms of EITHER:                                  *
+ *   (1) The GNU Lesser General Public License as published by the Free  *
+ *       Software Foundation; either version 2.1 of the License, or (at  *
+ *       your option) any later version. The text of the GNU Lesser      *
+ *       General Public License is included with this library in the     *
+ *       file LICENSE.TXT.                                               *
+ *   (2) The BSD-style license that is included with this library in     *
+ *       the file LICENSE-BSD.TXT.                                       *
+ *                                                                       *
+ * This library is distributed in the hope that it will be useful,       *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files    *
+ * LICENSE.TXT and LICENSE-BSD.TXT for more details.                     *
+ *                                                                       *
+ *************************************************************************/
+
+#ifndef _ROBUST_STEP_H_
+#define _ROBUST_STEP_H_
+
+#include <ode/common.h>
+
+size_t dxEstimateRobustStepMemoryRequirements(dxBody* const* body, int nb, dxJoint* const* _joint, int _nj);
+
+void dRobustStepIsland (dxWorldProcessContext* context, dxWorld *world,
+			  dxBody * const *body, int nb,
+			  dxJoint * const *joint, int nj,
+			  dReal stepsize);
+
+
+
+#endif
Index: ode/src/objects.h
===================================================================
--- ode/src/objects.h	(revision 1730)
+++ ode/src/objects.h	(working copy)
@@ -26,6 +26,7 @@
 #ifndef _ODE_OBJECT_H_
 #define _ODE_OBJECT_H_
 
+#include <limits>
 #include <ode/common.h>
 #include <ode/memory.h>
 #include <ode/mass.h>
@@ -97,6 +98,17 @@
   dReal w;			// the SOR over-relaxation parameter
 };
 
+// robust-step parameters
+struct dxRobustStepParameters {
+  dxRobustStepParameters() 
+  { 
+     eps_feas = eps = std::numeric_limits<dReal>::epsilon(); 
+     max_iterations = 100;
+  }
+  dReal eps_feas;                       // feasibility tolerance
+  dReal eps;                            // solution tolerance
+  int max_iterations;                   // maximum number of iterations
+};
 
 // contact generation parameters
 struct dxContactParameters {
@@ -153,6 +165,7 @@
   dxStepWorkingMemory *wmem; // Working memory object for dWorldStep/dWorldQuickStep
 
   dxQuickStepParameters qs;
+  dxRobustStepParameters rs;
   dxContactParameters contactp;
   dxDampingParameters dampingp; // damping parameters
   dReal max_angular_speed;      // limit the angular velocity to this magnitude
Index: ode/src/optimize.cpp
===================================================================
--- ode/src/optimize.cpp	(revision 0)
+++ ode/src/optimize.cpp	(revision 0)
@@ -0,0 +1,1012 @@
+#include <iostream>
+#include <boost/shared_array.hpp>
+#include <ode/odemath.h>
+#include <ode/matrix.h>
+#include <vector>
+#include <limits>
+#include "util.h"
+#include "optimize.h"
+
+using std::vector;
+using boost::shared_array;
+using std::cout;
+using std::endl;
+
+// misc defines
+#define ALLOCA dALLOCA16
+#define DEBUG
+
+// LAPACK routine for solving a symmetric indefinite system
+extern "C" {
+int ssysv_(char* uplo, int* n, int* nrhs, dReal* A, int* lda, int* ipiv, dReal* xb, int* ldb, dReal* work, int* lwork, int* info, short uplo_len);
+}
+
+// routine for solving a symmetric indefinite system
+void solveSymmetric(dReal* A, dReal* xb, int n)
+{
+  // form inputs to LAPACK
+  char UPLO = 'U';
+  int NRHS = 1;
+  int LDA = n;
+  int LDB = n;
+  int LWORK = -1;
+  dReal WORK_QUERY;
+  int INFO;
+  short UPLO_LEN = 1;
+
+  // memory for pivots
+  int* IPIV = new int[n];
+
+  // first, determine workspace size
+  ssysv_(&UPLO, &n, &NRHS, A, &LDA, IPIV, xb, &LDB, &WORK_QUERY, &LWORK, &INFO, UPLO_LEN);
+  dIASSERT(INFO == 0);
+
+  // setup workspace
+  LWORK = (int) WORK_QUERY;
+  dReal* WORK = new dReal[LWORK];
+
+  // do the solve
+  ssysv_(&UPLO, &n, &NRHS, A, &LDA, IPIV, xb, &LDB, WORK, &LWORK, &INFO, UPLO_LEN);
+  dIASSERT(INFO == 0);
+
+  delete [] IPIV;
+  delete [] WORK;
+}
+
+// non-padded Cholesky factorization
+int dNPFactorCholesky (dReal *A, int n)
+{
+// ODE's version of cholesky factorization seems to have a bug detecting when
+// matrix is singular when n=2, substituting a check in here...
+  if (n == 2)
+  {
+    if (dFabs(A[0]*A[3] - A[1]*A[2]) < dSqrt(std::numeric_limits<dReal>::epsilon()))
+      return false;
+  }
+
+  int i,j,k,nskip;
+  dReal sum,*a,*b,*aa,*bb,*cc,*recip;
+  dAASSERT (n > 0 && A);
+  nskip = n;
+  recip = (dReal*) ALLOCA (n * sizeof(dReal));
+  aa = A;
+  for (i=0; i<n; i++) {
+    bb = A;
+    cc = A + i*nskip;
+    for (j=0; j<i; j++) {
+      sum = *cc;
+      a = aa;
+      b = bb;
+      for (k=j; k; k--) sum -= (*(a++))*(*(b++));
+      *cc = sum * recip[j];
+      bb += nskip;
+      cc++;
+    }
+    sum = *cc;
+    a = aa;
+    for (k=i; k; k--, a++) sum -= (*a)*(*a);
+    if (sum <= REAL(0.0)) return 0;
+    *cc = dSqrt(sum);
+    recip[i] = dRecip (*cc);
+    aa += nskip;
+  }
+  return 1;
+}
+
+// non-padded Cholesky solve
+static void dNPSolveCholesky (const dReal *L, dReal *b, int n)
+{
+  int i,k,nskip;
+  dReal sum,*y;
+  dAASSERT (n > 0 && L && b);
+  nskip = n;
+  y = (dReal*) ALLOCA (n*sizeof(dReal));
+  for (i=0; i<n; i++) {
+    sum = 0;
+    for (k=0; k < i; k++) sum += L[i*nskip+k]*y[k];
+    y[i] = (b[i]-sum)/L[i*nskip+i];
+  }
+  for (i=n-1; i >= 0; i--) {
+    sum = 0;
+    for (k=i+1; k < n; k++) sum += L[k*nskip+i]*b[k];
+    b[i] = (y[i]-sum)/L[i*nskip+i];
+  }
+}
+
+// non-padded matrix multiplication
+void dNPMultiply0 (dReal *A, const dReal *B, const dReal *C, int p, int q, int r)
+{
+  int i,j,k,qskip,rskip,rpad;
+  if (p == 0 || q == 0 || r == 0)
+    return;
+  dAASSERT (A && B && C && p>0 && q>0 && r>0);
+  qskip = q;
+  rskip = r;
+  rpad = rskip - r;
+  dReal sum;
+  const dReal *b,*c,*bb;
+  bb = B;
+  for (i=p; i; i--) {
+    for (j=0 ; j<r; j++) {
+      c = C + j;
+      b = bb;
+      sum = 0;
+      for (k=q; k; k--, c+=rskip) sum += (*(b++))*(*c);
+      *(A++) = sum; 
+    }
+    A += rpad;
+    bb += qskip;
+  }
+}
+
+// non-padded matrix multiplication
+void dNPMultiply1 (dReal *A, const dReal *B, const dReal *C, int p, int q, int r)
+{
+  int i,j,k,pskip,rskip;
+  dReal sum;
+  if (p == 0 || q == 0 || r == 0)
+    return;
+  dAASSERT (A && B && C && p>0 && q>0 && r>0);
+  pskip = p;
+  rskip = r;
+  for (i=0; i<p; i++) {
+    for (j=0; j<r; j++) {
+      sum = 0;
+      for (k=0; k<q; k++) sum += B[i+k*pskip] * C[j+k*rskip];
+      A[i*rskip+j] = sum;
+    }
+  }
+}
+
+void dNPMultiply2 (dReal *A, const dReal *B, const dReal *C, int p, int q, int r)
+{
+  int i,j,k,z,rpad,qskip;
+  dReal sum;
+  const dReal *bb,*cc;
+  if (p == 0 || q == 0 || r == 0)
+    return;
+  dAASSERT (A && B && C && p>0 && q>0 && r>0);
+  rpad = 0;
+  qskip = q;
+  bb = B;
+  for (i=p; i; i--) {
+    cc = C;
+    for (j=r; j; j--) {
+      z = 0;
+      sum = 0;
+      for (k=q; k; k--,z++) sum += bb[z] * cc[z];
+      *(A++) = sum; 
+      cc += qskip;
+    }
+    A += rpad;
+    bb += qskip;
+  }
+}
+
+// prints a matrix
+void printMatrix(dReal* A, int m, int n)
+{
+  for (int i=0; i< m*n; i++)
+  {
+    if (i % n == 0 && i > 0)
+      std::cout << std::endl;
+    std::cout << A[i] << " ";
+  }
+  std::cout << std::endl;
+}
+
+// copies real arrays
+void dCopy(dReal* target, int tstride, dReal* source, int sstride, int n)
+{
+  for (int i=0; i< n; i++, target += tstride, source += sstride)
+    *target = *source;
+}
+
+// sets a submatrix of a matrix
+// A: the matrix into which B will be copied
+// ac: the number of columns of A
+// B: the source matrix
+// br: the number of rows of B
+// bc: the number of columns of b
+// sr: the starting row of A to which to copy
+// sc: the starting column of A to which to copy
+void dSetSubMat0(dReal* A, int ac, dReal* B, int br, int bc, int sr, int sc)
+{
+  int siA = sr*ac + sc;          // starting index for A
+  const int Arowskip = ac;
+  const int Browskip = bc;
+  int siB = 0;                   // starting index for B
+
+  for (int i=0; i< br; i++, siA += Arowskip, siB += Browskip)
+    memcpy(A+siA, B+siB, bc*sizeof(dReal));
+}
+
+// sets a submatrix of a matrix to a transposed matrix
+void dSetSubMat1(dReal* A, int ac, dReal* B, int br, int bc, int sr, int sc)
+{
+  int siA = sr*ac + sc;
+  const int Arowskip = ac;
+  int siB = 0;
+
+  for (int i=0; i< bc; i++, siA += Arowskip, siB++)
+    dCopy(A+siA, 1, B+siB, bc, br);
+}
+
+// Data structure for solving the LCP w = Mx + q for x
+struct LCPData
+{
+  dReal const* M;  // the n x n LCP matrix
+  dReal const* q;  // the n-dimensional LCP vector
+  dReal* work;     // an n-dimensional work vector
+
+  LCPData(int n) { work = new dReal[n]; }
+  ~LCPData() { delete [] work; }
+};
+
+// data for computing feasible starting point for convex optimization
+struct FeasibilityData
+{
+  int m;          // number of constraints in the original problem
+  int n;          // size of x in the original problem
+  void* data;     // data in the original problem
+  dReal* workn;   // work array of size n
+  dReal* workm;   // work array of size m+1
+  dReal* worknxn; // work array of size n x n
+
+  // functions in the original problem
+  void (*fx)(dReal*, int, dReal*, int, void*);
+  void (*grad)(dReal*, int, int, dReal*, void*);
+  bool (*hess)(dReal*, int, int, dReal*, void*);
+
+  FeasibilityData(int m, int n)
+  {
+    this->m = m;
+    this->n = n;
+    workn = new dReal[n];
+    workm = new dReal[m+1];
+    worknxn = new dReal[n*n];
+  }
+
+  ~FeasibilityData() { delete [] workm; delete [] workn; delete [] worknxn; }
+};
+
+// checks to see whether we can terminate early
+static bool make_feasible_tcheck(dReal* y, int n, void* data)
+{
+  // get the feasibility data
+  FeasibilityData& fdata = *((FeasibilityData*) data);
+  dIASSERT(n == fdata.n+1);
+  const int OLDN = fdata.n;
+  const int OLDM = fdata.m;
+
+  // remove v from y to yield x
+  memcpy(fdata.workn, y, OLDN*sizeof(dReal));
+
+  // call the original objective / constraint function
+  (*fdata.fx)(fdata.workn, OLDN, fdata.workm, OLDM, fdata.data);
+
+  // determine the maximum constraint value
+  dReal v = *std::max_element(fdata.workm+1, fdata.workm+1+OLDM);
+  return (v <= (dReal) 0.0);
+}
+
+// evaluation function for making an initial point feasible
+static void make_feasible_fx(dReal* y, int n, dReal* f, int m, void* data)
+{
+  // get the feasibility data
+  FeasibilityData& fdata = *((FeasibilityData*) data);
+  dIASSERT(n == fdata.n+1);
+  const int OLDN = fdata.n;
+  const int OLDM = fdata.m;
+
+  // remove v from y to yield x
+  memcpy(fdata.workn, y, OLDN*sizeof(dReal));
+
+  // call the original objective / constraint function
+  (*fdata.fx)(fdata.workn, OLDN, fdata.workm, OLDM, fdata.data);
+
+  // get v
+  dReal v = y[OLDN];
+  f[0] = v;
+
+  // constraints of f are fdata.workm[i] <= v
+  for (int i=0; i< OLDM; i++)
+    f[i+1] = fdata.workm[i+1] - v;
+}
+
+// gradient function for making an initial point feasible
+static void make_feasible_grad(dReal* y, int n, int idx, dReal* g, void* data)
+{
+  // get the feasibility data
+  FeasibilityData& fdata = *((FeasibilityData*) data);
+  dIASSERT(n == fdata.n+1);
+  const int OLDN = fdata.n;
+
+  // new objective function is simple
+  if (idx == 0)
+  {
+    dSetZero(g, n);
+    g[OLDN] = (dReal) 1.0;
+    return;
+  }
+
+  // still here?  need to call original gradient function
+
+  // remove v from y to yield x
+  memcpy(fdata.workn, y, OLDN*sizeof(dReal));
+
+  // call the original gradient function
+  (*fdata.grad)(fdata.workn, OLDN, idx, g, fdata.data);
+  g[OLDN] = (dReal) -1.0;
+}
+
+// Hessian function for making an initial point feasible
+static bool make_feasible_hess(dReal* y, int n, int idx, dReal* H, void* data)
+{
+  // get the feasibility data
+  FeasibilityData& fdata = *((FeasibilityData*) data);
+  dIASSERT(n == fdata.n+1);
+  const int OLDN = fdata.n;
+
+  // new objective function is simple
+  if (idx == 0)
+  {
+    dSetZero(H, n*n);
+    return false;
+  }
+
+  // still here?  need to call original Hessian function
+
+  // remove v from y to yield x
+  memcpy(fdata.workn, y, OLDN*sizeof(dReal));
+
+  // call the original Hessian function
+  if (!(*fdata.hess)(fdata.workn, OLDN, idx, fdata.worknxn, fdata.data))
+    return false;
+
+  // set the submatrix
+  dSetSubMat0(H, n, fdata.worknxn, OLDN, OLDN, 0, 0);
+
+  // set the last column and row of H to zeros
+  dSetZero(H+n*OLDN, n);
+  int Hidx = OLDN;
+  for (int i=0; i< OLDN; i++, Hidx+= n)
+    H[Hidx] = (dReal) 0.0;
+
+  return true;
+}
+
+// Hessian function for solving convex LCPs
+static bool lcp_ip_hess(dReal* x, int n, int idx, dReal* H, void* data)
+{
+  // get the LCP data
+  const LCPData& lcpdata = *((LCPData*) data);
+
+  // get M and q
+  const dReal* M = lcpdata.M;
+  const dReal* q = lcpdata.q;
+
+  // copy precomputed Hessian
+  if (idx == 0)
+  {
+    memcpy(H, M, n*n*sizeof(dReal));
+    return true;
+  }
+  else
+  {
+    dSetZero(H, n*n);
+    return false;
+  }
+}
+
+// gradient function for solving convex LCPs
+static void lcp_ip_grad(dReal* x, int n, int idx, dReal* g, void* data)
+{
+  // get the LCP data
+  const LCPData& lcpdata = *((LCPData*) data);
+
+  // get M and q
+  const dReal* M = lcpdata.M;
+  const dReal* q = lcpdata.q;
+
+  // objective function gradient: M*x + 1/2q
+  if (idx == 0)
+  {
+    dNPMultiply0(g, M, x, n, n, 1);
+    for (int i=0; i< n; i++)
+      g[i] += q[i]*0.5;  
+  }
+  // constraint x >= 0
+  else if (idx <= n)
+  {
+    dSetZero(g, n);
+    g[idx-1] = (dReal) -1.0;
+  }
+  // constraint w = Mx + q >= 0
+  else
+  {
+    // copy and negate row idx - n - 1 of M
+    memcpy(g, M+n*(idx-n-1), n*sizeof(dReal));
+    for (int i=0; i< n; i++)
+      g[i] = -g[i];
+  }
+}
+
+// objective / constraint evaluation function for solving convex LCPs
+static void lcp_ip_fx(dReal* x, int n, dReal* f, int m, void* data)
+{
+  const dReal S_BUFFER = std::numeric_limits<dReal>::epsilon();
+
+  // get the LCP data
+  const LCPData& lcpdata = *((LCPData*) data);
+
+  // get M and q
+  const dReal* M = lcpdata.M;
+  const dReal* q = lcpdata.q;
+
+  // get the work variable
+  dReal* work = lcpdata.work;
+
+  // evaluate the objective function
+  dNPMultiply0(work, M, x, n, n, 1);
+  for (int i=0; i< n; i++)
+    work[i] += q[i];
+  f[0] = dDot(x, work, n) * (dReal) 0.5;
+
+  // evaluate the x >= 0 constraint functions
+  int fidx = 1;
+  for (int i=0; i< n; i++)
+    if (x[i] != (dReal) 0.0)
+      f[fidx++] = -x[i];
+    else
+      f[fidx++] = -S_BUFFER;
+
+  // evaluate the w >= 0 constraint functions
+  for (int i=0; i< n; i++)
+    if (work[i] != (dReal) 0.0)
+      f[fidx++] = -work[i];
+    else
+      f[fidx++] = -S_BUFFER;
+}
+
+// checks whether the inequality constraints are feasible
+static bool feasible(dReal* f, int m)
+{
+  const dReal S_BUFFER = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  for (int i=0; i< m; i++)
+    if (!(f[i] < -S_BUFFER))
+      return false;
+
+  return true;
+}
+
+// makes a point feasible for solving a convex optimization problem
+bool dMakeFeasibleConvex(CvxOptParams& cparams, dReal eps_feas, dReal* x, int n)
+{
+  // setup the feasibility data
+  FeasibilityData fdata(cparams.m, n);
+  fdata.fx = cparams.fx;
+  fdata.grad = cparams.grad;
+  fdata.hess = cparams.hess;
+  fdata.data = cparams.data;
+
+  // evaluate f at current x
+  shared_array<dReal> f(new dReal[cparams.m+1]);
+  (*cparams.fx)(x, n, f.get(), cparams.m, cparams.data);
+
+  // verify that x is not already feasible (setup v simultaneously)
+  dReal v = *std::max_element(f.get()+1, f.get()+cparams.m+1);
+  if (v < (dReal) 0.0)
+    return true;
+
+  // setup y
+  shared_array<dReal> y(new dReal[n+1]);
+  memcpy(y.get(), x, n*sizeof(dReal));
+  y[n] = v + (dReal) 1.0;
+
+  // make new matrix A to account for increased size of y
+  shared_array<dReal> Anew(new dReal[(n+1)*cparams.nu_len]);
+  dSetSubMat0(Anew.get(), n+1, cparams.A, cparams.nu_len, n, 0, 0);
+  for (int i=0; i< cparams.nu_len; i++)
+    Anew[i*(n+1)+n] = (dReal) 0.0; 
+
+  // setup convex optimization parameters
+  CvxOptParams cp;
+  cp.m = cparams.m;
+  cp.nu_len = cparams.nu_len;
+  cp.eps = cparams.eps;
+  cp.tcheck = &make_feasible_tcheck;
+  cp.fx = &make_feasible_fx;
+  cp.grad = &make_feasible_grad;
+  cp.hess = &make_feasible_hess;
+  cp.data = &fdata;
+  cp.A = Anew.get();
+  cp.b = cparams.b;
+  cp.max_iterations = std::max(1000 + (int) log(n), cparams.max_iterations);
+
+  // do convex optimization with primal-dual method
+  dOptimizeConvexPrimalDual(cp, eps_feas, y.get(), n+1);
+
+  // get x out
+  memcpy(x, y.get(), n*sizeof(dReal));
+
+  // determine s
+  (*cparams.fx)(x, n, f.get(), cparams.m, cparams.data);
+  v = *std::max_element(f.get()+1, f.get()+cparams.m+1);
+  return v < eps_feas;
+}
+
+// interior point method for solving convex LCPs
+bool dSolveLCPIP(dReal* M, dReal* q, dReal* x, int n, dReal eps_feas)
+{
+  // create LCP data
+  LCPData lcpd(n);
+  lcpd.M = M;
+  lcpd.q = q;
+
+  // setup convex optimization parameters
+  CvxOptParams cparams;
+  cparams.m = n*2;
+  cparams.fx = &lcp_ip_fx;
+  cparams.grad = &lcp_ip_grad;
+  cparams.hess = &lcp_ip_hess;
+  cparams.eps = eps_feas;
+  cparams.data = &lcpd;
+  cparams.max_iterations = std::numeric_limits<int>::max();
+
+  // first, make feasible
+  if (!dMakeFeasibleConvex(cparams, eps_feas, x, n))
+    return false;
+
+  // now optimize
+  if (!dOptimizeConvexPrimalDual(cparams, eps_feas, x, n))
+    return false;
+
+  // check that x >= 0
+  for (int i=0; i< n; i++)
+    if (x[i] < -eps_feas)
+      return false;
+
+  // check that w >= 0
+  dNPMultiply0(lcpd.work, M, x, n, n, 1);
+  for (int i=0; i< n; i++)
+    if (lcpd.work[i] < -eps_feas)
+      return false;
+
+  // check complementarity condition
+  return dDot(lcpd.work, x, n) < eps_feas;
+}
+
+static void setupM(dReal* M, dReal* H, int n, dReal* A, int nu_len)
+{
+  // first zero the matrix
+  dSetZero(M, (n+nu_len)*(n+nu_len));
+
+  // copy H to M, row by row
+  dSetSubMat0(M, n+nu_len, H, n, n, 0, 0);
+  dSetSubMat0(M, n+nu_len, A, nu_len, n, n, 0);
+  dSetSubMat1(M, n+nu_len, A, nu_len, n, 0, n);
+}
+
+// conditions (makes positive-definite) the Hessian matrix
+static void conditionHessian(dReal* M, dReal* tmp, int n)
+{
+  // Hessian _must_ be positive-definite for the optimization to work
+  const dReal BETA = 1e-3;
+  dReal tau = M[0];
+  for (unsigned i=1; i< n; i++)
+    tau = std::min(tau, M[i*n+i]);
+  tau = (tau > (dReal) 0.0) ? BETA : -tau + BETA;
+
+  // copy M to tmp
+  memcpy(tmp, M, n*n*sizeof(dReal));
+
+  if (!dNPFactorCholesky(tmp, n))
+    while (true)
+    {
+      // copy M to tmp
+      memcpy(tmp, M, n*n*sizeof(dReal));
+
+      // update tmp += I*tau
+      for (int i=0; i< n; i++)
+        tmp[i*n+i] += tau;
+
+      // try Cholesky factorization
+      if (dNPFactorCholesky(tmp, n))
+        break;
+
+      // update tau
+      tau = std::max(tau*(dReal) 2.0, BETA);
+    }
+
+  // augment M
+  for (int i=0; i< n; i++)
+    M[i*n+i] += tau;
+}
+
+bool dOptimizeConvexPrimalDual(CvxOptParams& cparams, dReal eps_feas, dReal* x, int n)
+{
+  const int m = cparams.m;
+  const int nu_len = cparams.nu_len;
+  dReal rdual_nrm, rpri_nrm, f0_best;
+  const dReal NEAR_ZERO = dSqrt(std::numeric_limits<dReal>::epsilon());
+
+  // see whether we can quit immediately
+  if (cparams.tcheck && (*cparams.tcheck)(x, n, cparams.data))
+    return true;
+
+  // setup storage for best found
+  shared_array<dReal> x_best(new dReal[n]);
+
+  // setup vector of ones
+  shared_array<dReal> ones_m(new dReal[m]);
+  dSetValue(ones_m.get(), m, (dReal) 1.0);
+
+  // setup mu*m
+  const dReal mum = cparams.mu*m;
+
+  // setup nu
+  shared_array<dReal> nu(new dReal[nu_len]);
+  dSetZero(nu.get(),nu_len);
+
+  // determine f(x)
+  shared_array<dReal> f(new dReal[m+1]);
+  (*cparams.fx)(x, n, f.get(), m, cparams.data);
+  f0_best = f[0];
+  memcpy(x_best.get(), x, sizeof(dReal)*n);
+
+  // verify that f is non-positive for constraint functions
+  shared_array<dReal> fc(new dReal[m]);
+  memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+  dReal maxfc = *std::max_element(fc.get(), fc.get()+m);
+  dUASSERT(maxfc <= 0.0, "initial point infeasible");
+
+  // setup lambda: must be greater than zero
+  shared_array<dReal> lambda(new dReal[m]);
+  for (int i=0; i< m; i++)
+    lambda[i] = (fc[i] < (dReal) 0.0) ? (dReal) -1.0/fc[i] : dRecip(NEAR_ZERO);
+
+  // setup eta
+  dReal eta = -dDot(fc.get(), lambda.get(), m);
+
+  // init t
+  dReal t = mum/eta;
+
+  // init y and r
+  shared_array<dReal> y(new dReal[n+m+nu_len]);
+  shared_array<dReal> r(new dReal[n+m+nu_len]);
+
+  // init vectors and matrices so we don't have to keep reallocating memory
+  shared_array<dReal> x_plus(new dReal[n]);
+  shared_array<dReal> dx(new dReal[n]);
+  shared_array<dReal> lambda_plus(new dReal[m]);
+  shared_array<dReal> dlambda(new dReal[m]);
+  shared_array<dReal> nu_plus(new dReal[nu_len]);
+  shared_array<dReal> dnu(new dReal[nu_len]);
+  shared_array<dReal> Df(new dReal[m*n]);
+  shared_array<dReal> inv_t(new dReal[m]);
+  shared_array<dReal> l_fc(new dReal[m]);
+  shared_array<dReal> tmp1(new dReal[n]);
+  vector<shared_array<dReal> > g(m+1);
+  for (int i=0; i< m+1; i++)
+    g[i] = shared_array<dReal>(new dReal[n]);
+  shared_array<dReal> H(new dReal[n*n]);
+  shared_array<dReal> tmp2(new dReal[(n+nu_len)*(n+nu_len)]);
+  shared_array<dReal> M(new dReal[(n+nu_len)*(n+nu_len)]);
+  shared_array<dReal> rdual(new dReal[n]);
+  shared_array<dReal> rcent(new dReal[m]);
+  shared_array<dReal> rpri(new dReal[nu_len]);
+  shared_array<dReal> rhs(new dReal[n+nu_len]);
+  shared_array<dReal> tmp3(new dReal[m*m]);
+  shared_array<dReal> tmp4(new dReal[m]);
+
+  for (cparams.iterations = 0; cparams.iterations < cparams.max_iterations; cparams.iterations++)
+  {
+    // zero temporaries
+    dSetZero(tmp1.get(), n);
+    dSetZero(tmp2.get(), n*n);
+    dSetZero(tmp3.get(), m*m);
+    dSetZero(tmp4.get(), m);
+
+    // reset t
+    t = mum/eta;
+
+    #ifdef DEBUG
+    cout << "-------------------------------------------------------" << endl;
+    cout << "iteration: " << cparams.iterations << endl;
+    cout << " t: "  << t << endl;
+    cout << " x: ";
+    printMatrix(x, 1, n);
+    cout << " lambda: ";
+    printMatrix(lambda.get(), 1, m);
+    #endif
+
+    // compute the residual
+    for (int i=0; i< m+1; i++) (*cparams.grad)(x, n, i, g[i].get(), cparams.data);
+    (*cparams.fx)(x, n, f.get(), m, cparams.data);
+    memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+    for (int i=0, k=0; i< m; i++)
+      for (int j=0; j< n; j++)
+        Df[k++] = g[i+1][j];
+    dSetZero(r.get(), n+m+nu_len);
+    dNPMultiply1(r.get(), Df.get(), lambda.get(), n, m, 1);
+    dNPMultiply1(tmp1.get(), cparams.A, nu.get(), n, nu_len, 1);
+    for (int i=0; i< n; i++) r[i] += tmp1[i] + g[0][i];
+    dSetValue(inv_t.get(), m, (dReal) 1.0);
+    for (int i=0; i< m; i++) inv_t[i] /= t;
+    memcpy(l_fc.get(), fc.get(), m*sizeof(dReal));
+    for (int i=0; i< m; i++)  l_fc[i] *= -lambda[i];
+    memcpy(r.get()+n, l_fc.get(), m*sizeof(dReal));
+    for (int i=0; i< m; i++)  r[n+i] -= inv_t[i];
+    dNPMultiply0(r.get()+m+n, cparams.A, x, nu_len, n, 1);
+    for (int i=0; i< nu_len; i++)  r[n+m+i] -= cparams.b[i];
+
+    #ifdef DEBUG
+    cout << "Df: ";
+    printMatrix(Df.get(), m, n);
+    cout << " f0: " << f[0] << endl;
+    cout << " f: ";
+    printMatrix(fc.get(), 1, m);
+    cout << " rdual: ";
+    printMatrix(r.get(), 1, n);
+    cout << " rcent: ";
+    printMatrix(r.get()+n, 1, m);
+    #endif
+
+    // solve KKT equations for dx, dlambda, dnu
+    if (!(*cparams.hess)(x, n, 0, H.get(), cparams.data))
+      dSetZero(H.get(), n*n);
+    for (int i=0; i< m; i++)  { dIASSERT(fc[i] < 0.0); fc[i] = dRecip(fc[i]); }
+    for (int i=0; i< m; i++)
+    {
+      if ((*cparams.hess)(x, n, i+1, tmp2.get(), cparams.data))
+        for (int j=0; j< n*n; j++)  H[j] += tmp2[j] * lambda[i];
+      dNPMultiply2(tmp2.get(), g[i+1].get(), g[i+1].get(), n, 1, n);
+      for (int j=0; j< n*n; j++)  tmp2[j] *= lambda[i]*fc[i];
+      for (int j=0; j< n*n; j++)  H[j] -= tmp2[j];
+    }
+    #ifdef DEBUG
+    cout << "Hessian matrix [unconditioned]: " << std::endl;
+    printMatrix(H.get(), n, n);
+    #endif
+    conditionHessian(H.get(), tmp2.get(), n);
+    setupM(M.get(), H.get(), n, cparams.A, nu_len); 
+    memcpy(rdual.get(), r.get(), n*sizeof(dReal));
+    memcpy(rcent.get(), r.get()+n, m*sizeof(dReal));
+    memcpy(rpri.get(), r.get()+n+m, nu_len*sizeof(dReal));
+    dSetZero(tmp3.get(), m*m);
+    for (int i=0; i< m; i++) tmp3[m*i+i] = fc[i];
+    dNPMultiply0(tmp4.get(), tmp3.get(), rcent.get(), m, m, 1);    
+    dNPMultiply1(tmp1.get(), Df.get(), tmp4.get(), n, m, 1);
+    for (int i=0; i< n; i++) rhs[i] = -(rdual[i] + tmp1[i]);
+    for (int i=0; i< nu_len; i++) rhs[i+n] = -rpri[i];
+    #ifdef DEBUG
+    cout << "M (KKT matrix) [conditioned]: " << std::endl;
+    printMatrix(M.get(), n+nu_len, n+nu_len);
+    cout << "rhs: ";
+    printMatrix(rhs.get(), 1, n+nu_len);
+    #endif
+    if (nu_len > 0)
+    {
+      solveSymmetric(M.get(), rhs.get(), n+nu_len);
+    }
+    else
+    {
+      dNPFactorCholesky(M.get(), n);
+      dNPSolveCholesky(M.get(), rhs.get(), n);
+    }
+for (int i=0; i< n+nu_len; i++)
+dIASSERT(!isnan(rhs[i]));
+    memcpy(dx.get(), rhs.get(), n*sizeof(dReal));
+    memcpy(dnu.get(), rhs.get()+n, nu_len*sizeof(dReal));
+    dSetZero(tmp3.get(), m*m);
+    for (int i=0; i< m; i++) tmp3[i*m+i] = fc[i]*lambda[i];
+    dNPMultiply0(tmp4.get(), Df.get(), dx.get(), m, n, 1);
+    dNPMultiply0(dlambda.get(), tmp3.get(), tmp4.get(), m, m, 1);
+    for (int i=0; i< m; i++)
+      dlambda[i] = -dlambda[i] + fc[i]*rcent[i];
+    #ifdef DEBUG
+    cout << " dx: ";
+    printMatrix(dx.get(), 1, n);
+    cout << " dlambda: ";
+    printMatrix(dlambda.get(), 1, m);
+    #endif
+
+    // compute primal-dual search direction
+    const dReal dir_norm = dSqrt(dDot(rhs.get(), rhs.get(), n+nu_len));
+
+    // prepare to do backtracking line search
+    dReal smax = (dReal) 1.0;
+    for (int i=0; i< m; i++)
+      if (dlambda[i] < 0)
+      {
+        smax = std::min(smax, -lambda[i]/dlambda[i]);
+        if (smax < std::numeric_limits<dReal>::epsilon())
+          lambda[i] += NEAR_ZERO;
+      }
+    dReal s = (dReal) 0.99 * smax;
+    #ifdef DEBUG
+    cout << " maximum s: " << s << endl;
+    #endif
+    for (int i=0; i< n; i++) x_plus[i] = x[i] + dx[i]*s;
+    for (int i=0; i< m; i++) lambda_plus[i] = lambda[i] + dlambda[i]*s;
+    for (int i=0; i< nu_len; i++) nu_plus[i] = nu[i] + dnu[i]*s;
+
+    // satisfy inequality constraints 
+    (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+    memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+    #ifdef DEBUG
+    cout << " preparing to attempt to satisfy inequality constraints..." << endl;
+    #endif
+    while (!feasible(fc.get(), m))
+    {
+      #ifdef DEBUG
+      cout << "    s: " << s << "  fc: ";
+      printMatrix(fc.get(), 1, m);
+      #endif
+      s *= cparams.beta;
+      if (s*dir_norm < std::numeric_limits<dReal>::epsilon())
+      {
+        #ifdef DEBUG
+        cout << "*** s too small: exiting ***" << endl;
+        #endif
+        memcpy(x, x_best.get(), sizeof(dReal)*n);
+        return false;
+      }
+
+      // update f
+      for (int i=0; i< n; i++) x_plus[i] = x[i] + dx[i]*s;
+      (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+      memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+    }
+
+    // update lambda and nu
+    for (int i=0; i< m; i++) lambda_plus[i] = lambda[i] + dlambda[i]*s;
+    for (int i=0; i< nu_len; i++) nu_plus[i] = nu[i] + dnu[i]*s;
+
+    // re-evaluate the objective function
+    (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+    if (f[0] < f0_best)
+    {
+      f0_best = f[0];
+      memcpy(x_best.get(), x, sizeof(dReal)*n);
+    }
+
+    // determine norm of r target
+    const dReal rnorm = dSqrt(dDot(r.get(), r.get(), n+m+nu_len));
+    #ifdef DEBUG
+    cout << " current (old) residual: ";
+    printMatrix(r.get(), 1, n+m+nu_len);
+    #endif
+
+    // compute new residual
+    dSetZero(r.get(), n+m+nu_len);
+    dSetZero(tmp1.get(), n);
+    for (int i=0; i< m+1; i++) (*cparams.grad)(x_plus.get(), n, i, g[i].get(), cparams.data);
+    (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+    memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+    for (int i=0, k=0; i< m; i++)
+      for (int j=0; j< n; j++)
+        Df[k++] = g[i+1][j];
+    dNPMultiply1(r.get(), Df.get(), lambda_plus.get(), n, m, 1);
+    dNPMultiply1(tmp1.get(), cparams.A, nu_plus.get(), n, nu_len, 1);
+    for (int i=0; i< n; i++) r[i] += tmp1[i] + g[0][i];
+    dSetValue(inv_t.get(), m, (dReal) 1.0);
+    for (int i=0; i< m; i++) inv_t[i] /= t;
+    memcpy(l_fc.get(), fc.get(), m*sizeof(dReal));
+    for (int i=0; i< m; i++)  l_fc[i] *= -lambda_plus[i];
+    memcpy(r.get()+n, l_fc.get(), m*sizeof(dReal));
+    for (int i=0; i< m; i++)  r[n+i] -= inv_t[i];
+    dNPMultiply0(r.get()+m+n, cparams.A, x_plus.get(), nu_len, n, 1);
+    for (int i=0; i< nu_len; i++)  r[n+m+i] -= cparams.b[i];
+
+    // do backtracking line search
+    #ifdef DEBUG 
+    cout << " starting BLS..." << endl;
+    #endif
+    while (dSqrt(dDot(r.get(), r.get(), n+m+nu_len)) > (1-cparams.alpha*s)*rnorm)
+    {
+      #ifdef DEBUG
+      cout << "  s: " << s << endl;
+      #endif
+      s *= cparams.beta;
+
+      // verify that s is not too small
+      if (s*dir_norm < std::numeric_limits<dReal>::epsilon())
+      {
+        memcpy(x, x_best.get(), sizeof(dReal)*n);
+        #ifdef DEBUG
+        cout << "  *** s is too small: exiting ***" << endl;
+        #endif
+        return false;
+      }
+
+      // update x+, lambda+, nu+
+      for (int i=0; i< n; i++) x_plus[i] = x[i] + dx[i]*s;
+      for (int i=0; i< m; i++) lambda_plus[i] = lambda[i] + dlambda[i]*s;
+      for (int i=0; i< nu_len; i++) nu_plus[i] = nu[i] + dnu[i]*s;
+
+      // re-valuate the objective function
+      (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+      if (f[0] < f0_best)
+      {
+        f0_best = f[0];
+        memcpy(x_best.get(), x, sizeof(dReal)*n);
+      }
+
+      // recalculate the residual
+      dSetZero(r.get(), n+m+nu_len);
+      dSetZero(tmp1.get(), n);
+      for (int i=0; i< m+1; i++) (*cparams.grad)(x_plus.get(), n, i, g[i].get(), cparams.data);
+      (*cparams.fx)(x_plus.get(), n, f.get(), m, cparams.data);
+      memcpy(fc.get(), f.get()+1, sizeof(dReal)*m);
+      for (int i=0, k=0; i< m; i++)
+        for (int j=0; j< n; j++)
+          Df[k++] = g[i+1][j];
+      dNPMultiply1(r.get(), Df.get(), lambda_plus.get(), n, m, 1);
+      dNPMultiply1(tmp1.get(), cparams.A, nu_plus.get(), n, nu_len, 1);
+      for (int i=0; i< n; i++) r[i] += tmp1[i] + g[0][i];
+      dSetValue(inv_t.get(), m, (dReal) 1.0);
+      for (int i=0; i< m; i++) inv_t[i] /= t;
+      memcpy(l_fc.get(), fc.get(), m*sizeof(dReal));
+      for (int i=0; i< m; i++)  l_fc[i] *= -lambda_plus[i];
+      memcpy(r.get()+n, l_fc.get(), m*sizeof(dReal));
+      for (int i=0; i< m; i++)  r[n+i] -= inv_t[i];
+      dNPMultiply0(r.get()+m+n, cparams.A, x_plus.get(), nu_len, n, 1);
+      for (int i=0; i< nu_len; i++)  r[n+m+i] -= cparams.b[i];
+      #ifdef DEBUG
+      cout << "   determined residual: ";
+      printMatrix(r.get(), 1, n+m+nu_len);
+      #endif
+    }
+    #ifdef DEBUG
+    cout << "  new r: ";
+    printMatrix(r.get(), 1, n+m+nu_len);
+    #endif
+
+    // get x, lambda, and nu
+    memcpy(x, x_plus.get(), n*sizeof(dReal));
+    std::swap(lambda, lambda_plus);
+    std::swap(nu, nu_plus);
+    #ifdef DEBUG
+    printMatrix(x, 1, n);
+    #endif
+
+    // see whether we can quit
+    if (cparams.tcheck && (*cparams.tcheck)(x, n, cparams.data))
+    {
+      #ifdef DEBUG
+      cout << " *** termination check indicates we can quit ***" << endl;
+      #endif
+      return true;
+    }
+
+    // redetermine eta
+    eta = -dDot(fc.get(), lambda.get(), m);
+
+    // recompute primary and dual norms
+    rdual_nrm = dSqrt(dDot(r.get(), r.get(), n));
+    rpri_nrm = dSqrt(dDot(r.get()+n+m, r.get()+n+m, nu_len));
+
+    // check for convergence
+    if (rpri_nrm <= eps_feas && rdual_nrm <= eps_feas && eta < cparams.eps)
+    {
+      #ifdef DEBUG
+      cout << "solution is within tolerances... exiting" << endl;
+      #endif
+      memcpy(x, x_best.get(), n*sizeof(dReal));
+      return true;
+    }
+  }
+
+  #ifdef DEBUG
+  cout << " *** maximum number of iterations exceeded... exiting" << endl;
+  #endif
+
+  // if we're here, the max number of iterations has been exceeded
+  memcpy(x, x_best.get(), n*sizeof(dReal));
+  return false;
+}
+
+
Index: ode/src/ode.cpp
===================================================================
--- ode/src/ode.cpp	(revision 1730)
+++ ode/src/ode.cpp	(working copy)
@@ -39,6 +39,7 @@
 #include "quickstep.h"
 #include "util.h"
 #include "odetls.h"
+#include "robuststep.h"
 
 // misc defines
 #define ALLOCA dALLOCA16
@@ -1818,7 +1819,20 @@
   return result;
 }
 
+int dWorldRobustStep(dWorldID w, dReal stepsize)
+{
+  dUASSERT (w,"bad world argument");
+  dUASSERT (stepsize > 0,"stepsize must be > 0");
+  bool result = false;
+  if (dxReallocateWorldProcessContext(w, stepsize, &dxEstimateRobustStepMemoryRequirements))
+  {
+    dxProcessIslands(w, stepsize, &dRobustStepIsland);
+    result = true;
+  }
 
+  return result;
+}
+
 void dWorldImpulseToForce (dWorldID w, dReal stepsize,
 			   dReal ix, dReal iy, dReal iz,
 			   dVector3 force)
@@ -2016,7 +2030,18 @@
 	return w->qs.num_iterations;
 }
 
+void dWorldSetRobustStepMaxIterations (dWorldID w, int num)
+{
+	dAASSERT(w);
+	w->rs.max_iterations = num;
+}
 
+int dWorldGetRobustStepMaxIterations (dWorldID w)
+{
+	dAASSERT(w);
+	return w->rs.max_iterations;
+}
+
 void dWorldSetQuickStepW (dWorldID w, dReal param)
 {
 	dAASSERT(w);
Index: ode/src/Makefile.am
===================================================================
--- ode/src/Makefile.am	(revision 1730)
+++ ode/src/Makefile.am	(working copy)
@@ -52,12 +52,15 @@
                         odemath.cpp \
                         odeou.h \
                         odetls.h \
+                        optimize.cpp optimize.h \
                         plane.cpp \
                         quickstep.cpp quickstep.h \
                         ray.cpp \
+                        robuststep.cpp robuststep.h \
                         rotation.cpp \
                         sphere.cpp \
                         step.cpp step.h \
+												symm.c \
                         timer.cpp \
                         util.cpp util.h
 
@@ -124,5 +127,16 @@
                         collision_trimesh_plane.cpp
 endif
 
+#################################
+#   B O O S T  A D D I T I O N
+#################################
 
+AM_CPPFLAGS += $(BOOST_CPPFLAGS)
+# These other two are unnecessary, because only boost's shared array is 
+# used, which consists only of a header. 
+# If boost is used more completely, these need to be added (and a check
+# for the requisite library in the configure.in)
+#libode_la_LDFLAGS += $(BOOST_THREAD_LDFLAGS)
+#libode_la_LIBS += $(BOOST_THREAD_LIBS)
 
+
