Index: include/ode/objects.h
===================================================================
--- include/ode/objects.h	(revision 1806)
+++ include/ode/objects.h	(working copy)
@@ -447,6 +447,18 @@
 
 
 /**
+ * @brief Set the number of preconditioning iterations that the QuickStep method performs per
+ *        step.
+ * @ingroup world
+ * @remarks
+ * More iterations will give a more accurate solution, but will take
+ * longer to compute.
+ * @param num The default is 0 iterations.
+ */
+ODE_API void dWorldSetQuickStepPreconIterations (dWorldID, int num);
+
+
+/**
  * @brief Get the number of iterations that the QuickStep method performs per
  *        step.
  * @ingroup world
Index: configure.in
===================================================================
--- configure.in	(revision 1806)
+++ configure.in	(working copy)
@@ -1,9 +1,9 @@
 dnl AC_INIT does not take a macro as a version nr: set it separately! - Bram
 # add another minor for wg
-AC_INIT([ODE],[0.11.1.70],[ode@ode.org])
+AC_INIT([ODE],[0.11.1.71],[ode@ode.org])
 AC_CONFIG_SRCDIR([ode/src/ode.cpp])
 # add another minor for wg
-ODE_RELEASE=0.11.1.70
+ODE_RELEASE=0.11.1.71
 AC_SUBST(ODE_RELEASE)
 
 # Those are instructions from the Libtool manual:
Index: ode/src/quickstep.cpp
===================================================================
--- ode/src/quickstep.cpp	(revision 1806)
+++ ode/src/quickstep.cpp	(working copy)
@@ -86,6 +86,45 @@
 #define RANDOMLY_REORDER_CONSTRAINTS 1
 #undef LOCK_WHILE_RANDOMLY_REORDER_CONSTRAINTS
 
+
+// structure for passing variable pointers in SOR_LCP
+struct dxSORLCPParameters {
+    int nStart;   // 0
+    int nChunkSize;
+    int m; // m
+    int nb;
+    int num_iterations;
+    int precon_iterations;
+    dReal stepsize;
+    dReal sor_lcp_tolerance;
+    int* jb;
+    const int* findex;
+    dRealPtr Ad;
+    dRealPtr hi;
+    dRealPtr lo;
+    dRealPtr Adcfm;
+    dRealPtr invI;
+    dRealPtr I;
+    dRealPtr Ad_precon;
+    dRealPtr Adcfm_precon;
+    dRealPtr JiMratio;
+    dRealMutablePtr vnew;
+    dRealMutablePtr b;
+    dRealMutablePtr J;
+    dRealMutablePtr ac;
+    dRealMutablePtr lambda;
+    dRealMutablePtr iMJ;
+    dRealMutablePtr delta_error ;
+    dRealMutablePtr b_precon ;
+    dRealMutablePtr J_precon ;
+    dRealMutablePtr J_orig ;
+    dRealMutablePtr fc ;
+#ifdef REORDER_CONSTRAINTS
+    dRealMutablePtr last_lambda ;
+#endif
+};
+
+
 //****************************************************************************
 // special matrix multipliers
 
@@ -362,15 +401,138 @@
 
 #endif
 
+void updateVnew(const int nb, dRealPtr invI, dRealPtr ac, dxBody * const * body, dReal stepsize, dRealMutablePtr vnew)
+{
+  /****************************************************************/
+  /* compute vnew per ac update                                   */
+  /*   based on all external forces fe, ac                        */
+  /*   vnew should have started out same as v(n)                  */
+  /*   vnew should end up being v(n+1)                            */
+  /*                                                              */
+  /*  vnew = v_current + stepsize * invM * f_all                  */
+  /*                                                              */
+  /****************************************************************/
+  {
+    const dReal *invIrow = invI;
+    dRealMutablePtr vnew_ptr = vnew;
+    dxBody *const *const bodyend = body + nb;
+    const dReal *ac_ptr = ac;
+
+    for (dxBody *const *bodycurr = body; bodycurr != bodyend; ac_ptr+=6, invIrow += 12, vnew_ptr+=6, bodycurr++) {
+      // compute the velocity update:
+      // add stepsize * invM * f_all to the body velocity
+      dxBody *b = *bodycurr;
+      dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+      dReal tmp3[3];
+      for (int j=0; j<3; j++) {
+        // note that (ac) is an acceleration, hence there is
+        // add stepsize * ac to the body velocity
+        vnew_ptr[j]   = b->lvel[j] + stepsize * ac_ptr[j]   + body_invMass_mul_stepsize * b->facc[j];
+        vnew_ptr[j+3] = b->avel[j] + stepsize * ac_ptr[j+3];
+
+        // accumulate step*torques
+        tmp3[j] = stepsize*b->tacc[j];
+      }
+      // vnew = invI * f_all
+      dMultiplyAdd0_331 (vnew_ptr+3, invIrow, tmp3);
+
+    }
+  }
+}
+
+// vnew = J * M * vnew / stepsize
+static void multiply_JM (const int nb, const int m, dRealPtr J, dRealPtr I, dxBody * const *body, int *jb, dReal stepsize, dRealMutablePtr vnew)
+{
+  const dReal stepsize1 = dRecip(stepsize);
+  dReal tmp1[nb*6];
+  dReal *tmp1curr = tmp1;
+  dRealPtr vnewcurr = vnew;
+  const dReal *Irow = I;
+  dxBody *const *const bodyend = body + nb;
+  for (dxBody *const *bodycurr = body; bodycurr != bodyend; vnewcurr+=6, tmp1curr+=6, Irow+=12, bodycurr++) {
+    dxBody *b_ptr = *bodycurr;
+    dReal body_mass = b_ptr->mass.mass;
+    for (int j=0; j<3; j++) tmp1curr[j] = body_mass * vnewcurr[j] * stepsize1;
+    dReal tmpa[3];
+    for (int j=0; j<3; j++) tmpa[j] = vnewcurr[j+3] * stepsize1;
+    dMultiply0_331 (tmp1curr + 3,Irow,tmpa);
+  }
+  multiply_J (m,J,jb,tmp1,vnew);
+}
+
+void computeRHSPrecon(dxWorldProcessContext *context, const int m, const int nb, dRealPtr invI, dRealPtr I, dxBody * const *body, const dReal stepsize1, dRealMutablePtr c, dRealMutablePtr J, int *jb, dRealMutablePtr rhs_precon)
+{
+    /************************************************************************************/
+    /*                                                                                  */
+    /*               compute preconditioned rhs                                         */
+    /*                                                                                  */
+    /*  J J' lambda = J * ( M * (vnew - v) / h + fe )                                   */
+    /*                                                                                  */
+    /*  initiallly vnew is zero                                                         */
+    /*                                                                                  */
+    /************************************************************************************/
+    // mimic computation of rhs, but do it with J*M*inv(J) prefixed for preconditioned case.
+    BEGIN_STATE_SAVE(context, tmp2state) {
+      IFTIMING (dTimerNow ("compute rhs_precon"));
+      
+      // compute the "preconditioned" right hand side `rhs_precon'
+      dReal *tmp1 = context->AllocateArray<dReal> (nb*6);
+      // this is slightly different than non precon, where M is left multiplied by the pre J terms
+      //
+      // tmp1 = M*v/h + fe
+      //
+      dReal *tmp1curr = tmp1;
+      const dReal *Irow = I;
+      dxBody *const *const bodyend = body + nb;
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; tmp1curr+=6, Irow+=12, bodycurr++) {
+        dxBody *b_ptr = *bodycurr;
+        dReal body_mass = b_ptr->mass.mass;
+        for (int j=0; j<3; j++) tmp1curr[j] = b_ptr->facc[j] +  0* body_mass * b_ptr->lvel[j] * stepsize1;
+        dReal tmpa[3];
+        for (int j=0; j<3; j++) tmpa[j] = 0* b_ptr->avel[j] * stepsize1;
+        dMultiply0_331 (tmp1curr + 3,Irow,tmpa);
+        for (int k=0; k<3; k++) tmp1curr[3+k] += b_ptr->tacc[k];
+      }
+      //
+      // rhs_precon = - J * (M*v/h + fe)
+      //
+      multiply_J (m,J,jb,tmp1,rhs_precon);
+
+      //
+      // TODO: rhs_precon = J * inv(M) * c / h - J * (M*v/h + fe)
+      //
+      // c is the acceleration in the direction of the constraint, i.e. J * accel_inertial_frame
+      // so here, we want the forces forces in the constraint directions.
+      //
+      // analogously, we can view them as either velocity vs. momentum (m*v)
+      //  basically one is mass * the other one.
+      //
+      // The problem here is... everything is ok if velocity/acceleration is zero, but
+      //   momentum/forces are NOT zero even if velocity is zero.
+      //
+      // Question, can we do:  JM .dot. Jv (or JM .dot. c) for momentum/force
+      //   in the direction of the constraints?
+      //
+      for (int i=0; i<m; i++) rhs_precon[i] = 0*c[i]*stepsize1 - rhs_precon[i];
+
+
+      /*  DEBUG PRINTOUTS
+      printf("\n");
+      for (int i=0; i<m; i++) printf("c[%d] = %f\n",i,c[i]);
+      printf("\n");
+      */
+    } END_STATE_SAVE(context, tmp2state);
+
+    // complete rhs
+    //for (int i=0; i<m; i++) rhs_precon[i] = - rhs_precon[i];
+}
+
+
 static void ComputeRows(
                 int thread_id,
                 IndexError* order,
                 dxBody* const *body,
-                int* tmpInt,
-                dReal* tmpReal,
-                const int** tmpIntPtr,
-                dRealPtr* tmpRealPtr,
-                dRealMutablePtr* tmpMutablePtr,
+                dxSORLCPParameters params,
                 boost::recursive_mutex* mutex)
 {
   struct timeval tv;
@@ -379,37 +541,103 @@
   cur_time = (double)tv.tv_sec + (double)tv.tv_usec / 1.e6;
   //printf("thread %d started at time %f\n",thread_id,cur_time);
 
-  //boost::recursive_mutex::scoped_lock lock(*mutex); // put in fc read/writes?
-  int startRow           = tmpInt[0];
-  int nRows              = tmpInt[1];
-  int m                  = tmpInt[2];
-  int nb                 = tmpInt[3];
-  int num_iterations     = tmpInt[5];
-  dReal stepsize         = tmpReal[0];
-  dReal sor_lcp_tolerance= tmpReal[1];
-  const int* jb                = tmpIntPtr[0];
-  const int* findex            = tmpIntPtr[1];
-  dRealPtr        Ad           = tmpRealPtr[0];
-  dRealPtr        hi           = tmpRealPtr[1];
-  dRealPtr        lo           = tmpRealPtr[2];
-  dRealPtr        Adcfm        = tmpRealPtr[3];
-  dRealPtr        invI         = tmpRealPtr[5];
-  dRealMutablePtr b            = tmpMutablePtr[0];
-  dRealMutablePtr J            = tmpMutablePtr[1];
-  dRealMutablePtr fc           = tmpMutablePtr[2];
-  dRealMutablePtr lambda       = tmpMutablePtr[3];
-  dRealMutablePtr iMJ          = tmpMutablePtr[4];
+  //boost::recursive_mutex::scoped_lock lock(*mutex); // put in ac read/writes?
+  int startRow                 = params.nStart;   // 0
+  int nRows                    = params.nChunkSize; // m
+  int m                        = params.m; // m
+  int nb                       = params.nb;
+  int num_iterations           = params.num_iterations;
+  int precon_iterations        = params.precon_iterations;
+  dReal stepsize               = params.stepsize;
+  dReal sor_lcp_tolerance      = params.sor_lcp_tolerance;
+  int* jb                      = params.jb;
+  const int* findex            = params.findex;
+  dRealPtr        Ad           = params.Ad;
+  dRealPtr        hi           = params.hi;
+  dRealPtr        lo           = params.lo;
+  dRealPtr        Adcfm        = params.Adcfm;
+  dRealPtr        invI         = params.invI;
+  dRealPtr        I            = params.I;
+  dRealPtr        Ad_precon    = params.Ad_precon;
+  dRealPtr        Adcfm_precon = params.Adcfm_precon;
+  dRealPtr        JiMratio     = params.JiMratio;
+  dRealMutablePtr vnew         = params.vnew;
+  dRealMutablePtr b            = params.b;
+  dRealMutablePtr J            = params.J;
+  dRealMutablePtr ac           = params.ac;
+  dRealMutablePtr lambda       = params.lambda;
+  dRealMutablePtr iMJ          = params.iMJ;
+  dRealMutablePtr delta_error  = params.delta_error;
+  dRealMutablePtr b_precon     = params.b_precon;
+  dRealMutablePtr J_precon     = params.J_precon;
+  dRealMutablePtr J_orig       = params.J_orig;
+  dRealMutablePtr fc           = params.fc;
 #ifdef REORDER_CONSTRAINTS
-  dRealMutablePtr last_lambda  = tmpMutablePtr[10];
+  dRealMutablePtr last_lambda  = params.last_lambda;
 #endif
-  dRealMutablePtr delta_error  = tmpMutablePtr[11];
 
   //printf("iiiiiiiii %d %d %d\n",thread_id,jb[0],jb[1]);
   //for (int i=startRow; i<startRow+nRows; i++) // swap within boundary of our own segment
   //  printf("wwwwwwwwwwwww>id %d start %d n %d  order[%d].index=%d\n",thread_id,startRow,nRows,i,order[i].index);
 
+
+
+
+
+/*  DEBUG PRINTOUTS
+  // print J_orig
+  printf("J_orig\n");
+  for (int i=0; i < m ; i++) {
+    for (int j=0; j < 12 ; j++) {
+      printf("	%12.6f",J_orig[i*12+j]);
+    }
+    printf("\n");
+  }
+  printf("\n");
+
+  // print J, J_precon (already premultiplied by inverse of diagonal of LHS) and b_precon and b
+  printf("J_precon\n");
+  for (int i=0; i < m ; i++) {
+    for (int j=0; j < 12 ; j++) {
+      printf("	%12.6f",J_precon[i*12+j]);
+    }
+    printf("\n");
+  }
+  printf("\n");
+
+  printf("J\n");
+  for (int i=0; i < m ; i++) {
+    for (int j=0; j < 12 ; j++) {
+      printf("	%12.6f",J[i*12+j]);
+    }
+    printf("\n");
+  }
+  printf("\n");
+
+  printf("b_precon\n");
+  for (int i=0; i < m ; i++) printf("	%12.6f",b_precon[i]);
+  printf("\n");
+
+  printf("b\n");
+  for (int i=0; i < m ; i++) printf("	%12.6f",b[i]);
+  printf("\n");
+*/
+
+
+
+
+
+  // FIME: preconditioning can be defined insdie iterations loop now, becareful to match last iteration with
+  //       velocity update
+  bool preconditioning;
   for (int iteration=0; iteration < num_iterations; iteration++) {
 
+    if (iteration < precon_iterations) preconditioning = true;
+    else                               preconditioning = false;
+
+    //if (iteration%precon_iterations == 0) preconditioning = true; // every precon_iterations, do preconditioning
+    //else                                  preconditioning = false;
+
 #ifdef REORDER_CONSTRAINTS
     // constraints with findex < 0 always come first.
     if (iteration < 2) {
@@ -489,6 +717,10 @@
     //dSetZero (delta_error,m);
     dReal rms_error = 0;
 
+    dRealMutablePtr ac_ptr1;
+    dRealMutablePtr ac_ptr2;
+    dRealMutablePtr fc_ptr1;
+    dRealMutablePtr fc_ptr2;
     for (int i=startRow; i<startRow+nRows; i++) {
 
       //boost::recursive_mutex::scoped_lock lock(*mutex); // lock for every row
@@ -500,13 +732,13 @@
 
       int index = order[i].index;
 
-      dRealMutablePtr fc_ptr1;
-      dRealMutablePtr fc_ptr2;
       dReal delta;
 
       {
         int b1 = jb[index*2];
         int b2 = jb[index*2+1];
+        ac_ptr1 = ac + 6*b1;
+        ac_ptr2 = (b2 >= 0) ? ac + 6*b2 : NULL;
         fc_ptr1 = fc + 6*b1;
         fc_ptr2 = (b2 >= 0) ? fc + 6*b2 : NULL;
       }
@@ -514,19 +746,57 @@
       dReal old_lambda = lambda[index];
 
       {
-        delta = b[index] - old_lambda*Adcfm[index];
-        dRealPtr J_ptr = J + index*12;
-        // @@@ potential optimization: SIMD-ize this and the b2 >= 0 case
-        delta -=fc_ptr1[0] * J_ptr[0] + fc_ptr1[1] * J_ptr[1] +
-          fc_ptr1[2] * J_ptr[2] + fc_ptr1[3] * J_ptr[3] +
-          fc_ptr1[4] * J_ptr[4] + fc_ptr1[5] * J_ptr[5];
-        // @@@ potential optimization: handle 1-body constraints in a separate
-        //     loop to avoid the cost of test & jump?
-        if (fc_ptr2) {
-          delta -=fc_ptr2[0] * J_ptr[6] + fc_ptr2[1] * J_ptr[7] +
-            fc_ptr2[2] * J_ptr[8] + fc_ptr2[3] * J_ptr[9] +
-            fc_ptr2[4] * J_ptr[10] + fc_ptr2[5] * J_ptr[11];
+        if (preconditioning)
+        {
+          // modify rhs_precon by adding J * M * vnew / stepsize
+          // update delta
+          delta = b_precon[index] /* + vnew[index] */ - old_lambda*Adcfm_precon[index];
+
+          // ac is constraint acceleration in the non-precon case,
+          //  and fc is the actual constraint force in the precon case
+          // J_precon and J differs essentially in Ad and Ad_precon,
+          //  Ad is derived from diagonal of J inv(M) J'
+          //  Ad_precon is derived from diagonal of J J'
+          dRealPtr J_ptr = J_precon + index*12;
+
+          // for preconditioned case, update delta using fc, not ac
+
+          // @@@ potential optimization: SIMD-ize this and the b2 >= 0 case
+          delta -=fc_ptr1[0] * J_ptr[0] + fc_ptr1[1] * J_ptr[1] +
+                  fc_ptr1[2] * J_ptr[2] + fc_ptr1[3] * J_ptr[3] +
+                  fc_ptr1[4] * J_ptr[4] + fc_ptr1[5] * J_ptr[5];
+          // @@@ potential optimization: handle 1-body constraints in a separate
+          //     loop to avoid the cost of test & jump?
+          if (fc_ptr2) {
+            delta -=fc_ptr2[0] * J_ptr[6]  + fc_ptr2[1] * J_ptr[7] +
+                    fc_ptr2[2] * J_ptr[8]  + fc_ptr2[3] * J_ptr[9] +
+                    fc_ptr2[4] * J_ptr[10] + fc_ptr2[5] * J_ptr[11];
+          }
         }
+        else
+        {
+          delta = b[index] - old_lambda*Adcfm[index];
+          // update vnew,
+          //updateVnew(nb, invI, ac, body, stepsize, vnew);
+          // compute J * M * vnew / stepsize and store in vnew
+          //multiply_JM (nb, m, J, I, body, jb, stepsize, vnew);
+
+          dRealPtr J_ptr = J + index*12;
+          // @@@ potential optimization: SIMD-ize this and the b2 >= 0 case
+          delta -=ac_ptr1[0] * J_ptr[0] + ac_ptr1[1] * J_ptr[1] +
+                  ac_ptr1[2] * J_ptr[2] + ac_ptr1[3] * J_ptr[3] +
+                  ac_ptr1[4] * J_ptr[4] + ac_ptr1[5] * J_ptr[5];
+          // @@@ potential optimization: handle 1-body constraints in a separate
+          //     loop to avoid the cost of test & jump?
+          if (ac_ptr2) {
+            delta -=ac_ptr2[0] * J_ptr[6]  + ac_ptr2[1] * J_ptr[7] +
+                    ac_ptr2[2] * J_ptr[8]  + ac_ptr2[3] * J_ptr[9] +
+                    ac_ptr2[4] * J_ptr[10] + ac_ptr2[5] * J_ptr[11];
+          }
+        }
+
+
+
       }
 
       {
@@ -572,25 +842,56 @@
       //delta *= ramp;
       
       {
-        dRealPtr iMJ_ptr = iMJ + index*12;
-        // update fc.
-        // @@@ potential optimization: SIMD for this and the b2 >= 0 case
-        fc_ptr1[0] += delta * iMJ_ptr[0];
-        fc_ptr1[1] += delta * iMJ_ptr[1];
-        fc_ptr1[2] += delta * iMJ_ptr[2];
-        fc_ptr1[3] += delta * iMJ_ptr[3];
-        fc_ptr1[4] += delta * iMJ_ptr[4];
-        fc_ptr1[5] += delta * iMJ_ptr[5];
-        // @@@ potential optimization: handle 1-body constraints in a separate
-        //     loop to avoid the cost of test & jump?
-        if (fc_ptr2) {
-          fc_ptr2[0] += delta * iMJ_ptr[6];
-          fc_ptr2[1] += delta * iMJ_ptr[7];
-          fc_ptr2[2] += delta * iMJ_ptr[8];
-          fc_ptr2[3] += delta * iMJ_ptr[9];
-          fc_ptr2[4] += delta * iMJ_ptr[10];
-          fc_ptr2[5] += delta * iMJ_ptr[11];
+        // no longer need iMJ, just need J' herea
+        // to clarify, iMJ is really computed as the inv(M) * J without any further modification
+        //if (preconditioning)
+        {
+          // for preconditioning case, compute fc
+          dRealPtr J_ptr = J_orig + index*12; // FIXME: need un-altered unscaled J, not J_precon!!
+
+          // update fc.
+          // @@@ potential optimization: SIMD for this and the b2 >= 0 case
+          fc_ptr1[0] += delta * J_ptr[0];
+          fc_ptr1[1] += delta * J_ptr[1];
+          fc_ptr1[2] += delta * J_ptr[2];
+          fc_ptr1[3] += delta * J_ptr[3];
+          fc_ptr1[4] += delta * J_ptr[4];
+          fc_ptr1[5] += delta * J_ptr[5];
+          // @@@ potential optimization: handle 1-body constraints in a separate
+          //     loop to avoid the cost of test & jump?
+          if (fc_ptr2) {
+            fc_ptr2[0] += delta * J_ptr[6];
+            fc_ptr2[1] += delta * J_ptr[7];
+            fc_ptr2[2] += delta * J_ptr[8];
+            fc_ptr2[3] += delta * J_ptr[9];
+            fc_ptr2[4] += delta * J_ptr[10];
+            fc_ptr2[5] += delta * J_ptr[11];
+          }
         }
+        //else
+        {
+          // for non-precon case, update ac
+          dRealPtr iMJ_ptr = iMJ + index*12;
+
+          // update ac.
+          // @@@ potential optimization: SIMD for this and the b2 >= 0 case
+          ac_ptr1[0] += delta * iMJ_ptr[0];
+          ac_ptr1[1] += delta * iMJ_ptr[1];
+          ac_ptr1[2] += delta * iMJ_ptr[2];
+          ac_ptr1[3] += delta * iMJ_ptr[3];
+          ac_ptr1[4] += delta * iMJ_ptr[4];
+          ac_ptr1[5] += delta * iMJ_ptr[5];
+          // @@@ potential optimization: handle 1-body constraints in a separate
+          //     loop to avoid the cost of test & jump?
+          if (ac_ptr2) {
+            ac_ptr2[0] += delta * iMJ_ptr[6];
+            ac_ptr2[1] += delta * iMJ_ptr[7];
+            ac_ptr2[2] += delta * iMJ_ptr[8];
+            ac_ptr2[3] += delta * iMJ_ptr[9];
+            ac_ptr2[4] += delta * iMJ_ptr[10];
+            ac_ptr2[5] += delta * iMJ_ptr[11];
+          }
+        }
       }
     } // end of for loop on m
 
@@ -643,14 +944,14 @@
     if (rms_error < sor_lcp_tolerance)
     {
       #ifdef REPORT_MONITOR
-        printf("CONVERGED: id: %d steps: %d rms(%20.18f)\n",thread_id,iteration,rms_error);
+        printf("CONVERGED: id: %d steps: %d rms(%20.18f < %20.18f)\n",thread_id,iteration,rms_error,sor_lcp_tolerance);
       #endif
       break;
     }
     else if (iteration == num_iterations -1)
     {
       #ifdef REPORT_MONITOR
-        printf("**********ERROR: id: %d did not converge in %d steps, rms(%20.18f)\n",thread_id,num_iterations,rms_error);
+        printf("WARNING: id: %d did not converge in %d steps, rms(%20.18f > %20.18f)\n",thread_id,num_iterations,rms_error,sor_lcp_tolerance);
       #endif
     }
 
@@ -664,10 +965,11 @@
 }
 
 static void SOR_LCP (dxWorldProcessContext *context,
-  const int m, const int nb, dRealMutablePtr J, int *jb, dxBody * const *body,
-  dRealPtr invI, dRealMutablePtr lambda, dRealMutablePtr fc, dRealMutablePtr b,
+  const int m, const int nb, dRealMutablePtr J, dRealMutablePtr J_precon, dRealMutablePtr J_orig, int *jb, dxBody * const *body,
+  dRealPtr invI, dRealPtr I, dRealMutablePtr lambda, dRealMutablePtr ac, dRealMutablePtr fc, dRealMutablePtr b, dRealMutablePtr b_precon,
   dRealPtr lo, dRealPtr hi, dRealPtr cfm, const int *findex,
   const dxQuickStepParameters *qs,
+  dRealMutablePtr JiM, dRealMutablePtr JiMratio,
 #ifdef USE_TPROW
   boost::threadpool::pool* row_threadpool,
 #endif
@@ -690,8 +992,10 @@
   // compute fc=(inv(M)*J')*lambda. we will incrementally maintain fc
   // as we change lambda.
 #ifdef WARM_STARTING
-  multiply_invM_JT (m,nb,iMJ,jb,lambda,fc);
+  multiply_invM_JT (m,nb,J,jb,lambda,fc);
+  multiply_invM_JT (m,nb,iMJ,jb,lambda,ac);
 #else
+  dSetZero (ac,nb*6);
   dSetZero (fc,nb*6);
 #endif
 
@@ -712,11 +1016,60 @@
     }
   }
 
+  // recompute Ad for preconditioned case, Ad_precon is similar to Ad but
+  //   whereas Ad is 1 over diagonals of J inv(M) J'
+  //    Ad_precon is 1 over diagonals of J J'
+  dReal *Ad_precon = context->AllocateArray<dReal> (m);
 
+  {
+    const dReal sor_w = qs->w;		// SOR over-relaxation parameter
+    // precompute 1 / diagonals of A
+    // preconditioned version uses J instead of iMJ
+    dRealPtr J_ptr = J;
+    for (int i=0; i<m; J_ptr += 12, i++) {
+      dReal sum = 0;
+      for (int j=0; j<6; j++) sum += J_ptr[j] * J_ptr[j];
+      if (jb[i*2+1] >= 0) {
+        for (int k=6; k<12; k++) sum += J_ptr[k] * J_ptr[k];
+      }
+      Ad_precon[i] = sor_w / (sum + cfm[i]);
+    }
+  }
+
+  dReal *vnew = context->AllocateArray<dReal> (nb*6);
+
   /********************************/
   /* allocate for Adcfm           */
   /* which is a mX1 column vector */
   /********************************/
+  // compute Adcfm_precon for the preconditioned case
+  //   do this first before J gets altered (J's diagonals gets premultiplied by Ad)
+  //   and save a copy of J into J_orig
+  //   as J becomes J * Ad, J_precon becomes J * Ad_precon
+  dReal *Adcfm_precon = context->AllocateArray<dReal> (m);
+
+
+  {
+    // NOTE: This may seem unnecessary but it's indeed an optimization 
+    // to move multiplication by Ad[i] and cfm[i] out of iteration loop.
+
+    // scale J_precon and b_precon by Ad
+    // copy J_orig
+    dRealMutablePtr J_ptr = J;
+    dRealMutablePtr J_precon_ptr = J_precon;
+    dRealMutablePtr J_orig_ptr = J_orig;
+    for (int i=0; i<m; J_ptr += 12, J_precon_ptr += 12, J_orig_ptr += 12, i++) {
+      dReal Ad_precon_i = Ad_precon[i];
+      for (int j=0; j<12; j++) {
+        J_precon_ptr[j] = J_ptr[j] * Ad_precon_i;
+        J_orig_ptr[j] = J_ptr[j]; //copy J
+      }
+      b_precon[i] *= Ad_precon_i;
+      // scale Ad by CFM. N.B. this should be done last since it is used above
+      Adcfm_precon[i] = Ad_precon_i * cfm[i];
+    }
+  }
+
   dReal *Adcfm = context->AllocateArray<dReal> (m);
 
 
@@ -770,39 +1123,20 @@
 
   boost::recursive_mutex* mutex = new boost::recursive_mutex();
 
-  const int num_iterations = qs->num_iterations;
-  // single iteration, through all the constraints
-
-
-
-
-
-
-
-
-
+  // number of chunks must be at least 1
+  // (single iteration, through all the constraints)
   int num_chunks = qs->num_chunks > 0 ? qs->num_chunks : 1; // min is 1
 
   // prepare pointers for threads
-  int tmpInt_size = 6;
-  int tmpInt[tmpInt_size*num_chunks];
-  int tmpReal_size = 2;
-  dReal tmpReal[tmpReal_size*num_chunks];
-  int tmpIntPtr_size = 3;
-  const int* tmpIntPtr[tmpIntPtr_size*num_chunks];
-  int tmpRealPtr_size = 8;
-  dRealPtr tmpRealPtr[tmpRealPtr_size*num_chunks];
-  int tmpMutablePtr_size = 12;
-  dRealMutablePtr tmpMutablePtr[tmpMutablePtr_size*num_chunks];
+  dxSORLCPParameters params[num_chunks];
 
-  int num_overlap = qs->num_overlap;
+  // divide into chunks sequentially
   int chunk = m / num_chunks+1;
   chunk = chunk > 0 ? chunk : 1;
   int thread_id = 0;
 
 
-
-
+  // timing
   struct timeval tv;
   double cur_time;
   gettimeofday(&tv,NULL);
@@ -810,55 +1144,60 @@
   //printf("    quickstep start threads at time %f\n",cur_time);
 
 
-
-
   IFTIMING (dTimerNow ("start pgs rows"));
   for (int i=0; i<m; i+= chunk,thread_id++)
   {
-    //for (int ijk=0;ijk<m;ijk++) printf("aaaaaaaaaaaaaaaaaaaaa> id:%d jb[%d]=%d\n",thread_id,ijk,jb[ijk]);
+    //for (int ijk=0;ijk<m;ijk++) printf("thread_id> id:%d jb[%d]=%d\n",thread_id,ijk,jb[ijk]);
 
-    int nStart = i - num_overlap < 0 ? 0 : i - num_overlap;
-    int nEnd   = i + chunk + num_overlap;
+    int nStart = i - qs->num_overlap < 0 ? 0 : i - qs->num_overlap;
+    int nEnd   = i + chunk + qs->num_overlap;
     if (nEnd > m) nEnd = m;
     // if every one reorders constraints, this might just work
     // comment out below if using defaults (0 and m) so every thread runs through all joints
-    tmpInt[0+thread_id*tmpInt_size] = nStart;   // 0
-    tmpInt[1+thread_id*tmpInt_size] = nEnd - nStart; // m
-    tmpInt[2+thread_id*tmpInt_size] = m; // m
-    tmpInt[3+thread_id*tmpInt_size] = nb;
-    tmpInt[5+thread_id*tmpInt_size] = num_iterations;
-    tmpReal[0+thread_id*tmpReal_size] = stepsize;
-    tmpReal[1+thread_id*tmpReal_size] = qs->sor_lcp_tolerance;
-    tmpIntPtr[0+thread_id*tmpIntPtr_size] = jb;
-    tmpIntPtr[1+thread_id*tmpIntPtr_size] = findex;
-    tmpRealPtr[0+thread_id*tmpRealPtr_size] = Ad;
-    tmpRealPtr[1+thread_id*tmpRealPtr_size] = hi;
-    tmpRealPtr[2+thread_id*tmpRealPtr_size] = lo;
-    tmpRealPtr[3+thread_id*tmpRealPtr_size] = Adcfm;
-    tmpRealPtr[5+thread_id*tmpRealPtr_size] = invI;
-    tmpMutablePtr[0+thread_id*tmpMutablePtr_size] = b;
-    tmpMutablePtr[1+thread_id*tmpMutablePtr_size] = J;
-    tmpMutablePtr[2+thread_id*tmpMutablePtr_size] = fc;
-    tmpMutablePtr[3+thread_id*tmpMutablePtr_size] = lambda;
-    tmpMutablePtr[4+thread_id*tmpMutablePtr_size] = iMJ;
-    tmpMutablePtr[11+thread_id*tmpMutablePtr_size] = delta_error ;
+    params[thread_id].nStart = nStart;   // 0
+    params[thread_id].nChunkSize = nEnd - nStart; // m
+    params[thread_id].m = m; // m
+    params[thread_id].nb = nb;
+    params[thread_id].num_iterations = qs->num_iterations;
+    params[thread_id].precon_iterations = qs->precon_iterations;
+    params[thread_id].stepsize = stepsize;
+    params[thread_id].sor_lcp_tolerance = qs->sor_lcp_tolerance;
+    params[thread_id].jb = jb;
+    params[thread_id].findex = findex;
+    params[thread_id].Ad = Ad;
+    params[thread_id].hi = hi;
+    params[thread_id].lo = lo;
+    params[thread_id].Adcfm = Adcfm;
+    params[thread_id].invI = invI;
+    params[thread_id].I= I;
+    params[thread_id].Ad_precon = Ad_precon;
+    params[thread_id].Adcfm_precon = Adcfm_precon;
+    params[thread_id].vnew = vnew;
+    params[thread_id].JiMratio = JiMratio;
+    params[thread_id].b = b;
+    params[thread_id].J = J;
+    params[thread_id].ac = ac;
+    params[thread_id].lambda = lambda;
+    params[thread_id].iMJ = iMJ;
+    params[thread_id].delta_error  = delta_error ;
+    params[thread_id].b_precon  = b_precon ;
+    params[thread_id].J_precon  = J_precon ;
+    params[thread_id].J_orig  = J_orig ;
+    params[thread_id].fc  = fc ;
+#ifdef REORDER_CONSTRAINTS
+    params[thread_id].last_lambda  = last_lambda ;
+#endif
 
 #ifdef REPORT_MONITOR
     printf("thread summary: id %d i %d m %d chunk %d start %d end %d \n",thread_id,i,m,chunk,nStart,nEnd);
 #endif
 #ifdef USE_TPROW
     if (row_threadpool && row_threadpool->size() > 0)
-      row_threadpool->schedule(boost::bind(ComputeRows,thread_id,order, body, tmpInt+thread_id*tmpInt_size,
-                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
-                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex));
+      row_threadpool->schedule(boost::bind(ComputeRows,thread_id,order, body, params[thread_id], mutex));
     else //automatically skip threadpool if only 1 thread allocated
-      ComputeRows(thread_id,order, body, tmpInt+thread_id*tmpInt_size,
-                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
-                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex);
+      ComputeRows(thread_id,order, body, params[thread_id], mutex);
 #else
-    ComputeRows(thread_id,order, body, tmpInt+thread_id*tmpInt_size,
-                           tmpReal+thread_id*tmpReal_size, tmpIntPtr+thread_id*tmpIntPtr_size,
-                           tmpRealPtr+thread_id*tmpRealPtr_size, tmpMutablePtr+thread_id*tmpMutablePtr_size, mutex);
+    ComputeRows(thread_id,order, body, params[thread_id], mutex);
 #endif
   }
 
@@ -911,26 +1250,28 @@
   // frame, and compute the rotational force and add it to the torque
   // accumulator. I and invI are a vertical stack of 3x4 matrices, one per body.
   dReal *invI = context->AllocateArray<dReal> (3*4*nb);
+  dReal *I = context->AllocateArray<dReal> (3*4*nb);
 
   {
     dReal *invIrow = invI;
+    dReal *Irow = I;
     dxBody *const *const bodyend = body + nb;
-    for (dxBody *const *bodycurr = body; bodycurr != bodyend; invIrow += 12, bodycurr++) {
+    for (dxBody *const *bodycurr = body; bodycurr != bodyend; invIrow += 12, Irow += 12, bodycurr++) {
       dMatrix3 tmp;
-      dxBody *b = *bodycurr;
+      dxBody *b_ptr = *bodycurr;
 
       // compute inverse inertia tensor in global frame
-      dMultiply2_333 (tmp,b->invI,b->posr.R);
-      dMultiply0_333 (invIrow,b->posr.R,tmp);
+      dMultiply2_333 (tmp,b_ptr->invI,b_ptr->posr.R);
+      dMultiply0_333 (invIrow,b_ptr->posr.R,tmp);
 
-      if (b->flags & dxBodyGyroscopic) {
-        dMatrix3 I;
-        // compute inertia tensor in global frame
-        dMultiply2_333 (tmp,b->mass.I,b->posr.R);
-        dMultiply0_333 (I,b->posr.R,tmp);
+      // also store I for later use by preconditioner
+      dMultiply2_333 (tmp,b_ptr->mass.I,b_ptr->posr.R);
+      dMultiply0_333 (Irow,b_ptr->posr.R,tmp);
+
+      if (b_ptr->flags & dxBodyGyroscopic) {
         // compute rotational force
-        dMultiply0_331 (tmp,I,b->avel);
-        dSubtractVectorCross3(b->tacc,b->avel,tmp);
+        dMultiply0_331 (tmp,Irow,b_ptr->avel);
+        dSubtractVectorCross3(b_ptr->tacc,b_ptr->avel,tmp);
       }
     }
   }
@@ -941,9 +1282,9 @@
     dReal *invMrow = invM;
     dxBody *const *const bodyend = body + nb;
     for (dxBody *const *bodycurr = body; bodycurr != bodyend; invMrow++, bodycurr++) {
-      dxBody *b = *bodycurr;
-      //*invMrow = b->mass.mass;
-      *invMrow = b->invMass;
+      dxBody *b_ptr = *bodycurr;
+      //*invMrow = b_ptr->mass.mass;
+      *invMrow = b_ptr->invMass;
 
     }
   }
@@ -957,27 +1298,27 @@
     dReal gravity_x = world->gravity[0];
     if (gravity_x) {
       for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
-        dxBody *b = *bodycurr;
-        if ((b->flags & dxBodyNoGravity)==0) {
-          b->facc[0] += b->mass.mass * gravity_x;
+        dxBody *b_ptr = *bodycurr;
+        if ((b_ptr->flags & dxBodyNoGravity)==0) {
+          b_ptr->facc[0] += b_ptr->mass.mass * gravity_x;
         }
       }
     }
     dReal gravity_y = world->gravity[1];
     if (gravity_y) {
       for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
-        dxBody *b = *bodycurr;
-        if ((b->flags & dxBodyNoGravity)==0) {
-          b->facc[1] += b->mass.mass * gravity_y;
+        dxBody *b_ptr = *bodycurr;
+        if ((b_ptr->flags & dxBodyNoGravity)==0) {
+          b_ptr->facc[1] += b_ptr->mass.mass * gravity_y;
         }
       }
     }
     dReal gravity_z = world->gravity[2];
     if (gravity_z) {
       for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
-        dxBody *b = *bodycurr;
-        if ((b->flags & dxBodyNoGravity)==0) {
-          b->facc[2] += b->mass.mass * gravity_z;
+        dxBody *b_ptr = *bodycurr;
+        if ((b_ptr->flags & dxBodyNoGravity)==0) {
+          b_ptr->facc[2] += b_ptr->mass.mass * gravity_z;
         }
       }
     }
@@ -1026,10 +1367,14 @@
 
   // if there are constraints, compute the constraint force
   dReal *J = NULL;
+  dReal *J_precon = NULL;
+  dReal *J_orig = NULL;
+  dReal *JiM = NULL;
+  dReal *JiMratio = NULL;
   int *jb = NULL;
 
   if (m > 0) {
-    dReal *cfm, *lo, *hi, *rhs, *Jcopy;
+    dReal *cfm, *lo, *hi, *rhs, *rhs_precon, *Jcopy;
     int *findex;
 
     {
@@ -1038,6 +1383,8 @@
       const unsigned jelements = mlocal*12;
       J = context->AllocateArray<dReal> (jelements);
       dSetZero (J,jelements);
+      J_precon = context->AllocateArray<dReal> (jelements);
+      J_orig = context->AllocateArray<dReal> (jelements);
 
       // create a constraint equation right hand side vector `c', a constraint
       // force mixing vector `cfm', and LCP low and high bound vectors, and an
@@ -1058,8 +1405,16 @@
       jb = context->AllocateArray<int> (jbelements);
 
       rhs = context->AllocateArray<dReal> (mlocal);
+      rhs_precon = context->AllocateArray<dReal> (mlocal);
 
       Jcopy = context->AllocateArray<dReal> (mfb*12);
+      JiM = context->AllocateArray<dReal> (mlocal*12); // not used
+      dSetZero (JiM,jelements);
+      // JiMratio is the element-wise maximum ratio between
+      //   Ja*inv(Ma) and Jb*inv(Mb) for a joint
+      // if the joint is one sided, then we preset it to 1
+      JiMratio = context->AllocateArray<dReal> (mlocal); // test variable
+      dSetZero (JiMratio,mlocal);
     }
 
     BEGIN_STATE_SAVE(context, cstate) {
@@ -1151,6 +1506,10 @@
         //printf("jjjjjjjjj %d %d\n",jb[0],jb[1]);
       }
 
+
+
+
+
       BEGIN_STATE_SAVE(context, tmp1state) {
         IFTIMING (dTimerNow ("compute rhs"));
         // compute the right hand side `rhs'
@@ -1160,21 +1519,89 @@
         const dReal *invIrow = invI;
         dxBody *const *const bodyend = body + nb;
         for (dxBody *const *bodycurr = body; bodycurr != bodyend; tmp1curr+=6, invIrow+=12, bodycurr++) {
-          dxBody *b = *bodycurr;
-          dReal body_invMass = b->invMass;
-          for (int j=0; j<3; j++) tmp1curr[j] = b->facc[j] * body_invMass + b->lvel[j] * stepsize1;
-          dMultiply0_331 (tmp1curr + 3,invIrow,b->tacc);
-          for (int k=0; k<3; k++) tmp1curr[3+k] += b->avel[k] * stepsize1;
+          dxBody *b_ptr = *bodycurr;
+          dReal body_invMass = b_ptr->invMass;
+          for (int j=0; j<3; j++) tmp1curr[j] = b_ptr->facc[j] * body_invMass + b_ptr->lvel[j] * stepsize1;
+          dMultiply0_331 (tmp1curr + 3,invIrow,b_ptr->tacc);
+          for (int k=0; k<3; k++) tmp1curr[3+k] += b_ptr->avel[k] * stepsize1;
         }
 
         // put J*tmp1 into rhs
         multiply_J (m,J,jb,tmp1,rhs);
+        /*************************************************************/
+        /* compute J*inv(M) here JiM, it does not change             */
+        /*************************************************************/
+        {
+          dRealPtr J_ptr = J;
+          dRealMutablePtr JiM_ptr = JiM; // intermediate solution storage
+          dRealMutablePtr JiMratio_ptr = JiMratio; // intermediate solution storage
+          for (int i=0; i<m;J_ptr+=12,JiM_ptr+=12, i++) {
+
+            // compute JiM = J * invM
+            int b1 = jb[i*2];
+            int b2 = jb[i*2+1];
+            dReal k1 = body[b1]->invMass;
+
+            for (int j=0; j<3 ; j++) JiM_ptr[j] = J_ptr[j]*k1;
+
+
+            const dReal *invI_ptr1 = invI + 12*b1;
+            for (int j=0;j<3;j++) {
+              JiM_ptr[3+j] = 0;
+              for (int k=0;k<3;k++){
+                JiM_ptr[3+j] += J_ptr[3+k]*invI_ptr1[k*4+j];
+              }
+            }
+
+            // preset JiMratio to 1
+            JiMratio_ptr[0] = 1.0;
+
+            if (b2 >= 0){
+              dReal k2 = body[b2]->invMass;
+              for (int j=0; j<3 ; j++) JiM_ptr[j+6] = k2*J_ptr[j+6];
+              const dReal *invI_ptr2 = invI + 12*b2;
+              for (int j=0;j<3;j++) {
+                JiM_ptr[9+j] = 0;
+                for (int k=0;k<3;k++) JiM_ptr[9+j] += J_ptr[9+k]*invI_ptr2[k*4+j];
+              }
+
+              // check element-wise ratio for JiMratio
+              JiMratio_ptr[0] = 1.0;
+              for (int j=0;j<3;j++) {
+                if  (JiM_ptr[  j] != 0) JiMratio_ptr[0] = std::max(JiMratio_ptr[0],JiM_ptr[6+j]/JiM_ptr[  j]);
+                if  (JiM_ptr[3+j] != 0) JiMratio_ptr[0] = std::max(JiMratio_ptr[0],JiM_ptr[9+j]/JiM_ptr[3+j]);
+                if  (JiM_ptr[6+j] != 0) JiMratio_ptr[0] = std::max(JiMratio_ptr[0],JiM_ptr[  j]/JiM_ptr[6+j]);
+                if  (JiM_ptr[9+j] != 0) JiMratio_ptr[0] = std::max(JiMratio_ptr[0],JiM_ptr[3+j]/JiM_ptr[9+j]);
+              }
+            }
+          }
+        }
       
       } END_STATE_SAVE(context, tmp1state);
 
       // complete rhs
       for (int i=0; i<m; i++) rhs[i] = c[i]*stepsize1 - rhs[i];
 
+
+
+
+
+
+
+      // compute rhs_precon
+      computeRHSPrecon(context, m, nb, invI, I, body, stepsize1, c, J, jb, rhs_precon);
+
+
+
+
+
+
+
+
+
+
+
+
       // scale CFM
       for (int j=0; j<m; j++) cfm[j] *= stepsize1;
 
@@ -1197,11 +1624,13 @@
 #endif
 
     dReal *cforce = context->AllocateArray<dReal> (nb*6);
+    dReal *caccel = context->AllocateArray<dReal> (nb*6);
 
     BEGIN_STATE_SAVE(context, lcpstate) {
       IFTIMING (dTimerNow ("solving LCP problem"));
       // solve the LCP problem and get lambda and invM*constraint_force
-      SOR_LCP (context,m,nb,J,jb,body,invI,lambda,cforce,rhs,lo,hi,cfm,findex,&world->qs,
+      SOR_LCP (context,m,nb,J,J_precon,J_orig,jb,body,invI,I,lambda,caccel,cforce,rhs,rhs_precon,lo,hi,cfm,findex,&world->qs,
+      JiM,JiMratio,
 #ifdef USE_TPROW
                world->row_threadpool,
 #endif
@@ -1234,13 +1663,17 @@
       // no premultiplying of invM here (compare to update due to external force 'facc' below)
       //
       // add stepsize * cforce to the body velocity
-      const dReal *cforcecurr = cforce;
+      // or better named,
+      // add stepsize * caccel to the body velocity
+      //
+      const dReal *caccelcurr = caccel;
       dxBody *const *const bodyend = body + nb;
-      for (dxBody *const *bodycurr = body; bodycurr != bodyend; cforcecurr+=6, bodycurr++) {
-        dxBody *b = *bodycurr;
+      // update assuming caccel is already acceleration
+      for (dxBody *const *bodycurr = body; bodycurr != bodyend; caccelcurr+=6, bodycurr++) {
+        dxBody *b_ptr = *bodycurr;
         for (int j=0; j<3; j++) {
-          b->lvel[j] += stepsize * cforcecurr[j];
-          b->avel[j] += stepsize * cforcecurr[3+j];
+          b_ptr->lvel[j] += stepsize * caccelcurr[j];
+          b_ptr->avel[j] += stepsize * caccelcurr[3+j];
         }
       }
     }
@@ -1294,13 +1727,13 @@
     const dReal *invIrow = invI;
     dxBody *const *const bodyend = body + nb;
     for (dxBody *const *bodycurr = body; bodycurr != bodyend; invIrow += 12, bodycurr++) {
-      dxBody *b = *bodycurr;
-      dReal body_invMass_mul_stepsize = stepsize * b->invMass;
+      dxBody *b_ptr = *bodycurr;
+      dReal body_invMass_mul_stepsize = stepsize * b_ptr->invMass;
       for (int j=0; j<3; j++) {
-        b->lvel[j] += body_invMass_mul_stepsize * b->facc[j];
-        b->tacc[j] *= stepsize;
+        b_ptr->lvel[j] += body_invMass_mul_stepsize * b_ptr->facc[j];
+        b_ptr->tacc[j] *= stepsize;
       }
-      dMultiplyAdd0_331 (b->avel, invIrow, b->tacc);
+      dMultiplyAdd0_331 (b_ptr->avel, invIrow, b_ptr->tacc);
     }
   }
 
@@ -1334,8 +1767,8 @@
     IFTIMING (dTimerNow ("update position"));
     dxBody *const *const bodyend = body + nb;
     for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
-      dxBody *b = *bodycurr;
-      dxStepBody (b,stepsize);
+      dxBody *b_ptr = *bodycurr;
+      dxStepBody (b_ptr,stepsize);
     }
   }
 
@@ -1344,9 +1777,9 @@
     // zero all force accumulators
     dxBody *const *const bodyend = body + nb;
     for (dxBody *const *bodycurr = body; bodycurr != bodyend; bodycurr++) {
-      dxBody *b = *bodycurr;
-      dSetZero (b->facc,3);
-      dSetZero (b->tacc,3);
+      dxBody *b_ptr = *bodycurr;
+      dSetZero (b_ptr->facc,3);
+      dSetZero (b_ptr->tacc,3);
     }
   }
 
@@ -1363,11 +1796,14 @@
 }
 #endif
 
-static size_t EstimateSOR_LCPMemoryRequirements(int m)
+static size_t EstimateSOR_LCPMemoryRequirements(int m,int nb)
 {
   size_t res = dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for iMJ
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Ad
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Adcfm
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Ad_precon
+  res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for Adcfm_precon
+  res += dEFFICIENT_SIZE(sizeof(dReal) * nb*6); // for vnew
   res += dEFFICIENT_SIZE(sizeof(dReal) * m); // for delta_error
   res += dEFFICIENT_SIZE(sizeof(IndexError) * m); // for order
 #ifdef REORDER_CONSTRAINTS
@@ -1404,6 +1840,7 @@
   size_t res = 0;
 
   res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for invI
+  res += dEFFICIENT_SIZE(sizeof(dReal) * 3 * 4 * nb); // for I needed by preconditioner
   res += dEFFICIENT_SIZE(sizeof(dReal) * nb); // for invM
 
   {
@@ -1412,12 +1849,22 @@
     size_t sub1_res2 = dEFFICIENT_SIZE(sizeof(dJointWithInfo1) * nj); // for shrunk jointiinfos
     if (m > 0) {
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for J
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for J_precon
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for J_orig
       sub1_res2 += 4 * dEFFICIENT_SIZE(sizeof(dReal) * m); // for cfm, lo, hi, rhs
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m); // for rhs_precon
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * 2 * m); // for jb            FIXME: shoulbe be 2 not 12?
       sub1_res2 += dEFFICIENT_SIZE(sizeof(int) * m); // for findex
       sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * mfb); // for Jcopy
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 12 * m); // for JiM
+      sub1_res2 += dEFFICIENT_SIZE(sizeof(dReal) * m); // for JiMratio
       {
         size_t sub2_res1 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for c
+        //sub2_res1 += dEFFICIENT_SIZE(sizeof(int)   * 6 * nb); // for JTJfindex
+        //sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb * 6 * nb); // for JTJ
+        //sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for JTrhs
+        sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for invJrhs
+        sub2_res1 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for invJrhs_updated
         {
           size_t sub3_res1 = dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for tmp1
     
@@ -1428,8 +1875,9 @@
 
         size_t sub2_res2 = dEFFICIENT_SIZE(sizeof(dReal) * m); // for lambda
         sub2_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for cforce
+        sub2_res2 += dEFFICIENT_SIZE(sizeof(dReal) * 6 * nb); // for caccel
         {
-          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m); // for SOR_LCP
+          size_t sub3_res1 = EstimateSOR_LCPMemoryRequirements(m,nb); // for SOR_LCP
 
           size_t sub3_res2 = 0;
 #ifdef CHECK_VELOCITY_OBEYS_CONSTRAINT
Index: ode/src/objects.h
===================================================================
--- ode/src/objects.h	(revision 1806)
+++ ode/src/objects.h	(working copy)
@@ -96,6 +96,7 @@
 
 // quick-step parameters
 struct dxQuickStepParameters {
+  int precon_iterations;	// number of preconditioned SOR iterations to perform (without error correction)
   int num_iterations;		// number of SOR iterations to perform
   dReal w;			// the SOR over-relaxation parameter
   int num_chunks;		// divide rows to these many chunks
Index: ode/src/ode.cpp
===================================================================
--- ode/src/ode.cpp	(revision 1806)
+++ ode/src/ode.cpp	(working copy)
@@ -1629,6 +1629,7 @@
   w->adis.linear_average_threshold = REAL(0.01)*REAL(0.01);		// (magnitude squared)
 
   w->qs.num_iterations = 20;
+  w->qs.precon_iterations = 0;
   w->qs.w = REAL(1.3);
   w->qs.num_chunks = 1;
   w->qs.num_overlap = 0;
@@ -2143,6 +2144,11 @@
 	dAASSERT(w);
 	w->qs.num_iterations = num;
 }
+void dWorldSetQuickStepPreconIterations (dWorldID w, int num)
+{
+	dAASSERT(w);
+	w->qs.precon_iterations = num;
+}
 
 
 int dWorldGetQuickStepNumIterations (dWorldID w)
